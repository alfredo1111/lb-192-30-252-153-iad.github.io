/**
 * @version 1.0.0.0
 * @copyright Copyright Â©  2016
 * @compiler Bridge.NET 17.1.1
 */
Bridge.assembly("Kusto.JavaScript.Client", function ($asm, globals) {
    "use strict";

    Bridge.define("Kusto.Charting.ArgumentColumnType", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Numeric: 2,
                DateTime: 4,
                TimeSpan: 8,
                String: 16,
                Object: 32,
                DateTimeOrTimeSpan: 12,
                StringOrDateTimeOrTimeSpan: 28,
                NumericOrDateTimeOrTimeSpan: 14,
                StringOrObject: 48,
                All: 62
            }
        },
        $flags: true
    });

    Bridge.define("Kusto.Charting.ArgumentRestrictions", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                MustHave: 1,
                NotIncludedInSeries: 2
            }
        },
        $flags: true
    });

    Bridge.define("Kusto.Charting.ChartKind", {
        $kind: "enum",
        statics: {
            fields: {
                Unspecified: 0,
                Line: 1,
                Point: 2,
                Bar: 3
            }
        }
    });

    Bridge.define("Kusto.Charting.DataChartsHelper", {
        statics: {
            fields: {
                c_minFractionOfIntervalsToDetectDistribution: 0,
                c_minElementsAmountToFillGapsWithNans: 0,
                c_decimalRoundingPrecision: 0,
                c_doubleAcceptableApproximation: 0
            },
            ctors: {
                init: function () {
                    this.c_minFractionOfIntervalsToDetectDistribution = 0.8;
                    this.c_minElementsAmountToFillGapsWithNans = 4;
                    this.c_decimalRoundingPrecision = 8;
                    this.c_doubleAcceptableApproximation = 1E-08;
                }
            },
            methods: {
                /**
                 * Generates set of a DataItem objects from provided structure,
                 based on required argument parameters(column type and restrictions).
                 Takes in account x-columns, y-columns and series if provided.
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {Kusto.Charting.IChartingDataSource}          table                   Data source, which has to implement IChartingDataSource.
                 * @param   {Kusto.Charting.ArgumentColumnType}           argumentColumnType      Required column type
                 * @param   {Kusto.Charting.ArgumentRestrictions}         argumentRestrictions    Argument restrictions
                 * @param   {System.Collections.Generic.IEnumerable$1}    seriesColumns           Optional. Names of columns to be considered as series.
                 * @param   {boolean}                                     accumulateResults       Optional. Defines the necessity of accumulation in each DataItem values from the previous ones. Default - false.
                 * @param   {string}                                      xColumn                 Optional. Name of column to be considered as an argument.
                 * @param   {System.Collections.Generic.IEnumerable$1}    yColumns                Optional. Names of columns to be considered as a function.
                 * @return  {System.Collections.Generic.IEnumerable$1}                            Collection of DataItem objects.
                 */
                GetData: function (table, argumentColumnType, argumentRestrictions, seriesColumns, accumulateResults, xColumn, yColumns) {
                    if (argumentColumnType === void 0) { argumentColumnType = 16; }
                    if (argumentRestrictions === void 0) { argumentRestrictions = 0; }
                    if (seriesColumns === void 0) { seriesColumns = null; }
                    if (accumulateResults === void 0) { accumulateResults = false; }
                    if (xColumn === void 0) { xColumn = null; }
                    if (yColumns === void 0) { yColumns = null; }
                    var result = new (System.Collections.Generic.List$1(Kusto.Charting.DataItem)).ctor();

                    var tableSchema = table.Kusto$Charting$IChartingDataSource$GetSchema();
                    if (tableSchema == null || System.Linq.Enumerable.from(tableSchema).count() === 0) {
                        return result;
                    }

                    if (seriesColumns == null) {
                        seriesColumns = new (System.Collections.Generic.List$1(System.String)).ctor();
                    }

                    if (yColumns == null) {
                        yColumns = new (System.Collections.Generic.List$1(System.String)).ctor();
                    }

                    var lastValues = new (System.Collections.Generic.Dictionary$2(System.String,System.Double))();
                    var defaultArgumentValues = new (System.Collections.Generic.Dictionary$2(System.String,System.Double))();
                    var argumentDataColumnIndex = { v : -1 };
                    var seriesIndexes = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var yIndexes = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    var isDataFormedAsSeries = { v : false };
                    Kusto.Charting.DataChartsHelper.ResolvePredefinedColumnsIndexes(table, seriesColumns, seriesIndexes, yColumns, yIndexes, xColumn, argumentDataColumnIndex, argumentColumnType, isDataFormedAsSeries);

                    var isTableValidForCharting = false;
                    if (!isDataFormedAsSeries.v) {
                        isTableValidForCharting = Kusto.Charting.DataChartsHelper.DetectChartDimensionsUsingColumnTypes(tableSchema, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, yIndexes);
                        isDataFormedAsSeries.v = !isTableValidForCharting;
                    }

                    if (isDataFormedAsSeries.v) {
                        isTableValidForCharting = Kusto.Charting.DataChartsHelper.DetectChartDimensionsUsingData(tableSchema, table, seriesColumns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, yIndexes);
                    }

                    if (!isTableValidForCharting) {
                        return result;
                    }

                    for (var i = 0; i < table.Kusto$Charting$IChartingDataSource$RowsCount; i = (i + 1) | 0) {
                        if (!isDataFormedAsSeries.v) {
                            Kusto.Charting.DataChartsHelper.ResolveDataItemsFromDataRow(result, table, lastValues, defaultArgumentValues, i, argumentColumnType, argumentRestrictions, accumulateResults, argumentDataColumnIndex.v, seriesIndexes, yIndexes);
                        } else {
                            Kusto.Charting.DataChartsHelper.ResolveDataSeriesFromDataRow(result, table, lastValues, defaultArgumentValues, i, argumentColumnType, argumentRestrictions, accumulateResults, argumentDataColumnIndex.v, seriesIndexes, yIndexes);
                        }
                    }

                    return result;
                },
                /**
                 * Detects if provided type is numeric.
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {Function}    type                                    Type to be analyzed.
                 * @param   {boolean}     considerDateTimeAndTimeSpanAsNumeric    Optional. Defines if DateTime and TimeSpan should be considered as numeric.
                 Default - true.
                 * @return  {boolean}                                             True, if provided type is numreic, false - if not.
                 */
                IsNumericType: function (type, considerDateTimeAndTimeSpanAsNumeric) {
                    if (considerDateTimeAndTimeSpanAsNumeric === void 0) { considerDateTimeAndTimeSpanAsNumeric = true; }
                    if (type == null) {
                        return false;
                    } else if (Bridge.referenceEquals(type, System.TimeSpan) || Bridge.referenceEquals(type, System.DateTime)) {
                        return considerDateTimeAndTimeSpanAsNumeric;
                    } else if (Bridge.referenceEquals(type, System.Byte) || Bridge.referenceEquals(type, System.Decimal) || Bridge.referenceEquals(type, System.Double) || Bridge.referenceEquals(type, System.Int16) || Bridge.referenceEquals(type, System.Int32) || Bridge.referenceEquals(type, System.Int64) || Bridge.referenceEquals(type, System.SByte) || Bridge.referenceEquals(type, System.UInt16) || Bridge.referenceEquals(type, System.UInt32) || Bridge.referenceEquals(type, System.UInt64)) {
                        return true;
                    } else if (Bridge.referenceEquals(type, System.Object)) {
                        if (Bridge.Reflection.isGenericType(type) && Bridge.referenceEquals(Bridge.Reflection.getGenericTypeDefinition(type), System.Nullable$1)) {
                            return Kusto.Charting.DataChartsHelper.IsNumericType(System.Nullable.getUnderlyingType(type), considerDateTimeAndTimeSpanAsNumeric);
                        }
                    }

                    return false;
                },
                /**
                 * Returns names of columns, from provided data source, which which may be considered as an argument.
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {Kusto.Charting.IChartingDataSource}          table               Data source, which has to implement IChartingDataSource.
                 * @param   {System.Collections.Generic.IEnumerable$1}    columnsToExclude    Optional. Columns to be excluded from detection.
                 * @return  {System.Collections.Generic.IEnumerable$1}                        Collection of columns' names.
                 */
                GetAllArgumentColumns: function (table, columnsToExclude) {
                    if (columnsToExclude === void 0) { columnsToExclude = null; }
                    var result = new (System.Collections.Generic.List$1(System.String)).ctor();
                    var schema = table.Kusto$Charting$IChartingDataSource$GetSchema();
                    var n = System.Linq.Enumerable.from(table.Kusto$Charting$IChartingDataSource$GetSchema()).count();
                    var columnsToExcludeDefined = columnsToExclude != null && System.Linq.Enumerable.from(columnsToExclude).any();
                    if (n > 1) {
                        for (var i = 0; i < n; i = (i + 1) | 0) {
                            var columnName = System.Linq.Enumerable.from(schema).elementAt(i).Item1;
                            if (columnsToExcludeDefined && System.Linq.Enumerable.from(columnsToExclude).contains(columnName)) {
                                continue;
                            }

                            result.add(columnName);
                        }
                    }

                    return result;
                },
                /**
                 * Detects the first column of type string.
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {Kusto.Charting.IChartingDataSource}    table           Data source, which has to implement IChartingDataSource.
                 * @param   {number}                                amountToSkip    Amount of columns type string to be skipped
                 * @return  {string}                                                Name of first column of type string.
                 */
                GetFirstStringColumnName: function (table, amountToSkip) {
                    if (amountToSkip === void 0) { amountToSkip = 0; }
                    var schema = table.Kusto$Charting$IChartingDataSource$GetSchema();
                    var n = System.Linq.Enumerable.from(table.Kusto$Charting$IChartingDataSource$GetSchema()).count();
                    for (var i = 0; i < n; i = (i + 1) | 0) {
                        if (System.Linq.Enumerable.from(schema).elementAt(i).Item2 === Kusto.Charting.ArgumentColumnType.String) {
                            if (amountToSkip === 0) {
                                return System.Linq.Enumerable.from(schema).elementAt(i).Item1;
                            } else {
                                amountToSkip = (amountToSkip - 1) | 0;
                            }
                        }
                    }

                    return null;
                },
                /**
                 * Method fills gaps in arguments sequence in collection of DataItems,
                 pasting new items with NaN values
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {System.Collections.Generic.List$1}    data       Input collection of DataItems. For consistent result, data should be sorted.
                 * @param   {Kusto.Charting.ArgumentColumnType}    argType    Type of argument
                 * @return  {System.Collections.Generic.List$1}
                 */
                FillGapsWithNaNs: function (data, argType) {
                    var $t;
                    if (data == null || !System.Linq.Enumerable.from(data).any() || data.Count < Kusto.Charting.DataChartsHelper.c_minElementsAmountToFillGapsWithNans) {
                        return data;
                    }

                    var dataGroups = System.Linq.Enumerable.from(data).groupBy($asm.$.Kusto.Charting.DataChartsHelper.f1);
                    var result = new (System.Collections.Generic.List$1(Kusto.Charting.DataItem)).$ctor2(data.Count);
                    //filling gaps for each serie
                    $t = Bridge.getEnumerator(dataGroups);
                    try {
                        while ($t.moveNext()) {
                            var dg = $t.Current;
                            var serieDataItems = Kusto.Charting.DataChartsHelper.FillGapsWithNaNs$1(dg.select($asm.$.Kusto.Charting.DataChartsHelper.f2), argType);
                            result.AddRange(serieDataItems);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return result;
                },
                FillGapsWithNaNs$1: function (data, argType) {
                    var $t;
                    if (System.Linq.Enumerable.from(data).count() < Kusto.Charting.DataChartsHelper.c_minElementsAmountToFillGapsWithNans) {
                        return data;
                    }

                    var argData;
                    //resolving sequence of argument values
                    switch (argType) {
                        case Kusto.Charting.ArgumentColumnType.DateTime: 
                            argData = System.Linq.Enumerable.from(data).select($asm.$.Kusto.Charting.DataChartsHelper.f3).ToArray(System.Double);
                            break;
                        case Kusto.Charting.ArgumentColumnType.Numeric: 
                            argData = System.Linq.Enumerable.from(data).select($asm.$.Kusto.Charting.DataChartsHelper.f4).ToArray(System.Double);
                            break;
                        default: 
                            return data;
                    }

                    if (argData == null) {
                        return data;
                    }

                    //resolving collection of distances between values of argument
                    var distances = Kusto.Charting.DataChartsHelper.SelectSuccessivePairs(argData);
                    //getting the distance which appears most often and the number of appearances
                    var maxGroup = Kusto.Charting.DataChartsHelper.GetTopGroupByCount(distances, argType);
                    var initialDistance = maxGroup.Item1;
                    if (maxGroup == null || System.Convert.toDouble(Bridge.box(maxGroup.Item2, System.Int32)) / System.Linq.Enumerable.from(distances).count() < Kusto.Charting.DataChartsHelper.c_minFractionOfIntervalsToDetectDistribution) {
                        return data;
                    }

                    var result = new (System.Collections.Generic.List$1(Kusto.Charting.DataItem)).$ctor2(System.Linq.Enumerable.from(data).count());
                    var prevItem = null;
                    $t = Bridge.getEnumerator(data, Kusto.Charting.DataItem);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (prevItem == null) {
                                result.add(item);
                                prevItem = item;
                                continue;
                            }

                            var currentDistance = Kusto.Charting.DataChartsHelper.GetDistance(prevItem, item, argType);
                            //if currentDistance is larger than initialDistance - we assume a gap
                            if (currentDistance - initialDistance > Kusto.Charting.DataChartsHelper.c_doubleAcceptableApproximation) {
                                var gapLength = 0;
                                //amount of initialDistances in the gap
                                try {
                                    gapLength = System.Convert.toInt32(Bridge.box(Bridge.Math.round(currentDistance / initialDistance, 0, 6), System.Double, System.Double.format, System.Double.getHashCode));
                                }
                                catch ($e1) {
                                    $e1 = System.Exception.create($e1);
                                    return data;
                                }

                                // regular modulo (%) does not work well with doubles, so using next formula
                                var mod = currentDistance - gapLength * initialDistance;
                                // if amount of initialDistances in currentDistance is not integer, gaps can't be filled
                                if (mod > Kusto.Charting.DataChartsHelper.c_doubleAcceptableApproximation) {
                                    return data;
                                }

                                //filling the gap with DataItems in which ValueData is set to NaN
                                for (var j = 1; j < gapLength; j = (j + 1) | 0) {
                                    var newItem = prevItem.Clone();
                                    newItem.ValueData = Number.NaN;
                                    result.add(newItem);
                                }
                            }

                            result.add(item);
                            prevItem = item;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return result;
                },
                /**
                 * Method resolves probable type of argument based on generated data items
                 *
                 * @static
                 * @public
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {System.Collections.Generic.List$1}    data    List of DataItems, which used as data source for visualization
                 * @return  {Kusto.Charting.ArgumentColumnType}            Type of data
                 */
                ResolveArgumentType: function (data) {
                    if (data == null || !System.Linq.Enumerable.from(data).any()) {
                        return Kusto.Charting.ArgumentColumnType.None;
                    }

                    if (System.Linq.Enumerable.from(data).all($asm.$.Kusto.Charting.DataChartsHelper.f5)) {
                        return Kusto.Charting.ArgumentColumnType.DateTime;
                    }

                    if (System.Linq.Enumerable.from(data).any($asm.$.Kusto.Charting.DataChartsHelper.f6)) {
                        return Kusto.Charting.ArgumentColumnType.Numeric;
                    }

                    return Kusto.Charting.ArgumentColumnType.String;
                },
                /**
                 * Calculates intervals between values in collection
                 *
                 * @static
                 * @private
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {Array.<number>}    collection
                 * @return  {Array.<number>}                  Array of doubles
                 */
                SelectSuccessivePairs: function (collection) {
                    var $t;
                    if (collection == null || System.Linq.Enumerable.from(collection).count() <= 1) {
                        return null;
                    }

                    var result = System.Array.init(((System.Linq.Enumerable.from(collection).count() - 1) | 0), 0, System.Double);
                    var isFirstElement = true;
                    var prev = Bridge.getDefaultValue(System.Double);
                    var idx = 0;
                    $t = Bridge.getEnumerator(collection);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (isFirstElement) {
                                isFirstElement = false;
                                prev = item;
                                continue;
                            }

                            result[System.Array.index(idx, result)] = Math.abs(item - prev);
                            idx = (idx + 1) | 0;
                            prev = item;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return result;
                },
                GetTopGroupByCount: function (data, sequenceType) {
                    var $t;
                    var sorted = System.Linq.Enumerable.from(data).orderBy($asm.$.Kusto.Charting.DataChartsHelper.f2);
                    var currentGroup = new (System.Collections.Generic.List$1(System.Double)).$ctor2(System.Linq.Enumerable.from(data).count());
                    var maxGroupCount = 0;
                    var maxGroupValue = 0.0;
                    var prevNum = null;
                    $t = Bridge.getEnumerator(sorted);
                    try {
                        while ($t.moveNext()) {
                            var num = $t.Current;
                            if (!System.Nullable.hasValue(prevNum)) {
                                prevNum = num;
                                currentGroup.add(num);
                                continue;
                            }

                            var diff = num - System.Nullable.getValue(prevNum);
                            //if the difference is larger than acceptable for error of double type, we assume the start of a new group
                            if (diff > Kusto.Charting.DataChartsHelper.c_doubleAcceptableApproximation) {
                                if (System.Linq.Enumerable.from(currentGroup).count() > maxGroupCount) {
                                    maxGroupCount = System.Linq.Enumerable.from(currentGroup).count();
                                    maxGroupValue = Bridge.Math.round(System.Linq.Enumerable.from(currentGroup).average(), Kusto.Charting.DataChartsHelper.c_decimalRoundingPrecision, 6);
                                }

                                currentGroup.clear();
                            }

                            currentGroup.add(num);
                            prevNum = num;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return { Item1: maxGroupValue, Item2: maxGroupCount };
                },
                GetDistance: function (start, end, sequenceType) {
                    if (start == null || end == null) {
                        return -1;
                    }

                    var distance = -1;
                    switch (sequenceType) {
                        case Kusto.Charting.ArgumentColumnType.DateTime: 
                            distance = System.Int64.toNumber(System.DateTime.getTicks(end.ArgumentDateTime).sub(System.DateTime.getTicks(start.ArgumentDateTime)));
                            break;
                        case Kusto.Charting.ArgumentColumnType.Numeric: 
                            distance = end.ArgumentNumeric - start.ArgumentNumeric;
                            break;
                    }

                    return Bridge.Math.round(Math.abs(distance), Kusto.Charting.DataChartsHelper.c_decimalRoundingPrecision, 6);
                },
                ResolvePredefinedColumnsIndexes: function (data, seriesColumns, seriesIndexes, yColumns, yIndexes, xColumn, xColumnIdx, argumentColumnType, isDataFormedAsSeries) {
                    var dataIsSeries = null;
                    var columns = data.Kusto$Charting$IChartingDataSource$GetSchema();
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        var column = System.Linq.Enumerable.from(columns).elementAt(i);
                        var columnName = column.Item1;
                        if (System.Linq.Enumerable.from(seriesColumns).any() && System.Linq.Enumerable.from(seriesColumns).contains(columnName)) {
                            seriesIndexes.add(i);
                            continue;
                        }

                        var isY = System.Linq.Enumerable.from(yColumns).any() && System.Linq.Enumerable.from(yColumns).contains(columnName);
                        var isX = !System.String.isNullOrWhiteSpace(xColumn) && Bridge.referenceEquals(xColumn, columnName);
                        if (isY || isX) {
                            var columnType = column.Item2;
                            var isSeries = false;
                            //checking if data formed as series
                            if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.StringOrObject, Bridge.box(columnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                                var value = Bridge.toString(data.Kusto$Charting$IChartingDataSource$GetValue(0, i));
                                var type = Kusto.Charting.DataChartsHelper.ResolveJsonArrayType(value);
                                if (type !== Kusto.Charting.ArgumentColumnType.None) {
                                    columnType = type;
                                    isSeries = true;
                                }
                            }

                            if (System.Nullable.hasValue(dataIsSeries)) {
                                if (System.Nullable.getValue(dataIsSeries) !== isSeries) {
                                    throw new Kusto.Charting.SeriesCreationException("Y-Axes and X-Axis both should be defined as scalars or as series");
                                }
                            } else {
                                dataIsSeries = isSeries;
                            }

                            //resolving index
                            if (isX) {
                                if (System.Enum.hasFlag(argumentColumnType, Bridge.box(columnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                                    xColumnIdx.v = i;
                                } else {
                                    throw new Kusto.Charting.SeriesCreationException(System.String.format("Type of column {0}, provided as X-Axis, does not match required by chart type", [columnName]));
                                }
                            } else if (isY) {
                                if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.NumericOrDateTimeOrTimeSpan, Bridge.box(columnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                                    yIndexes.add(i);
                                } else {
                                    throw new Kusto.Charting.SeriesCreationException(System.String.format("Column {0}, provided as Y-Axis, sould be one of types: Numeric, DateTime, Timespan", [columnName]));
                                }
                            }
                        }
                    }

                    isDataFormedAsSeries.v = System.Nullable.hasValue(dataIsSeries) ? System.Nullable.getValue(dataIsSeries) : false;
                    if (!System.Linq.Enumerable.from(yIndexes).any() && System.Linq.Enumerable.from(yColumns).any()) {
                        throw new Kusto.Charting.SeriesCreationException("Any of columns defined as Y-Axes were not found in data, not of an appropriate type or used as argument or series");
                    }

                    if (!System.String.isNullOrWhiteSpace(xColumn) && xColumnIdx.v < 0) {
                        throw new Kusto.Charting.SeriesCreationException(System.String.format("Column {0}, provided as X-Axis, was not found in data", [xColumn]));
                    }

                    if (System.Linq.Enumerable.from(seriesColumns).any() && !System.Linq.Enumerable.from(seriesIndexes).any()) {
                        throw new Kusto.Charting.SeriesCreationException("Any of columns, provided as Series, were not found in data");
                    }
                },
                ResolveDataSeriesFromDataRow: function (result, table, lastValues, defaultArgumentValues, rowIdx, argumentColumnType, argumentRestrictions, accumulate, argumentDataColumnIndex, seriesIndexes, yIndexes) {
                    var $t, $t1, $t2;
                    var columns = table.Kusto$Charting$IChartingDataSource$GetSchema();
                    var baseSeriesName = "";
                    if (System.Linq.Enumerable.from(seriesIndexes).any()) {
                        var baseSeriesNameBuilder = new System.Text.StringBuilder();
                        $t = Bridge.getEnumerator(seriesIndexes);
                        try {
                            while ($t.moveNext()) {
                                var sIndex = $t.Current;
                                var column = System.Linq.Enumerable.from(columns).elementAt(sIndex);
                                if (baseSeriesNameBuilder.getLength() > 0) {
                                    baseSeriesNameBuilder.append(", ");
                                }

                                baseSeriesNameBuilder.appendFormat("{0}:{1}", column.Item1, Bridge.toString(table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, sIndex)));
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }baseSeriesName = baseSeriesNameBuilder.toString();
                    }
                    var argumentValue = table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, argumentDataColumnIndex);
                    var argumentActualType = Kusto.Charting.DataChartsHelper.ResolveJsonArrayType(Bridge.toString(argumentValue));
                    // In case the first column to be series, and the last one before numeric one - to be the ArgumentData
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        if (i === argumentDataColumnIndex || (System.Linq.Enumerable.from(yIndexes).any() && !System.Linq.Enumerable.from(yIndexes).contains(i)) || seriesIndexes.contains(i)) {
                            continue; // skip argument data index, series indexes and colmns not included to yIndexes if defined.
                        }

                        var column1 = System.Linq.Enumerable.from(columns).elementAt(i);
                        var cellValue = table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, i);
                        if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.StringOrObject, Bridge.box(column1.Item2, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                            var value = ($t1 = (Bridge.as(cellValue, System.String)), $t1 != null ? $t1 : (Bridge.toString(cellValue)));
                            var type = Kusto.Charting.DataChartsHelper.ResolveJsonArrayType(value);
                            if (type === Kusto.Charting.ArgumentColumnType.None) {
                                continue;
                            }

                            if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.NumericOrDateTimeOrTimeSpan, Bridge.box(type, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {

                                var values = Kusto.Charting.DataChartsHelper.ParseJsonArrayAsDouble(value, true);
                                if (values == null || System.Linq.Enumerable.from(value).count() === 0) {
                                    continue;
                                }

                                var seriesName = (System.String.isNullOrEmpty(baseSeriesName)) ? column1.Item1 : (baseSeriesName || "") + ":" + (column1.Item1 || "");
                                var lastValue = 0;
                                var argumentDateTime = Kusto.Charting.DataChartsHelper.GetArgumentDateTimeArray(argumentValue, argumentActualType, argumentDataColumnIndex, System.Linq.Enumerable.from(values).count());
                                var argumentNumeric = Kusto.Charting.DataChartsHelper.GetArgumentNumericArray(argumentValue, argumentActualType, argumentDataColumnIndex, System.Linq.Enumerable.from(values).count());
                                var argumentString = Kusto.Charting.DataChartsHelper.GetArgumentStringArray(argumentValue, argumentActualType, argumentDataColumnIndex, System.Linq.Enumerable.from(values).count());

                                for (var j = 0; j < System.Linq.Enumerable.from(values).count(); j = (j + 1) | 0) {
                                    var argumentData = "";
                                    if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.DateTimeOrTimeSpan, Bridge.box(argumentColumnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.DateTimeOrTimeSpan, Bridge.box(argumentActualType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                                        argumentData = System.DateTime.format(argumentDateTime[System.Array.index(j, argumentDateTime)]);
                                    } else if (System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.Numeric, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && argumentActualType === Kusto.Charting.ArgumentColumnType.Numeric) {
                                        argumentData = System.Double.format(argumentNumeric[System.Array.index(j, argumentNumeric)]);
                                    } else if (System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.String, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                                        argumentData = argumentString[System.Array.index(j, argumentString)];
                                        if (System.String.isNullOrEmpty(argumentData)) {
                                            argumentData = Bridge.as(argumentValue, System.String);
                                        }
                                    }

                                    var dataItem = ($t2 = new Kusto.Charting.DataItem(), $t2.ArgumentData = argumentData, $t2.ArgumentDateTime = argumentDateTime[System.Array.index(j, argumentDateTime)], $t2.ArgumentNumeric = argumentNumeric[System.Array.index(j, argumentNumeric)], $t2.ValueData = accumulate ? values[System.Array.index(j, values)] + lastValue : values[System.Array.index(j, values)], $t2.ValueName = column1.Item1, $t2.SeriesName = seriesName, $t2);

                                    // Correction for charts - ArgumentData cannot be empty for some charts
                                    if (System.String.isNullOrEmpty(dataItem.ArgumentData)) {
                                        dataItem.ArgumentData = "<empty>";
                                    }
                                    result.add(dataItem);
                                    lastValue = dataItem.ValueData;
                                }
                            }
                        }
                    }
                },
                GetArgumentStringArray: function (value, argumentColumnType, argumentDataColumnIndex, count) {
                    if (!System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.String, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) || argumentDataColumnIndex < 0) {
                        return System.Array.init(count, null, System.String);
                    }

                    var result = Kusto.Charting.DataChartsHelper.ParseJsonArrayAsString(Bridge.toString(value));
                    if (result == null) {
                        return System.Array.init(count, null, System.String);
                    }

                    return result;
                },
                GetArgumentNumericArray: function (value, argumentColumnType, argumentDataColumnIndex, count) {
                    if (argumentColumnType !== Kusto.Charting.ArgumentColumnType.Numeric || argumentDataColumnIndex < 0) {
                        return System.Array.init(count, 0, System.Double);
                    }

                    var result = Kusto.Charting.DataChartsHelper.ParseJsonArrayAsDouble(Bridge.toString(value));
                    if (result == null) {
                        return System.Array.init(count, 0, System.Double);
                    }

                    return result;
                },
                GetArgumentDateTimeArray: function (value, argumentColumnType, argumentDataColumnIndex, count) {
                    if (!System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.DateTimeOrTimeSpan, Bridge.box(argumentColumnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) || argumentDataColumnIndex < 0) {
                        return System.Array.init(count, function (){
                            return System.DateTime.getDefaultValue();
                        }, System.DateTime);
                    }

                    var result = Kusto.Charting.DataChartsHelper.ParseJsonArrayAsDateTime(Bridge.toString(value));
                    if (result == null) {
                        return System.Array.init(count, function (){
                            return System.DateTime.getDefaultValue();
                        }, System.DateTime);
                    }

                    return result;
                },
                ResolveDataItemsFromDataRow: function (result, table, lastValues, defaultArgumentValues, rowIdx, argumentColumnType, argumentRestrictions, accumulate, argumentDataColumnIndex, seriesIndexes, yIndexes) {
                    var $t, $t1;
                    var columns = table.Kusto$Charting$IChartingDataSource$GetSchema();
                    var baseSeriesName = "";
                    if (System.Linq.Enumerable.from(seriesIndexes).any()) {
                        var baseSeriesNameBuilder = new System.Text.StringBuilder();
                        $t = Bridge.getEnumerator(seriesIndexes);
                        try {
                            while ($t.moveNext()) {
                                var sIndex = $t.Current;
                                var column = System.Linq.Enumerable.from(columns).elementAt(sIndex);
                                if (baseSeriesNameBuilder.getLength() > 0) {
                                    baseSeriesNameBuilder.append(", ");
                                }

                                baseSeriesNameBuilder.appendFormat("{0}:{1}", column.Item1, Bridge.toString(table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, sIndex)));
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }baseSeriesName = baseSeriesNameBuilder.toString();
                    }
                    var argumentValue = table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, argumentDataColumnIndex);
                    var argumentActualType = (argumentValue == null) ? argumentColumnType : System.Linq.Enumerable.from(columns).elementAt(argumentDataColumnIndex).Item2;
                    // In case the first column to be series, and the last one before numeric one - to be the ArgumentData
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        if (i === argumentDataColumnIndex || (System.Linq.Enumerable.from(yIndexes).any() && !System.Linq.Enumerable.from(yIndexes).contains(i)) || seriesIndexes.contains(i)) {
                            continue; // skip argument data index, series indexes and colmns not included to yIndexes if defined.
                        }

                        var column1 = System.Linq.Enumerable.from(columns).elementAt(i);
                        if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.NumericOrDateTimeOrTimeSpan, Bridge.box(column1.Item2, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                            var cellValue = table.Kusto$Charting$IChartingDataSource$GetValue(rowIdx, i);
                            var nullableValue = Kusto.Charting.DataChartsHelper.TryConvertToDouble(cellValue, column1.Item2);
                            if (nullableValue == null) {
                                continue; // skip this point
                            }

                            var value = System.Nullable.getValue(nullableValue);
                            var seriesName = (System.String.isNullOrEmpty(baseSeriesName)) ? column1.Item1 : (baseSeriesName || "") + ":" + (column1.Item1 || "");
                            var lastValue = { };
                            var argumentDateTime = Kusto.Charting.DataChartsHelper.GetArgumentDateTime(argumentValue, argumentActualType);
                            var argumentNumeric = Kusto.Charting.DataChartsHelper.GetArgumentNumeric(argumentValue, argumentActualType, argumentDataColumnIndex, seriesName, defaultArgumentValues);
                            var dataItem = ($t1 = new Kusto.Charting.DataItem(), $t1.ArgumentData = (argumentDataColumnIndex >= 0) ? Bridge.toString(argumentValue) : "", $t1.ArgumentDateTime = argumentDateTime, $t1.ArgumentNumeric = argumentNumeric, $t1.ValueData = accumulate && lastValues.tryGetValue(seriesName, lastValue) ? value + lastValue.v : value, $t1.ValueName = column1.Item1, $t1.SeriesName = seriesName, $t1);
                            // Correction for charts - ArgumentData cannot be empty for some charts
                            if (System.String.isNullOrEmpty(dataItem.ArgumentData)) {
                                dataItem.ArgumentData = "<empty>";
                            }
                            result.add(dataItem);
                            lastValues.set(dataItem.SeriesName, dataItem.ValueData);
                        }
                    }
                },
                GetArgumentDateTime: function (value, argumentColumnType) {
                    if (!System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.DateTime, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && !System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.TimeSpan, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                        return System.DateTime.getMinValue();
                    }

                    if (Bridge.is(value, System.DateTime)) {
                        return System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.DateTime));
                    } else if (Bridge.is(value, System.TimeSpan)) {
                        return System.DateTime.create$2(System.Nullable.getValue(Bridge.cast(Bridge.unbox(value), System.TimeSpan)).getTicks());
                    }

                    return System.DateTime.getMinValue();
                },
                GetArgumentNumeric: function (value, argumentColumnType, argumentDataColumnIndex, seriesName, defaultArgumentValues) {
                    if (!System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.Numeric, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) || Kusto.Charting.DataChartsHelper.CheckIfDBNull(value)) {
                        return Number.NaN;
                    }

                    // Invent argument values if 
                    if (argumentDataColumnIndex < 0) {
                        if (!defaultArgumentValues.containsKey(seriesName)) {
                            defaultArgumentValues.set(seriesName, 0);
                        }
                        defaultArgumentValues.set(seriesName, defaultArgumentValues.get(seriesName)+1);
                        return defaultArgumentValues.get(seriesName);
                    }

                    return Kusto.Charting.DataChartsHelper.ConvertToDouble(value, argumentColumnType);
                },
                ConvertToDouble: function (obj, type) {
                    var value = 0;
                    if (type === Kusto.Charting.ArgumentColumnType.DateTime) {
                        value = Kusto.Charting.DataChartsHelper.DateTimeToTotalSeconds(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj), System.DateTime)));
                    } else if (type === Kusto.Charting.ArgumentColumnType.TimeSpan) {
                        value = Kusto.Charting.DataChartsHelper.TimeSpanToTotalSeconds(System.Nullable.getValue(Bridge.cast(Bridge.unbox(obj), System.TimeSpan)));
                    } else {
                        try {
                            value = System.Convert.toDouble(obj);
                        }
                        catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            value = Number.NaN;
                        }
                    }

                    return value;
                },
                TryConvertToDouble: function (value, type) {
                    if (value == null || Kusto.Charting.DataChartsHelper.CheckIfDBNull(value)) {
                        return Number.NaN;
                    }

                    return Kusto.Charting.DataChartsHelper.ConvertToDouble(value, type);
                },
                /**
                 * from the table columns and reuirements, deduce the x, y, and series axis.
                 *
                 * @static
                 * @private
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns                    
                 * @param   {Kusto.Charting.IChartingDataSource}          table                      
                 * @param   {System.Collections.Generic.IEnumerable$1}    seriesColumns              
                 * @param   {Kusto.Charting.ArgumentColumnType}           argumentColumnType         
                 * @param   {Kusto.Charting.ArgumentRestrictions}         argumentRestrictions       
                 * @param   {System.Int32}                                argumentDataColumnIndex    
                 * @param   {System.Collections.Generic.List$1}           seriesIndexes              
                 * @param   {System.Collections.Generic.List$1}           yIndexes
                 * @return  {boolean}
                 */
                DetectChartDimensionsUsingData: function (columns, table, seriesColumns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, yIndexes) {
                    var $t;
                    var resolvedColumnTypes = System.Array.init(System.Linq.Enumerable.from(columns).count(), 0, Kusto.Charting.ArgumentColumnType);

                    if (table.Kusto$Charting$IChartingDataSource$RowsCount === 0) {
                        return false;
                    }

                    var firstNumericColumnIndex = -1;
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        var column = System.Linq.Enumerable.from(columns).elementAt(i);
                        resolvedColumnTypes[System.Array.index(i, resolvedColumnTypes)] = column.Item2;
                        if (yIndexes != null && yIndexes.contains(i)) {
                            continue;
                        }

                        var item = table.Kusto$Charting$IChartingDataSource$GetValue(0, i);
                        if (column.Item2 === Kusto.Charting.ArgumentColumnType.String || column.Item2 === Kusto.Charting.ArgumentColumnType.Object) {
                            var value = ($t = (Bridge.as(item, System.String)), $t != null ? $t : (Bridge.toString(item)));
                            var type = Kusto.Charting.DataChartsHelper.ResolveJsonArrayType(value);
                            if (type === Kusto.Charting.ArgumentColumnType.None) {
                                if ((seriesColumns == null || !System.Linq.Enumerable.from(seriesColumns).any()) && argumentDataColumnIndex.v < 0) {
                                    // Add column to series mapping
                                    seriesIndexes.add(i);
                                }
                                continue;
                            }

                            resolvedColumnTypes[System.Array.index(i, resolvedColumnTypes)] = type;
                            if (System.Enum.hasFlag(argumentColumnType, Bridge.box(type, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && argumentDataColumnIndex.v < 0) {
                                argumentDataColumnIndex.v = i;
                            } else if (type === Kusto.Charting.ArgumentColumnType.Numeric && firstNumericColumnIndex < 0) {
                                firstNumericColumnIndex = i;
                            }
                        }
                    }

                    return Kusto.Charting.DataChartsHelper.CompleteChartDimentionsDetection(columns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, firstNumericColumnIndex, resolvedColumnTypes, yIndexes);
                },
                /**
                 * from the table columns and requirements, deduce the x, y, and series axis.
                 *
                 * @static
                 * @private
                 * @this Kusto.Charting.DataChartsHelper
                 * @memberof Kusto.Charting.DataChartsHelper
                 * @param   {System.Collections.Generic.IEnumerable$1}    columns                    
                 * @param   {Kusto.Charting.ArgumentColumnType}           argumentColumnType         
                 * @param   {Kusto.Charting.ArgumentRestrictions}         argumentRestrictions       
                 * @param   {System.Int32}                                argumentDataColumnIndex    
                 * @param   {System.Collections.Generic.List$1}           seriesIndexes              
                 * @param   {System.Collections.Generic.List$1}           yIndexes
                 * @return  {boolean}
                 */
                DetectChartDimensionsUsingColumnTypes: function (columns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, yIndexes) {
                    var firstNumericColumnIndex = -1;
                    // Find first numeric column
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        if (yIndexes != null && yIndexes.contains(i) || (seriesIndexes != null && seriesIndexes.contains(i))) {
                            continue;
                        }

                        var column = System.Linq.Enumerable.from(columns).elementAt(i);
                        if (System.Enum.hasFlag(argumentColumnType, Bridge.box(column.Item2, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && argumentDataColumnIndex.v < 0) {
                            argumentDataColumnIndex.v = i;
                        } else if (column.Item2 === Kusto.Charting.ArgumentColumnType.Numeric) {
                            firstNumericColumnIndex = i;
                            break;
                        }
                    }

                    var resolvedColumnTypes = System.Linq.Enumerable.from(columns).select($asm.$.Kusto.Charting.DataChartsHelper.f7).ToArray(Kusto.Charting.ArgumentColumnType);
                    return Kusto.Charting.DataChartsHelper.CompleteChartDimentionsDetection(columns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, firstNumericColumnIndex, resolvedColumnTypes, yIndexes);
                },
                CompleteChartDimentionsDetection: function (columns, argumentColumnType, argumentRestrictions, argumentDataColumnIndex, seriesIndexes, firstNumericColumnIndex, resolvedColumnTypes, yIndexes) {
                    if (argumentDataColumnIndex.v >= 0 && System.Linq.Enumerable.from(seriesIndexes).any()) {
                        return true;
                    }
                    // if required argument is of numeric type, there should be at least one numeric column
                    if (argumentDataColumnIndex.v < 0 && firstNumericColumnIndex < 0 && System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.Numeric, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                        return false;
                    }

                    // Set argumentDataColumnIndex if it is invalid
                    if (argumentDataColumnIndex.v < 0) {
                        if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.DateTimeOrTimeSpan, Bridge.box(argumentColumnType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                            // If the argument requested type is string DateTimeOrTimeSpan 
                            // we already know that it was not found
                            return false;
                        }

                        if (System.Enum.hasFlag(argumentColumnType, Bridge.box(Kusto.Charting.ArgumentColumnType.Numeric, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType)))) {
                            if (System.Linq.Enumerable.from(columns).count() > 1) {
                                argumentDataColumnIndex.v = firstNumericColumnIndex;
                            }
                        } else {
                            if (System.Enum.hasFlag(argumentRestrictions, Bridge.box(Kusto.Charting.ArgumentRestrictions.NotIncludedInSeries, Kusto.Charting.ArgumentRestrictions, System.Enum.toStringFn(Kusto.Charting.ArgumentRestrictions)))) {
                                argumentDataColumnIndex.v = Kusto.Charting.DataChartsHelper.GoBackwardsAndFindColumnNotInList(firstNumericColumnIndex, seriesIndexes, yIndexes);
                            } else {
                                argumentDataColumnIndex.v = (firstNumericColumnIndex - 1) | 0;
                            }
                        }
                    }

                    if (argumentDataColumnIndex.v < 0 && System.Enum.hasFlag(argumentRestrictions, Bridge.box(Kusto.Charting.ArgumentRestrictions.MustHave, Kusto.Charting.ArgumentRestrictions, System.Enum.toStringFn(Kusto.Charting.ArgumentRestrictions)))) {
                        argumentDataColumnIndex.v = 0;
                    }


                    if (!System.Linq.Enumerable.from(seriesIndexes).any() && argumentDataColumnIndex.v >= 0) {
                        var seriesDefaultIndex = argumentDataColumnIndex.v;
                        if (resolvedColumnTypes[System.Array.index(argumentDataColumnIndex.v, resolvedColumnTypes)] !== Kusto.Charting.ArgumentColumnType.String) {
                            seriesDefaultIndex = Kusto.Charting.DataChartsHelper.GetFirstStringColumnIndex(resolvedColumnTypes);
                        } else if (System.Enum.hasFlag(argumentRestrictions, Bridge.box(Kusto.Charting.ArgumentRestrictions.NotIncludedInSeries, Kusto.Charting.ArgumentRestrictions, System.Enum.toStringFn(Kusto.Charting.ArgumentRestrictions)))) {
                            seriesDefaultIndex = (argumentDataColumnIndex.v - 1) | 0; // In case argument shouldn't be included to series - move one before
                        }

                        if (seriesDefaultIndex >= 0 && !yIndexes.contains(seriesDefaultIndex)) {
                            seriesIndexes.add(seriesDefaultIndex);
                        }
                    }

                    return true;
                },
                GoBackwardsAndFindColumnNotInList: function (startIndex, seriesIndices, yIndexes) {
                    for (var i = (startIndex - 1) | 0; i >= 0; i = (i - 1) | 0) {
                        var isNotInSeries = (seriesIndices == null) ? true : !seriesIndices.contains(i);
                        var isNotInYs = (yIndexes == null) ? true : !yIndexes.contains(i);
                        if (isNotInSeries && isNotInYs) {
                            return i;
                        }
                    }
                    return -1;
                },
                GetFirstStringColumnIndex: function (columns) {
                    for (var i = 0; i < System.Linq.Enumerable.from(columns).count(); i = (i + 1) | 0) {
                        if (System.Linq.Enumerable.from(columns).elementAt(i) === Kusto.Charting.ArgumentColumnType.String) {
                            return i;
                        }
                    }
                    return -1;
                },
                TimeSpanToTotalSeconds: function (ts) {
                    return ts.getTotalSeconds();
                },
                DateTimeToTotalSeconds: function (dt) {
                    return System.TimeSpan.fromTicks(System.DateTime.getTicks(dt)).getTotalSeconds();
                },
                ParseJsonArrayAsDateTime: function (value) {
                    if (System.String.isNullOrWhiteSpace(value) || !System.String.startsWith(value.trim(), "[")) {
                        return null;
                    }

                    try {
                        return Newtonsoft.Json.JsonConvert.DeserializeObject(value, System.Array.type(System.DateTime));
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);

                    }

                    return null;
                },
                ParseJsonArrayAsDouble: function (value, considerDateTimeAndTimeSpanAsDouble) {
                    if (considerDateTimeAndTimeSpanAsDouble === void 0) { considerDateTimeAndTimeSpanAsDouble = false; }
                    if (System.String.isNullOrWhiteSpace(value) || !System.String.startsWith(value.trim(), "[")) {
                        return null;
                    }

                    var result;
                    var valueAsArr;
                    try {
                        valueAsArr = Newtonsoft.Json.JsonConvert.DeserializeObject(value, System.Array.type(System.String));
                        result = System.Array.init(System.Linq.Enumerable.from(valueAsArr).count(), 0, System.Double);
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        return null;
                    }

                    var resolvedValueType = Kusto.Charting.ArgumentColumnType.None;
                    var d = { };
                    for (var i = 0; i < System.Linq.Enumerable.from(valueAsArr).count(); i = (i + 1) | 0) {
                        var val = valueAsArr[System.Array.index(i, valueAsArr)];
                        if (val == null) {
                            result[System.Array.index(i, result)] = Number.NaN;
                            continue;
                        } else if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.Numeric, Bridge.box(resolvedValueType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && System.Double.tryParse(val, null, d)) {
                            if (resolvedValueType === Kusto.Charting.ArgumentColumnType.None) {
                                resolvedValueType = Kusto.Charting.ArgumentColumnType.Numeric;
                            }

                            result[System.Array.index(i, result)] = d.v;
                            continue;
                        } else if (considerDateTimeAndTimeSpanAsDouble) {
                            var ts = { };
                            if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.TimeSpan, Bridge.box(resolvedValueType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && System.TimeSpan.tryParse(val, null, ts)) {
                                if (resolvedValueType === Kusto.Charting.ArgumentColumnType.None) {
                                    resolvedValueType = Kusto.Charting.ArgumentColumnType.TimeSpan;
                                }

                                result[System.Array.index(i, result)] = ts.v.getTotalSeconds();
                                continue;
                            }

                            var dt = { };
                            if (System.Enum.hasFlag(Kusto.Charting.ArgumentColumnType.DateTime, Bridge.box(resolvedValueType, Kusto.Charting.ArgumentColumnType, System.Enum.toStringFn(Kusto.Charting.ArgumentColumnType))) && System.DateTime.tryParse(val, null, dt)) {
                                if (resolvedValueType === Kusto.Charting.ArgumentColumnType.None) {
                                    resolvedValueType = Kusto.Charting.ArgumentColumnType.DateTime;
                                }

                                result[System.Array.index(i, result)] = System.TimeSpan.fromTicks(System.DateTime.getTicks(dt.v)).getTotalSeconds();
                                continue;
                            }
                        }

                        return null;
                    }

                    if (resolvedValueType !== Kusto.Charting.ArgumentColumnType.None) {
                        return result;
                    }

                    return null;
                },
                ParseJsonArrayAsString: function (value) {
                    if (System.String.isNullOrWhiteSpace(value) || !System.String.startsWith(value.trim(), "[")) {
                        return null;
                    }

                    try {
                        return Newtonsoft.Json.JsonConvert.DeserializeObject(value, System.Array.type(System.String));
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);

                    }

                    return null;
                },
                ResolveJsonArrayType: function (value) {
                    var arr;
                    try {
                        arr = Newtonsoft.Json.JsonConvert.DeserializeObject(value, System.Array.type(System.String));
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        return Kusto.Charting.ArgumentColumnType.None;
                    }

                    if (arr == null || System.Linq.Enumerable.from(arr).count() === 0) {
                        return Kusto.Charting.ArgumentColumnType.None;
                    }

                    if (Kusto.Charting.DataChartsHelper.ArrayIsDouble(arr)) {
                        return Kusto.Charting.ArgumentColumnType.Numeric;
                    }

                    if (Kusto.Charting.DataChartsHelper.ArrayIsTimespan(arr)) {
                        return Kusto.Charting.ArgumentColumnType.TimeSpan;
                    }

                    if (Kusto.Charting.DataChartsHelper.ArrayIsDatetime(arr)) {
                        return Kusto.Charting.ArgumentColumnType.DateTime;
                    }

                    return Kusto.Charting.ArgumentColumnType.String;
                },
                ArrayIsTimespan: function (arr) {
                    var $t;
                    var hasTimeSpanValues = false;
                    var ts = { };
                    $t = Bridge.getEnumerator(arr);
                    try {
                        while ($t.moveNext()) {
                            var val = $t.Current;
                            if (val == null) {
                                continue;
                            } else if (System.TimeSpan.tryParse(val, null, ts)) {
                                hasTimeSpanValues = true;
                                continue;
                            }

                            return false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return hasTimeSpanValues;
                },
                ArrayIsDatetime: function (arr) {
                    var $t;
                    var hasDateTimeValues = false;
                    var d = { };
                    $t = Bridge.getEnumerator(arr);
                    try {
                        while ($t.moveNext()) {
                            var val = $t.Current;
                            if (val == null) {
                                continue;
                            } else if (System.DateTime.tryParse(val, null, d)) {
                                hasDateTimeValues = true;
                                continue;
                            }

                            return false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return hasDateTimeValues;
                },
                ArrayIsDouble: function (arr) {
                    var $t;
                    var hasNumericValues = false;
                    var d = { };
                    $t = Bridge.getEnumerator(arr);
                    try {
                        while ($t.moveNext()) {
                            var val = $t.Current;
                            if (val == null) {
                                continue;
                            } else if (System.Double.tryParse(val, null, d)) {
                                hasNumericValues = true;
                                continue;
                            }

                            return false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return hasNumericValues;
                },
                CheckIfDBNull: function (value) {
                    // from all supported types, only System.DBNull returns string.Empty from ToString()
                    // so will consider that this assumption as sufficient 
                    return value != null && Bridge.referenceEquals(Bridge.toString(value), "");
                }
            }
        }
    });

    Bridge.ns("Kusto.Charting.DataChartsHelper", $asm.$);

    Bridge.apply($asm.$.Kusto.Charting.DataChartsHelper, {
        f1: function (d) {
            return d.SeriesName;
        },
        f2: function (d) {
            return d;
        },
        f3: function (d) {
            return System.Convert.toDouble(System.DateTime.getTicks(d.ArgumentDateTime));
        },
        f4: function (d) {
            return d.ArgumentNumeric;
        },
        f5: function (d) {
            return !Bridge.equals(d.ArgumentDateTime, Bridge.getDefaultValue(System.DateTime));
        },
        f6: function (d) {
            return d.ArgumentNumeric !== Bridge.getDefaultValue(System.Double);
        },
        f7: function (c) {
            return c.Item2;
        }
    });

    Bridge.define("Kusto.Charting.DataItem", {
        props: {
            SeriesName: null,
            ArgumentData: null,
            ValueData: 0,
            ValueName: null,
            ArgumentDateTime: null,
            ArgumentNumeric: 0,
            SecondaryAxisYName: null,
            PrefferredChartKind: 0
        },
        ctors: {
            init: function () {
                this.ArgumentDateTime = System.DateTime.getDefaultValue();
            }
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Charting.DataItem(), $t.SeriesName = this.SeriesName, $t.ArgumentData = this.ArgumentData, $t.ValueData = this.ValueData, $t.ValueName = this.ValueName, $t.ArgumentDateTime = this.ArgumentDateTime, $t.ArgumentNumeric = this.ArgumentNumeric, $t.SecondaryAxisYName = this.SecondaryAxisYName, $t.PrefferredChartKind = this.PrefferredChartKind, $t);
            }
        }
    });

    Bridge.define("Kusto.Charting.ExtendedDouble", {
        statics: {
            methods: {
                IsFinite: function (d) {
                    return !(Math.abs(d) === Number.POSITIVE_INFINITY) && !isNaN(d);
                }
            }
        }
    });

    Bridge.define("Kusto.Charting.IChartingDataSource", {
        $kind: "interface"
    });

    Bridge.define("Kusto.Charting.SeriesCreationException", {
        inherits: [System.Exception],
        ctors: {
            ctor: function (error) {
                this.$initialize();
                System.Exception.ctor.call(this, error);
            }
        }
    });

    Bridge.define("Kusto.Cloud.Platform.Text.StringLiteral", {
        statics: {
            methods: {
                /**
                 * Parses a CSL string literal. There are four kinds of string literals:
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Text.StringLiteral
                 * @memberof Kusto.Cloud.Platform.Text.StringLiteral
                 * @param   {string}    literal
                 * @return  {string}
                 */
                ParseStringLiteral: function (literal) {
                    var result = { };
                    if (Kusto.Cloud.Platform.Text.StringLiteral.TryParseStringLiteral(literal, result)) {
                        return result.v;
                    }

                    // TODO: Replace with an exception that traces
                    throw new System.ArgumentException.$ctor1(System.String.format("Malformed string literal: '{0}'", [literal]));
                },
                TryParseStringLiteral: function (str, literal) {
                    literal.v = str;

                    // We don't generally expect this to be true:
                    if (System.String.isNullOrWhiteSpace(literal.v)) {
                        return false;
                    }

                    // String literals starting with an 'h' or 'H' denote literals
                    // that should be hidden, but here we don't care.
                    if (literal.v.charCodeAt(0) === 104 || literal.v.charCodeAt(0) === 72) {
                        literal.v = literal.v.substr(1);
                    }

                    if (System.String.startsWith(literal.v, "\"")) {
                        if (literal.v.length >= 2 && System.String.endsWith(literal.v, "\"")) {
                            literal.v = literal.v.substr(1, ((literal.v.length - 2) | 0));
                            if (!Kusto.Cloud.Platform.Utils.ExtendedRegex.TryUnescape(literal.v, literal)) {
                                return false;
                            }
                            return true;
                        }
                    } else if (System.String.startsWith(literal.v, "'")) {
                        if (literal.v.length >= 2 && System.String.endsWith(literal.v, "'")) {
                            literal.v = literal.v.substr(1, ((literal.v.length - 2) | 0));
                            if (!Kusto.Cloud.Platform.Utils.ExtendedRegex.TryUnescape(literal.v, literal)) {
                                return false;
                            }
                            return true;
                        }
                    } else if (System.String.startsWith(literal.v, "@\"")) {
                        if (literal.v.length >= 3 && System.String.endsWith(literal.v, "\"")) {
                            var ret = literal.v.substr(2, ((literal.v.length - 3) | 0));
                            literal.v = System.String.replaceAll(ret, "\"\"", "\""); // "" -> "
                            return true;
                        }
                    } else if (System.String.startsWith(literal.v, "@'")) {
                        if (literal.v.length >= 3 && System.String.endsWith(literal.v, "'")) {
                            var ret1 = literal.v.substr(2, ((literal.v.length - 3) | 0));
                            literal.v = System.String.replaceAll(ret1, "''", "'"); // '' -> '
                            return true;
                        }
                    }

                    return false;
                },
                IsStringLiteral: function (str) {
                    if (System.String.isNullOrWhiteSpace(str)) {
                        return false;
                    }

                    var first = str.charCodeAt(0);
                    return (first === 34 || first === 39 || first === 64);
                },
                Equals: function (str1, str2) {
                    if (str1 == null && str2 == null) {
                        return true;
                    }

                    if (str1 == null || str2 == null) {
                        return false;
                    }

                    return System.String.equals(str1, str2, 4);
                },
                TrimSingleQuotes: function (name) {
                    if (System.String.isNullOrWhiteSpace(name)) {
                        return name;
                    }

                    if (System.String.startsWith(name, "'") && System.String.endsWith(name, "'") && name.length >= 2) {
                        name = name.substr(1, ((name.length - 2) | 0));
                    }

                    return name;
                },
                TrimBrackets: function (input) {
                    if (System.String.startsWith(input, "[") && System.String.endsWith(input, "]") && input.length >= 2) {
                        input = input.substr(1, ((input.length - 2) | 0));
                    }

                    return input;
                },
                InitArray: function (T, arr, value) {
                    if (arr != null) {
                        for (var i = 0; i < arr.length; i = (i + 1) | 0) {
                            arr[System.Array.index(i, arr)] = value;
                        }
                    }
                }
            }
        }
    });

    /** @namespace Kusto.Cloud.Platform.Utils */

    /**
     * CS freshman.
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Cloud.Platform.Utils.BitTwiddling
     */
    Bridge.define("Kusto.Cloud.Platform.Utils.BitTwiddling", {
        statics: {
            methods: {
                /**
                 * Count the number of bits set in the input (int).
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.BitTwiddling
                 * @memberof Kusto.Cloud.Platform.Utils.BitTwiddling
                 * @param   {number}    n
                 * @return  {number}
                 */
                CountBits: function (n) {
                    var ret = 0;

                    while (n !== 0) {
                        n = n & (((n - 1) | 0));
                        ret = (ret + 1) | 0;
                    }
                    return ret;
                },
                /**
                 * Count the number of bits set in the input (long).
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.BitTwiddling
                 * @memberof Kusto.Cloud.Platform.Utils.BitTwiddling
                 * @param   {System.Int64}    n
                 * @return  {number}
                 */
                CountBits$1: function (n) {
                    var ret = 0;

                    while (n.ne(System.Int64(0))) {
                        n = n.and((n.sub(System.Int64(1))));
                        ret = (ret + 1) | 0;
                    }
                    return ret;
                }
            }
        }
    });

    /**
     * Options to apply when chopping strings.
     *
     * @public
     * @class Kusto.Cloud.Platform.Utils.ChopOptions
     */
    Bridge.define("Kusto.Cloud.Platform.Utils.ChopOptions", {
        $kind: "enum",
        statics: {
            fields: {
                ChopFromBeginning: 1,
                ChopFromEnd: 2,
                ChopFromMiddle: 4,
                ThreeDotsCharacterNotSupported: 8
            }
        }
    });

    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Func
     * @param   {TCollection}    arg
     * @return  {boolean}
     */

    /**
     * Enumerable extension methods
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Cloud.Platform.Utils.ExtendedEnumerable
     */
    Bridge.define("Kusto.Cloud.Platform.Utils.ExtendedEnumerable", {
        statics: {
            methods: {
                /**
                 * Safely clones an existing collection in a shallow manner (it's the responsibility
                 of the element itself to be a value type of immutable).
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T             
                 * @param   {System.Collections.Generic.IEnumerable$1}    collection
                 * @return  {System.Collections.Generic.IEnumerable$1}
                 */
                SafeShallowClone: function (T, collection) {
                    if (collection == null) {
                        return null;
                    }

                    return new (System.Collections.Generic.List$1(T)).$ctor1(collection);
                },
                /**
                 * Returns the 0-based index of the first item in the collection
                 for which the predicate returns true, or -1.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    TCollection    
                 * @param   {System.Collections.Generic.IEnumerable$1}    collection     
                 * @param   {System.Func}                                 predicate
                 * @return  {number}
                 */
                IndexOf: function (TCollection, collection, predicate) {
                    var $t;
                    // TODO: What about Javascript?
                    // Ensure.ArgIsNotNull(predicate, "predicate");
                    if (Bridge.staticEquals(predicate, null)) {
                        return -1;
                    }

                    if (collection == null) {
                        return -1;
                    }

                    var i = 0;
                    $t = Bridge.getEnumerator(collection, TCollection);
                    try {
                        while ($t.moveNext()) {
                            var item = $t.Current;
                            if (predicate(item)) {
                                return i;
                            }
                            i = (i + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return -1;
                },
                /**
                 * Returns a collection that is the concatenation of two other collections.
                 Any of the arguments may be null. Result might also be null.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T         
                 * @param   {System.Collections.Generic.IEnumerable$1}    first     
                 * @param   {System.Collections.Generic.IEnumerable$1}    second
                 * @return  {System.Collections.Generic.IEnumerable$1}
                 */
                SafeConcat: function (T, first, second) {
                    if (first == null) {
                        return second;
                    }

                    if (second == null) {
                        return first;
                    }

                    return System.Linq.Enumerable.from(first).concat(second);
                },
                /**
                 * Returns a collection that is the union of two other collections (duplicates are excluded).
                 Any of the arguments may be null. Result might also be null.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T         
                 * @param   {System.Collections.Generic.IEnumerable$1}    first     
                 * @param   {System.Collections.Generic.IEnumerable$1}    second
                 * @return  {System.Collections.Generic.IEnumerable$1}
                 */
                SafeUnion: function (T, first, second) {
                    if (first == null && second == null) {
                        return null;
                    }

                    if (first == null) {
                        return System.Linq.Enumerable.from(second).distinct();
                    }

                    if (second == null) {
                        return System.Linq.Enumerable.from(first).distinct();
                    }

                    return System.Linq.Enumerable.from(first).union(second);
                },
                /**
                 * Returns the collection unless it is null or holds no elements,
                 in which case return null.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}       TCollection    
                 * @param   {TCollection}    collection
                 * @return  {TCollection}
                 */
                SafeFastNullIfEmpty: function (TCollection, collection) {
                    if (collection == null || Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone(collection)) {
                        return null;
                    }

                    return collection;
                },
                SafeEmptyIEnumerableIfNull: function (T, collectionEnumerable) {
                    return collectionEnumerable || System.Linq.Enumerable.empty();
                },
                /**
                 * Similar to IEnumerable{T}.Any, only faster and works on null arguments.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T             
                 * @param   {System.Collections.Generic.IEnumerable$1}    collection
                 * @return  {boolean}
                 */
                SafeFastAny$4: function (T, collection) {
                    if (collection == null) {
                        return false;
                    }

                    { // Scope to ensure no cross-talk with next block
                        var asICollectionT = Bridge.as(collection, System.Collections.Generic.ICollection$1(T));
                        if (asICollectionT != null) {
                            return System.Array.getCount(asICollectionT, T) !== 0;
                        }
                    }

                    {
                        var asICollection = Bridge.as(collection, System.Collections.ICollection);
                        if (asICollection != null) {
                            return System.Array.getCount(asICollection) !== 0;
                        }
                    }



                    return System.Linq.Enumerable.from(collection).any();
                },
                SafeFastAny$3: function (T, collection) {
                    return collection != null && System.Array.getCount(collection, T) > 0;
                },
                SafeFastAny$6: function (T, collection) {
                    return collection != null && collection.Count > 0;
                },
                SafeFastAny$2: function (T, collection) {
                    return collection != null && collection.Count > 0;
                },
                SafeFastAny$7: function (K, V, collection) {
                    return collection != null && collection.count > 0;
                },
                SafeFastAny$1: function (T, collection) {
                    return collection != null && collection.length > 0;
                },
                /**
                 * Similar to IEnumerable.Any, only faster and works on null arguments.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {System.Collections.IEnumerable}    collection
                 * @return  {boolean}
                 */
                SafeFastAny: function (collection) {
                    var $t;
                    if (collection == null) {
                        return false;
                    }

                    { // Scope to ensure no cross-talk with next block
                        var asICollection = Bridge.as(collection, System.Collections.ICollection);
                        if (asICollection != null) {
                            return System.Array.getCount(asICollection) !== 0;
                        }
                    }

                    var e = Bridge.getEnumerator(collection);
                    $t = Bridge.as(e, System.IDisposable);
                    try {
                        if (e.System$Collections$IEnumerator$moveNext()) {
                            return true;
                        }
                    }
                    finally {
                        if (Bridge.hasValue($t)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return false;
                },
                SafeFastAny$5: function (T, collection, predicate) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(T, collection)) {
                        return false;
                    }

                    return System.Linq.Enumerable.from(collection).any(predicate);
                },
                /**
                 * Similar to IEnumerable{T}.Contains, only faster and works on null arguments.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                          T             
                 * @param   {System.Collections.Generic.IEnumerable$1}          collection    
                 * @param   {T}                                                 item          
                 * @param   {System.Collections.Generic.IEqualityComparer$1}    comparer
                 * @return  {boolean}
                 */
                SafeFastContains: function (T, collection, item, comparer) {
                    if (comparer === void 0) { comparer = null; }
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(T, collection)) {
                        return false;
                    }

                    return System.Linq.Enumerable.from(collection).contains(item, comparer);
                },
                /**
                 * Similar to IEnumerable{T}.None, only faster and works on null arguments.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T             
                 * @param   {System.Collections.Generic.IEnumerable$1}    collection
                 * @return  {boolean}
                 */
                SafeFastNone$1: function (T, collection) {
                    return !Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(T, collection);
                },
                /**
                 * Similar to IEnumerable.None, only faster and works on null arguments.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {System.Collections.IEnumerable}    collection
                 * @return  {boolean}
                 */
                SafeFastNone: function (collection) {
                    return !Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny(collection);
                },
                /**
                 * Inverse of IEnumerable{T}.Any(predicate)
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T            Element type
                 * @param   {System.Collections.Generic.IEnumerable$1}    source       The source IEnumerable.
                 * @param   {System.Func}                                 predicate    The predicate.
                 * @return  {boolean}                                                  true if none of the specified collection items match the given predicate
                 */
                None$1: function (T, source, predicate) {
                    return !System.Linq.Enumerable.from(source).any(predicate);
                },
                /**
                 * Overload. Inverse of IEnumerable{T}.Any()
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T         Element type
                 * @param   {System.Collections.Generic.IEnumerable$1}    source    The source IEnumerable.
                 * @return  {boolean}                                               true if the collection is empty
                 */
                None: function (T, source) {
                    return Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(T, source);
                },
                /**
                 * Returns a collection where each key appears only once
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T              Element type
                 * @param   {Function}                                    TKey           Key selector
                 * @param   {System.Collections.Generic.IEnumerable$1}    source         IEnumerable collection
                 * @param   {System.Func}                                 keySelector    Key selector function
                 * @return  {System.Collections.Generic.IEnumerable$1}                   Returns collection of items that are aggregated by unique key selector
                 */
                DistinctBy: function (T, TKey, source, keySelector) {
                    return System.Linq.Enumerable.from(source).groupBy(keySelector).select($asm.$.Kusto.Cloud.Platform.Utils.ExtendedEnumerable.f1);
                },
                /**
                 * Returns an intersection of the given collections
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedEnumerable
                 * @param   {Function}                                    T              Element type
                 * @param   {System.Collections.Generic.IEnumerable$1}    collections    The collection to intersect
                 * @return  {System.Collections.Generic.IEnumerable$1}                   Returns collection of items with the given collections intersection
                 */
                Intersect: function (T, collections) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.System.Collections.Generic.IEnumerable$1(T), collections)) {
                        return null;
                    }

                    var enumerator = Bridge.getEnumerator(collections, System.Collections.Generic.IEnumerable$1(T));
                    if (enumerator.System$Collections$IEnumerator$moveNext()) {
                        var result = new (System.Collections.Generic.HashSet$1(T)).$ctor1(enumerator[Bridge.geti(enumerator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);

                        while (enumerator.System$Collections$IEnumerator$moveNext()) {
                            result.intersectWith(enumerator[Bridge.geti(enumerator, "System$Collections$Generic$IEnumerator$1$System$Collections$Generic$IEnumerable$1$" + Bridge.getTypeAlias(T) + "$Current$1", "System$Collections$Generic$IEnumerator$1$Current$1")]);
                        }

                        return result;
                    }
                    return null;
                },
                IntersectWith: function (T, collection, other) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(T, collection)) {
                        return other;
                    }

                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(T, other)) {
                        return collection;
                    }

                    var result = new (System.Collections.Generic.HashSet$1(T)).$ctor1(collection);
                    result.intersectWith(other);
                    return result;
                }
            }
        }
    });

    Bridge.ns("Kusto.Cloud.Platform.Utils.ExtendedEnumerable", $asm.$);

    Bridge.apply($asm.$.Kusto.Cloud.Platform.Utils.ExtendedEnumerable, {
        f1: function (x) {
            return x.first();
        }
    });

    Bridge.define("Kusto.Cloud.Platform.Utils.ExtendedRegex", {
        statics: {
            methods: {
                TryUnescape: function (str, result) {
                    result.v = "";
                    try {
                        result.v = System.Text.RegularExpressions.Regex.unescape(str);
                        return true;
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArgumentException)) {
                            return false;
                        } else {
                            throw $e1;
                        }
                    }
                },
                TryTransformWildCardPatternToRegex: function (wildcardPattern) {
                    try {
                        // First, remove the [] brackets
                        var input = System.String.trim(wildcardPattern, [91, 93]);
                        var regexString = System.String.replaceAll(input, "*", ".*");
                        return new System.Text.RegularExpressions.Regex.ctor(regexString, 0);
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        // Creation of regex failed
                        return null;
                    }
                },
                IsWildCardPattern: function (wildcardPattern) {
                    return System.String.indexOf(wildcardPattern, String.fromCharCode(42)) >= 0;
                }
            }
        }
    });

    /**
     * Extensions for {@link }
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Cloud.Platform.Utils.ExtendedString
     */
    Bridge.define("Kusto.Cloud.Platform.Utils.ExtendedString", {
        statics: {
            fields: {
                c_newlineAsStringArray: null,
                c_postfix: null,
                c_wrap: null,
                c_nullGuids: null,
                /**
                 * A delegate that can be used to get an object's value safely
                 when it is unknown if the object will be null or not.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @type System.Func
                 */
                SafeToString: null,
                /**
                 * An empty (no elements) string array.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @type Array.<string>
                 */
                EmptyArray: null
            },
            ctors: {
                init: function () {
                    this.c_newlineAsStringArray = System.Array.init(["\n"], System.String);
                    this.c_postfix = "...";
                    this.c_wrap = "  ";
                    this.c_nullGuids = System.Array.init([System.Guid.Empty.toString(), "{" + (System.Guid.Empty.toString() || "") + "}"], System.String);
                    this.SafeToString = $asm.$.Kusto.Cloud.Platform.Utils.ExtendedString.f1;
                    this.EmptyArray = System.Array.init(0, null, System.String);
                }
            },
            methods: {
                /**
                 * A safe version (will not throw on null) of string.GetHashCode().
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    value
                 * @return  {number}
                 */
                SafeGetHashCode: function (value) {
                    if (value == null) {
                        return 20080512;
                    }
                    return Bridge.getHashCode(value);
                },
                /**
                 * This fast calculation is relying on the fact that the different characters in the 
                 Guid are already random (across a limited range of values though)".
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    value
                 * @return  {number}
                 */
                GuidSafeFastGetHashCode: function (value) {
                    if (value == null || value.length < 26) {
                        return Kusto.Cloud.Platform.Utils.ExtendedString.SafeGetHashCode(value);
                    }
                    return (value.charCodeAt(1) ^ value.charCodeAt(9) << 8 | value.charCodeAt(10)) ^ (value.charCodeAt(16) << 16 | value.charCodeAt(17)) ^ (value.charCodeAt(24) << 24 | value.charCodeAt(25));
                },
                /**
                 * Like {@link }, but extra-safe with nulls.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}                   format    
                 * @param   {Array.<System.Object>}    args
                 * @return  {string}
                 */
                SafeFormat: function (format, args) {
                    if (args === void 0) { args = []; }
                    if (format == null) {
                        return "[format:null]";
                    }

                    if (args == null || args.length === 0) {
                        return System.String.format.apply(System.String, [format].concat(args));
                    }

                    var args2 = System.Array.init(args.length, null, System.String);
                    for (var a = 0; a < args.length; a = (a + 1) | 0) {
                        var arg = args[System.Array.index(a, args)];
                        var arg2;
                        if (arg == null) {
                            arg2 = "[null]";
                        } else {
                            var argStr = Bridge.toString(arg); // NOTE: This loses the user-provided format string!
                            if (argStr == null) {
                                arg2 = "[ToStringNull]";
                            } else if (argStr.length === 0) {
                                arg2 = "[ToStringEmpty]";
                            } else if (System.String.isNullOrWhiteSpace(argStr)) {
                                arg2 = "[ToStringWhitespace]";
                            } else {
                                arg2 = argStr;
                            }
                        }
                        args2[System.Array.index(a, args2)] = arg2;
                    }

                    return System.String.format.apply(System.String, [format].concat(args2));
                },
                /**
                 * Replaces the format item in a specified string with the string representation
                 of a corresponding object in a specified array with the current culture.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @throws {System.ArgumentNullException} format or args is null.
                 * @throws {System.FormatException} format is invalid.-or- The index of a format item is less than zero, or greater
                 than or equal to the length of the args array.
                 * @param   {string}                   format    A composite format string.
                 * @param   {Array.<System.Object>}    args      An object array that contains zero or more objects to format.
                 * @return  {string}                             A copy of format in which the format items have been replaced by the string
                 representation of the corresponding objects in args.
                 */
                FormatWithCurrentCulture: function (format, args) {
                    if (args === void 0) { args = []; }
                    return Kusto.Cloud.Platform.Utils.ExtendedString.FormatWith(format, System.Globalization.CultureInfo.getCurrentCulture(), args);
                },
                /**
                 * Replaces the format item in a specified string with the string representation
                 of a corresponding object in a specified array with an invariant culture.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @throws {System.ArgumentNullException} format or args is null.
                 * @throws {System.FormatException} format is invalid.-or- The index of a format item is less than zero, or greater
                 than or equal to the length of the args array.
                 * @param   {string}                   format    A composite format string.
                 * @param   {Array.<System.Object>}    args      An object array that contains zero or more objects to format.
                 * @return  {string}                             A copy of format in which the format items have been replaced by the string
                 representation of the corresponding objects in args.
                 */
                FormatWithInvariantCulture: function (format, args) {
                    if (args === void 0) { args = []; }
                    return Kusto.Cloud.Platform.Utils.ExtendedString.FormatWith(format, System.Globalization.CultureInfo.invariantCulture, args);
                },
                /**
                 * Replaces the format item in a specified string with the string representation
                 of a corresponding object in a specified array. A specified parameter supplies
                 culture-specific formatting information.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @throws {System.ArgumentNullException} format or args is null.
                 * @throws {System.FormatException} format is invalid.-or- The index of a format item is less than zero, or greater
                 than or equal to the length of the args array.
                 * @param   {string}                    format            A composite format string.
                 * @param   {System.IFormatProvider}    formatProvider    An object that supplies culture-specific formatting information.
                 * @param   {Array.<System.Object>}     args              An object array that contains zero or more objects to format.
                 * @return  {string}                                      A copy of format in which the format items have been replaced by the string
                 representation of the corresponding objects in args.
                 */
                FormatWith: function (format, formatProvider, args) {
                    if (args === void 0) { args = []; }
                    return System.String.formatProvider.apply(System.String, [formatProvider, format].concat(args));
                },
                /**
                 * Returns true if the string is null, empty, whitespace, or
                 indicates a null Guid (all zeros).
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}     value
                 * @return  {boolean}
                 */
                SafeIsNullGuid: function (value) {
                    return System.String.isNullOrWhiteSpace(value) || Bridge.referenceEquals(value, Kusto.Cloud.Platform.Utils.ExtendedString.c_nullGuids[System.Array.index(0, Kusto.Cloud.Platform.Utils.ExtendedString.c_nullGuids)]) || Bridge.referenceEquals(value, Kusto.Cloud.Platform.Utils.ExtendedString.c_nullGuids[System.Array.index(1, Kusto.Cloud.Platform.Utils.ExtendedString.c_nullGuids)]);
                },
                /**
                 * Removes all leading and trailing white-space characters from the given string
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text
                 * @return  {string}
                 */
                SafeFastTrim: function (text) {
                    return !System.String.isNullOrWhiteSpace(text) ? text.trim() : text;
                },
                /**
                 * Trims a prefix from a string
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text      The text to trim.
                 * @param   {string}    prefix    Prefix to remove
                 * @return  {string}
                 */
                TrimStart$1: function (text, prefix) {
                    if (System.String.startsWith(text, prefix)) {
                        return text.substr(prefix.length, ((text.length - prefix.length) | 0));
                    }
                    return text;
                },
                /**
                 * Trims a character from the beginning of a string.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}     text       The text to trim.
                 * @param   {number}     c          The character to remove from the beginning of <b>c</b>
                 if it exists.
                 * @param   {boolean}    justOne    If true, remove just one instance of the character.
                 * @return  {string}                The trimmed string.
                 */
                TrimStart: function (text, c, justOne) {
                    if (System.String.isNullOrEmpty(text)) {
                        return text;
                    }

                    if (justOne) {
                        return text.charCodeAt(0) === c ? text.substr(1) : text;
                    }

                    if (text.charCodeAt(0) !== c) {
                        return text;
                    }

                    var i = 0;
                    while (i < text.length && text.charCodeAt(i) === c) {
                        i = (i + 1) | 0;
                    }
                    if (i === text.length) {
                        return "";
                    }
                    return text.substr(i);
                },
                /**
                 * Trims a prefix from a string
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text      The text to trim.
                 * @param   {string}    suffix    Prefix to remove
                 * @return  {string}
                 */
                TrimEnd: function (text, suffix) {
                    if (System.String.endsWith(text, suffix)) {
                        return text.substr(0, ((text.length - suffix.length) | 0));
                    }
                    return text;
                },
                /**
                 * Removes a single pair of balanced [ and ] characters
                 that start and end the string, if they exist.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text
                 * @return  {string}
                 */
                TrimBalancedSquareBrackets: function (text) {
                    if (text != null && System.String.startsWith(text, "[") && System.String.endsWith(text, "]")) {
                        text = text.substr(1, ((text.length - 2) | 0));
                    }

                    return text;
                },
                /**
                 * Removes a single pair of balanced ( and ) characters
                 that start and end the string, if they exist.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text
                 * @return  {string}
                 */
                TrimBalancedRoundBrackets: function (text) {
                    return Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalanced(text, "(", ")");
                },
                /**
                 * Removes a single pair of balanced [ and ] characters
                 that start and end the string, if they exist.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text        
                 * @param   {string}    openning    
                 * @param   {string}    closing
                 * @return  {string}
                 */
                TrimBalanced: function (text, openning, closing) {
                    if (text != null && System.String.startsWith(text, openning) && System.String.endsWith(text, closing)) {
                        text = text.substr(openning.length, ((text.length - (((openning.length + closing.length) | 0))) | 0));
                    }

                    return text;
                },
                /**
                 * Trims a string from single (') or double (") quotes surrounding it,
                 as long as they are balanced.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text
                 * @return  {string}
                 */
                TrimBalancedSingleAndDoubleQuotes: function (text) {
                    if (System.String.isNullOrEmpty(text)) {
                        return text;
                    }

                    var start = 0;
                    var end = (text.length - 1) | 0;

                    while (start < end) {
                        if (text.charCodeAt(start) === 34 && text.charCodeAt(end) === 34) {
                            start = (start + 1) | 0;
                            end = (end - 1) | 0;
                            continue;
                        }
                        if (text.charCodeAt(start) === 39 && text.charCodeAt(end) === 39) {
                            start = (start + 1) | 0;
                            end = (end - 1) | 0;
                            continue;
                        }

                        break;
                    }

                    if (start > end) {
                        return "";
                    }

                    return text.substr(start, ((((end - start) | 0) + 1) | 0));
                },
                
                FindFirstNonWhitespaceCharacter: function (value, index) {
                    if (index === void 0) { index = 0; }
                    if (value == null) {
                        return -1;
                    }

                    while (true) {
                        if (index >= value.length) {
                            return -1;
                        }

                        if (!System.Char.isWhiteSpace(String.fromCharCode(value.charCodeAt(index)))) {
                            return index;
                        }

                        index = (index + 1) | 0;
                    }
                },
                /**
                 * Returns the index of the first character that is not equal between two strings.
                 Returns -1 if they are identical.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    lhs    
                 * @param   {string}    rhs
                 * @return  {number}
                 */
                FirstFirstUnequalCharacter: function (lhs, rhs) {
                    if (Bridge.referenceEquals(lhs, rhs)) {
                        return -1;
                    }

                    // Since the two are not equal, we can safely assume that if one has no characters,
                    // it's the first character that is different
                    if (lhs == null || rhs == null || lhs.length === 0 || rhs.length === 0) {
                        return 0;
                    }

                    var i = 0;
                    for (; i < lhs.length && i < rhs.length; i = (i + 1) | 0) {
                        if (lhs.charCodeAt(i) !== rhs.charCodeAt(i)) {
                            return i;
                        }
                    }

                    return i;
                },
                /**
                 * Counts how many times a substring appears in the string, non-overlapping.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}                     text          The string we suspect may have one or more appearrences of the substring.
                 * @param   {string}                     substring     The substring to find and count. Non-null and non-empty.
                 * @param   {System.StringComparison}    comparison    How to compare strings.
                 * @return  {number}                                   The number of times <b /> appears in <b />
                 (non-overlapping: "aa" appears exactly twice in "aaaa", not three times).
                 */
                CountNonOverlappingSubstrings$1: function (text, substring, comparison) {
                    if (comparison === void 0) { comparison = 4; }
                    if (System.String.isNullOrEmpty(text) || System.String.isNullOrEmpty(substring)) {
                        return 0;
                    }

                    var count = 0;
                    var i = 0;
                    while (i < text.length) {
                        i = System.String.indexOf(text, substring, i, text.length, comparison);
                        if (i < 0) {
                            return count;
                        }

                        count = (count + 1) | 0;
                        i = (i + substring.length) | 0;
                    }

                    return count;
                },
                /**
                 * Similar to {@link },
                 but counts the occurrences of a single character in the text.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    text    
                 * @param   {number}    c
                 * @return  {number}
                 */
                CountNonOverlappingSubstrings: function (text, c) {
                    if (System.String.isNullOrEmpty(text)) {
                        return 0;
                    }

                    var count = 0;
                    var i = 0;
                    while (i < text.length) {
                        i = System.String.indexOf(text, String.fromCharCode(c), i);
                        if (i < 0) {
                            return count;
                        }

                        count = (count + 1) | 0;
                        i = (i + 1) | 0;
                    }

                    return count;
                },
                /**
                 * Returns true if <b />'s first character
                 is <b />, or false otherwise. Tolerant
                 to null strings.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}     what    
                 * @param   {number}     c
                 * @return  {boolean}
                 */
                SafeStartsWith: function (what, c) {
                    if (System.String.isNullOrEmpty(what)) {
                        return false;
                    }

                    return what.charCodeAt(0) === c;
                },
                /**
                 * Similar to {@link }, but (1) gets the number of characters
                 in the "tail" to return rather than the count of characters to skip, and (2) is safe
                 and does not throw.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    what      
                 * @param   {number}    length
                 * @return  {string}
                 */
                SafeGetTail: function (what, length) {
                    if (what == null) {
                        return null;
                    }

                    if (length <= 0) {
                        return "";
                    }

                    if (length >= what.length) {
                        return what;
                    }

                    return what.substr(((what.length - length) | 0));
                },
                /**
                 * Returns the beginning of the string <b /> up to
                 but not including the first appearence of <b />.
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    what         
                 * @param   {string}    delimiter
                 * @return  {string}
                 */
                SplitFirst: function (what, delimiter) {
                    if (what == null || System.String.isNullOrEmpty(delimiter)) {
                        return null;
                    }

                    var delimiterIndex = System.String.indexOf(what, delimiter, 0, what.length, 4);
                    if (delimiterIndex < 0) {
                        return what;
                    }

                    var first = what.substr(0, delimiterIndex);
                    return first;
                },
                /**
                 * Rotates right the string (right shift, where the last character becomes the first).
                 (It might create an invalid string, for Some unicode characters that don't fit 16 bits and are represented by two UTF16 characters).
                 *
                 * @static
                 * @public
                 * @this Kusto.Cloud.Platform.Utils.ExtendedString
                 * @memberof Kusto.Cloud.Platform.Utils.ExtendedString
                 * @param   {string}    s
                 * @return  {string}
                 */
                Rotate: function (s) {
                    if (System.String.isNullOrEmpty(s) || s.length < 2) {
                        return s;
                    }

                    return (s.substr(1, ((s.length - 1) | 0)) || "") + (s.substr(0, 1) || "");
                }
            }
        }
    });

    Bridge.ns("Kusto.Cloud.Platform.Utils.ExtendedString", $asm.$);

    Bridge.apply($asm.$.Kusto.Cloud.Platform.Utils.ExtendedString, {
        f1: function (obj) {
            var $t;
            return obj != null ? (($t = Bridge.toString(obj), $t != null ? $t : "[ToStringNull]")) : "[null]";
        }
    });

    Bridge.define("Kusto.Data.Common.CslQueryParser", {
        statics: {
            methods: {
                PrettifyQuery: function (query, appendText) {
                    var parser = new Kusto.Data.IntelliSense.CslCommandParser();
                    var commands = parser.Parse(null, query, Kusto.Data.IntelliSense.ParseMode.CommandTokensOnly);
                    if (System.Linq.Enumerable.from(commands).count() !== 1) {
                        // Skip any prettifying if there is more than one command
                        return query;
                    }

                    // Format query nicely
                    var queryFormatted = System.Linq.Enumerable.from(commands).first().FormatAsString("\n", 7);
                    if (System.String.isNullOrEmpty(queryFormatted)) {
                        queryFormatted = query;
                    }

                    if (!System.String.isNullOrEmpty(appendText)) {
                        queryFormatted = (queryFormatted || "") + (appendText || "");
                    }
                    return queryFormatted;
                }
            }
        }
    });

    /** @namespace Kusto.Data.Common */

    /**
     * Flavor of DatabaseShow command
     *
     * @public
     * @class Kusto.Data.Common.DatabaseShowFlavor
     */
    Bridge.define("Kusto.Data.Common.DatabaseShowFlavor", {
        $kind: "enum",
        statics: {
            fields: {
                Identity: 0,
                Verbose: 1,
                Policies: 2,
                DataStats: 3
            }
        }
    });

    /**
     * Kusto Entity Types.
     *
     * @public
     * @class Kusto.Data.Common.EntityType
     */
    Bridge.define("Kusto.Data.Common.EntityType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Unknown
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 0
                 * @type Kusto.Data.Common.EntityType
                 */
                Unknown: 0,
                /**
                 * Cluster entity type
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 1
                 * @type Kusto.Data.Common.EntityType
                 */
                Cluster: 1,
                /**
                 * Database entity type
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 2
                 * @type Kusto.Data.Common.EntityType
                 */
                Database: 2,
                /**
                 * Table entity type
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 3
                 * @type Kusto.Data.Common.EntityType
                 */
                Table: 3,
                /**
                 * Column entity type
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 4
                 * @type Kusto.Data.Common.EntityType
                 */
                Column: 4,
                /**
                 * Function entity type
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.EntityType
                 * @constant
                 * @default 5
                 * @type Kusto.Data.Common.EntityType
                 */
                Function: 5
            }
        }
    });

    /**
     * Extensions for enum DatabaseShowFlavor
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Common.ExtendedDatabaseShowFlavor
     */
    Bridge.define("Kusto.Data.Common.ExtendedDatabaseShowFlavor", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.DatabaseShowFlavor.Identity: 
                            return "Identity";
                        case Kusto.Data.Common.DatabaseShowFlavor.Verbose: 
                            return "Verbose";
                        case Kusto.Data.Common.DatabaseShowFlavor.Policies: 
                            return "Policies";
                        case Kusto.Data.Common.DatabaseShowFlavor.DataStats: 
                            return "DataStats";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.Common.DatabaseShowFlavor() };
                    return Kusto.Data.Common.ExtendedDatabaseShowFlavor.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.Common.DatabaseShowFlavor.Identity: 
                            return true;
                        case Kusto.Data.Common.DatabaseShowFlavor.Verbose: 
                            return true;
                        case Kusto.Data.Common.DatabaseShowFlavor.Policies: 
                            return true;
                        case Kusto.Data.Common.DatabaseShowFlavor.DataStats: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Common.DatabaseShowFlavor() };
                    if (Kusto.Data.Common.ExtendedDatabaseShowFlavor.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "0": 
                        case "Identity": 
                            ret.v = Kusto.Data.Common.DatabaseShowFlavor.Identity;
                            return true;
                        case "1": 
                        case "Verbose": 
                            ret.v = Kusto.Data.Common.DatabaseShowFlavor.Verbose;
                            return true;
                        case "2": 
                        case "Policies": 
                            ret.v = Kusto.Data.Common.DatabaseShowFlavor.Policies;
                            return true;
                        case "3": 
                        case "DataStats": 
                            ret.v = Kusto.Data.Common.DatabaseShowFlavor.DataStats;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "identity": 
                                ret.v = Kusto.Data.Common.DatabaseShowFlavor.Identity;
                                return true;
                            case "verbose": 
                                ret.v = Kusto.Data.Common.DatabaseShowFlavor.Verbose;
                                return true;
                            case "policies": 
                                ret.v = Kusto.Data.Common.DatabaseShowFlavor.Policies;
                                return true;
                            case "datastats": 
                                ret.v = Kusto.Data.Common.DatabaseShowFlavor.DataStats;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.DatabaseShowFlavor.Identity: 
                            return "";
                        case Kusto.Data.Common.DatabaseShowFlavor.Verbose: 
                            return "";
                        case Kusto.Data.Common.DatabaseShowFlavor.Policies: 
                            return "";
                        case Kusto.Data.Common.DatabaseShowFlavor.DataStats: 
                            return "";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Extensions for enum EntityType
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Common.ExtendedEntityType
     */
    Bridge.define("Kusto.Data.Common.ExtendedEntityType", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.EntityType.Unknown: 
                            return "Unknown";
                        case Kusto.Data.Common.EntityType.Cluster: 
                            return "Cluster";
                        case Kusto.Data.Common.EntityType.Database: 
                            return "Database";
                        case Kusto.Data.Common.EntityType.Table: 
                            return "Table";
                        case Kusto.Data.Common.EntityType.Column: 
                            return "Column";
                        case Kusto.Data.Common.EntityType.Function: 
                            return "Function";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.Common.EntityType() };
                    return Kusto.Data.Common.ExtendedEntityType.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.Common.EntityType.Unknown: 
                            return true;
                        case Kusto.Data.Common.EntityType.Cluster: 
                            return true;
                        case Kusto.Data.Common.EntityType.Database: 
                            return true;
                        case Kusto.Data.Common.EntityType.Table: 
                            return true;
                        case Kusto.Data.Common.EntityType.Column: 
                            return true;
                        case Kusto.Data.Common.EntityType.Function: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Common.EntityType() };
                    if (Kusto.Data.Common.ExtendedEntityType.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "0": 
                        case "Unknown": 
                            ret.v = Kusto.Data.Common.EntityType.Unknown;
                            return true;
                        case "1": 
                        case "Cluster": 
                            ret.v = Kusto.Data.Common.EntityType.Cluster;
                            return true;
                        case "2": 
                        case "Database": 
                            ret.v = Kusto.Data.Common.EntityType.Database;
                            return true;
                        case "3": 
                        case "Table": 
                            ret.v = Kusto.Data.Common.EntityType.Table;
                            return true;
                        case "4": 
                        case "Column": 
                            ret.v = Kusto.Data.Common.EntityType.Column;
                            return true;
                        case "5": 
                        case "Function": 
                            ret.v = Kusto.Data.Common.EntityType.Function;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "unknown": 
                                ret.v = Kusto.Data.Common.EntityType.Unknown;
                                return true;
                            case "cluster": 
                                ret.v = Kusto.Data.Common.EntityType.Cluster;
                                return true;
                            case "database": 
                                ret.v = Kusto.Data.Common.EntityType.Database;
                                return true;
                            case "table": 
                                ret.v = Kusto.Data.Common.EntityType.Table;
                                return true;
                            case "column": 
                                ret.v = Kusto.Data.Common.EntityType.Column;
                                return true;
                            case "function": 
                                ret.v = Kusto.Data.Common.EntityType.Function;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.EntityType.Unknown: 
                            return "Unknown";
                        case Kusto.Data.Common.EntityType.Cluster: 
                            return "Cluster entity type";
                        case Kusto.Data.Common.EntityType.Database: 
                            return "Database entity type";
                        case Kusto.Data.Common.EntityType.Table: 
                            return "Table entity type";
                        case Kusto.Data.Common.EntityType.Column: 
                            return "Column entity type";
                        case Kusto.Data.Common.EntityType.Function: 
                            return "Function entity type";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Extensions for enum IngestionErrorCategory
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Common.ExtendedIngestionErrorCategory
     */
    Bridge.define("Kusto.Data.Common.ExtendedIngestionErrorCategory", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.IngestionErrorCategory.Unknown: 
                            return "Unknown";
                        case Kusto.Data.Common.IngestionErrorCategory.InternalServiceError: 
                            return "InternalServiceError";
                        case Kusto.Data.Common.IngestionErrorCategory.BadFormat: 
                            return "BadFormat";
                        case Kusto.Data.Common.IngestionErrorCategory.BadRequest: 
                            return "BadRequest";
                        case Kusto.Data.Common.IngestionErrorCategory.BlobNotFound: 
                            return "BlobNotFound";
                        case Kusto.Data.Common.IngestionErrorCategory.UpdatePolicyFailure: 
                            return "UpdatePolicyFailure";
                        case Kusto.Data.Common.IngestionErrorCategory.EntityNotFound: 
                            return "EntityNotFound";
                        case Kusto.Data.Common.IngestionErrorCategory.UserAccessNotAuthorized: 
                            return "UserAccessNotAuthorized";
                        case Kusto.Data.Common.IngestionErrorCategory.DataAccessNotAuthorized: 
                            return "DataAccessNotAuthorized";
                        case Kusto.Data.Common.IngestionErrorCategory.FileTooLarge: 
                            return "FileTooLarge";
                        case Kusto.Data.Common.IngestionErrorCategory.ThrottledOnEngine: 
                            return "ThrottledOnEngine";
                        case Kusto.Data.Common.IngestionErrorCategory.DownloadFailed: 
                            return "DownloadFailed";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.Common.IngestionErrorCategory() };
                    return Kusto.Data.Common.ExtendedIngestionErrorCategory.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.Common.IngestionErrorCategory.Unknown: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.InternalServiceError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.BadFormat: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.BadRequest: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.BlobNotFound: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.UpdatePolicyFailure: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.EntityNotFound: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.UserAccessNotAuthorized: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.DataAccessNotAuthorized: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.FileTooLarge: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.ThrottledOnEngine: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCategory.DownloadFailed: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Common.IngestionErrorCategory() };
                    if (Kusto.Data.Common.ExtendedIngestionErrorCategory.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "Unknown": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.Unknown;
                            return true;
                        case "InternalServiceError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.InternalServiceError;
                            return true;
                        case "BadFormat": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.BadFormat;
                            return true;
                        case "BadRequest": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.BadRequest;
                            return true;
                        case "BlobNotFound": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.BlobNotFound;
                            return true;
                        case "UpdatePolicyFailure": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.UpdatePolicyFailure;
                            return true;
                        case "EntityNotFound": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.EntityNotFound;
                            return true;
                        case "UserAccessNotAuthorized": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.UserAccessNotAuthorized;
                            return true;
                        case "DataAccessNotAuthorized": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.DataAccessNotAuthorized;
                            return true;
                        case "FileTooLarge": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.FileTooLarge;
                            return true;
                        case "ThrottledOnEngine": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.ThrottledOnEngine;
                            return true;
                        case "DownloadFailed": 
                            ret.v = Kusto.Data.Common.IngestionErrorCategory.DownloadFailed;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "unknown": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.Unknown;
                                return true;
                            case "internalserviceerror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.InternalServiceError;
                                return true;
                            case "badformat": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.BadFormat;
                                return true;
                            case "badrequest": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.BadRequest;
                                return true;
                            case "blobnotfound": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.BlobNotFound;
                                return true;
                            case "updatepolicyfailure": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.UpdatePolicyFailure;
                                return true;
                            case "entitynotfound": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.EntityNotFound;
                                return true;
                            case "useraccessnotauthorized": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.UserAccessNotAuthorized;
                                return true;
                            case "dataaccessnotauthorized": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.DataAccessNotAuthorized;
                                return true;
                            case "filetoolarge": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.FileTooLarge;
                                return true;
                            case "throttledonengine": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.ThrottledOnEngine;
                                return true;
                            case "downloadfailed": 
                                ret.v = Kusto.Data.Common.IngestionErrorCategory.DownloadFailed;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.IngestionErrorCategory.Unknown: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.InternalServiceError: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.BadFormat: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.BadRequest: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.BlobNotFound: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.UpdatePolicyFailure: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.EntityNotFound: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.UserAccessNotAuthorized: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.DataAccessNotAuthorized: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.FileTooLarge: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.ThrottledOnEngine: 
                            return "";
                        case Kusto.Data.Common.IngestionErrorCategory.DownloadFailed: 
                            return "";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Extensions for enum IngestionErrorCode
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Common.ExtendedIngestionErrorCode
     */
    Bridge.define("Kusto.Data.Common.ExtendedIngestionErrorCode", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.IngestionErrorCode.Unknown: 
                            return "Unknown";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_LowMemoryCondition: 
                            return "Stream_LowMemoryCondition";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_WrongNumberOfFields: 
                            return "Stream_WrongNumberOfFields";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_InputStreamTooLarge: 
                            return "Stream_InputStreamTooLarge";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_NoDataToIngest: 
                            return "Stream_NoDataToIngest";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_ClosingQuoteMissing: 
                            return "Stream_ClosingQuoteMissing";
                        case Kusto.Data.Common.IngestionErrorCode.Download_SourceNotFound: 
                            return "Download_SourceNotFound";
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccessConditionNotSatisfied: 
                            return "Download_AccessConditionNotSatisfied";
                        case Kusto.Data.Common.IngestionErrorCode.Download_Forbidden: 
                            return "Download_Forbidden";
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccountNotFound: 
                            return "Download_AccountNotFound";
                        case Kusto.Data.Common.IngestionErrorCode.Download_BadRequest: 
                            return "Download_BadRequest";
                        case Kusto.Data.Common.IngestionErrorCode.Download_NotTransient: 
                            return "Download_NotTransient";
                        case Kusto.Data.Common.IngestionErrorCode.Download_UnknownError: 
                            return "Download_UnknownError";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_QuerySchemaDoesNotMatchTableSchema: 
                            return "UpdatePolicy_QuerySchemaDoesNotMatchTableSchema";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_FailedDescendantTransaction: 
                            return "UpdatePolicy_FailedDescendantTransaction";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_IngestionError: 
                            return "UpdatePolicy_IngestionError";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_UnknownError: 
                            return "UpdatePolicy_UnknownError";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MissingJsonMappingtFailure: 
                            return "BadRequest_MissingJsonMappingtFailure";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyBlob: 
                            return "BadRequest_InvalidOrEmptyBlob";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DatabaseNotExist: 
                            return "BadRequest_DatabaseNotExist";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableNotExist: 
                            return "BadRequest_TableNotExist";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidKustoIdentityToken: 
                            return "BadRequest_InvalidKustoIdentityToken";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_UriMissingSas: 
                            return "BadRequest_UriMissingSas";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FileTooLarge: 
                            return "BadRequest_FileTooLarge";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_NoValidResponseFromEngine: 
                            return "BadRequest_NoValidResponseFromEngine";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableAccessDenied: 
                            return "BadRequest_TableAccessDenied";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MessageExhausted: 
                            return "BadRequest_MessageExhausted";
                        case Kusto.Data.Common.IngestionErrorCode.General_BadRequest: 
                            return "General_BadRequest";
                        case Kusto.Data.Common.IngestionErrorCode.General_InternalServerError: 
                            return "General_InternalServerError";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Cyclic_Update_Not_Allowed: 
                            return "UpdatePolicy_Cyclic_Update_Not_Allowed";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion: 
                            return "UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidCsvMapping: 
                            return "BadRequest_InvalidCsvMapping";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidMappingReference: 
                            return "BadRequest_InvalidMappingReference";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MappingReferenceWasNotFound: 
                            return "BadRequest_MappingReferenceWasNotFound";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidJsonMapping: 
                            return "BadRequest_InvalidJsonMapping";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FormatNotSupported: 
                            return "BadRequest_FormatNotSupported";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DuplicateMapping: 
                            return "BadRequest_DuplicateMapping";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_CorruptedMessage: 
                            return "BadRequest_CorruptedMessage";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InconsistentMapping: 
                            return "BadRequest_InconsistentMapping";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_SyntaxError: 
                            return "BadRequest_SyntaxError";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyTableName: 
                            return "BadRequest_InvalidOrEmptyTableName";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyDatabaseName: 
                            return "BadRequest_EmptyDatabaseName";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyTenantIdentifier: 
                            return "BadRequest_EmptyTenantIdentifier";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyMappingReference: 
                            return "BadRequest_EmptyMappingReference";
                        case Kusto.Data.Common.IngestionErrorCode.General_AbandonedIngestion: 
                            return "General_AbandonedIngestion";
                        case Kusto.Data.Common.IngestionErrorCode.General_ThrottledIngestion: 
                            return "General_ThrottledIngestion";
                        case Kusto.Data.Common.IngestionErrorCode.General_TransientSchemaMismatch: 
                            return "General_TransientSchemaMismatch";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.UInt32)]);
                    }
                },
                FastIsDefined: function (value) {
                    var dummy = { v : new Kusto.Data.Common.IngestionErrorCode() };
                    return Kusto.Data.Common.ExtendedIngestionErrorCode.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined$1: function (value) {
                    switch (value) {
                        case Kusto.Data.Common.IngestionErrorCode.Unknown: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Stream_LowMemoryCondition: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Stream_WrongNumberOfFields: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Stream_InputStreamTooLarge: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Stream_NoDataToIngest: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Stream_ClosingQuoteMissing: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_SourceNotFound: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccessConditionNotSatisfied: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_Forbidden: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccountNotFound: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_BadRequest: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_NotTransient: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.Download_UnknownError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_QuerySchemaDoesNotMatchTableSchema: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_FailedDescendantTransaction: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_IngestionError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_UnknownError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MissingJsonMappingtFailure: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyBlob: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DatabaseNotExist: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableNotExist: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidKustoIdentityToken: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_UriMissingSas: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FileTooLarge: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_NoValidResponseFromEngine: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableAccessDenied: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MessageExhausted: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.General_BadRequest: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.General_InternalServerError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Cyclic_Update_Not_Allowed: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidCsvMapping: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidMappingReference: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MappingReferenceWasNotFound: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidJsonMapping: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FormatNotSupported: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DuplicateMapping: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_CorruptedMessage: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InconsistentMapping: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_SyntaxError: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyTableName: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyDatabaseName: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyTenantIdentifier: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyMappingReference: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.General_AbandonedIngestion: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.General_ThrottledIngestion: 
                            return true;
                        case Kusto.Data.Common.IngestionErrorCode.General_TransientSchemaMismatch: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((((that & flag) >>> 0)) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((((that & flag) >>> 0)) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Common.IngestionErrorCode() };
                    if (Kusto.Data.Common.ExtendedIngestionErrorCode.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "Unknown": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Unknown;
                            return true;
                        case "0x80DA0007": 
                        case "Stream_LowMemoryCondition": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_LowMemoryCondition;
                            return true;
                        case "0x80DA0008": 
                        case "Stream_WrongNumberOfFields": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_WrongNumberOfFields;
                            return true;
                        case "0x80DA0009": 
                        case "Stream_InputStreamTooLarge": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_InputStreamTooLarge;
                            return true;
                        case "Stream_NoDataToIngest": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_NoDataToIngest;
                            return true;
                        case "0x80DA000b": 
                        case "Stream_ClosingQuoteMissing": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_ClosingQuoteMissing;
                            return true;
                        case "Download_SourceNotFound": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_SourceNotFound;
                            return true;
                        case "Download_AccessConditionNotSatisfied": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_AccessConditionNotSatisfied;
                            return true;
                        case "Download_Forbidden": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_Forbidden;
                            return true;
                        case "Download_AccountNotFound": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_AccountNotFound;
                            return true;
                        case "Download_BadRequest": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_BadRequest;
                            return true;
                        case "Download_NotTransient": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_NotTransient;
                            return true;
                        case "Download_UnknownError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.Download_UnknownError;
                            return true;
                        case "UpdatePolicy_QuerySchemaDoesNotMatchTableSchema": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_QuerySchemaDoesNotMatchTableSchema;
                            return true;
                        case "UpdatePolicy_FailedDescendantTransaction": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_FailedDescendantTransaction;
                            return true;
                        case "UpdatePolicy_IngestionError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_IngestionError;
                            return true;
                        case "UpdatePolicy_UnknownError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_UnknownError;
                            return true;
                        case "BadRequest_MissingJsonMappingtFailure": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MissingJsonMappingtFailure;
                            return true;
                        case "BadRequest_InvalidOrEmptyBlob": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyBlob;
                            return true;
                        case "BadRequest_DatabaseNotExist": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_DatabaseNotExist;
                            return true;
                        case "BadRequest_TableNotExist": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_TableNotExist;
                            return true;
                        case "BadRequest_InvalidKustoIdentityToken": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidKustoIdentityToken;
                            return true;
                        case "BadRequest_UriMissingSas": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_UriMissingSas;
                            return true;
                        case "BadRequest_FileTooLarge": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_FileTooLarge;
                            return true;
                        case "BadRequest_NoValidResponseFromEngine": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_NoValidResponseFromEngine;
                            return true;
                        case "BadRequest_TableAccessDenied": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_TableAccessDenied;
                            return true;
                        case "BadRequest_MessageExhausted": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MessageExhausted;
                            return true;
                        case "General_BadRequest": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.General_BadRequest;
                            return true;
                        case "General_InternalServerError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.General_InternalServerError;
                            return true;
                        case "UpdatePolicy_Cyclic_Update_Not_Allowed": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Cyclic_Update_Not_Allowed;
                            return true;
                        case "UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion;
                            return true;
                        case "BadRequest_InvalidCsvMapping": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidCsvMapping;
                            return true;
                        case "BadRequest_InvalidMappingReference": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidMappingReference;
                            return true;
                        case "BadRequest_MappingReferenceWasNotFound": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MappingReferenceWasNotFound;
                            return true;
                        case "BadRequest_InvalidJsonMapping": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidJsonMapping;
                            return true;
                        case "BadRequest_FormatNotSupported": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_FormatNotSupported;
                            return true;
                        case "BadRequest_DuplicateMapping": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_DuplicateMapping;
                            return true;
                        case "BadRequest_CorruptedMessage": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_CorruptedMessage;
                            return true;
                        case "BadRequest_InconsistentMapping": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InconsistentMapping;
                            return true;
                        case "BadRequest_SyntaxError": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_SyntaxError;
                            return true;
                        case "BadRequest_InvalidOrEmptyTableName": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyTableName;
                            return true;
                        case "BadRequest_EmptyDatabaseName": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyDatabaseName;
                            return true;
                        case "BadRequest_EmptyTenantIdentifier": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyTenantIdentifier;
                            return true;
                        case "BadRequest_EmptyMappingReference": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyMappingReference;
                            return true;
                        case "General_AbandonedIngestion": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.General_AbandonedIngestion;
                            return true;
                        case "General_ThrottledIngestion": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.General_ThrottledIngestion;
                            return true;
                        case "General_TransientSchemaMismatch": 
                            ret.v = Kusto.Data.Common.IngestionErrorCode.General_TransientSchemaMismatch;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "unknown": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Unknown;
                                return true;
                            case "stream_lowmemorycondition": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_LowMemoryCondition;
                                return true;
                            case "stream_wrongnumberoffields": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_WrongNumberOfFields;
                                return true;
                            case "stream_inputstreamtoolarge": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_InputStreamTooLarge;
                                return true;
                            case "stream_nodatatoingest": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_NoDataToIngest;
                                return true;
                            case "stream_closingquotemissing": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Stream_ClosingQuoteMissing;
                                return true;
                            case "download_sourcenotfound": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_SourceNotFound;
                                return true;
                            case "download_accessconditionnotsatisfied": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_AccessConditionNotSatisfied;
                                return true;
                            case "download_forbidden": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_Forbidden;
                                return true;
                            case "download_accountnotfound": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_AccountNotFound;
                                return true;
                            case "download_badrequest": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_BadRequest;
                                return true;
                            case "download_nottransient": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_NotTransient;
                                return true;
                            case "download_unknownerror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.Download_UnknownError;
                                return true;
                            case "updatepolicy_queryschemadoesnotmatchtableschema": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_QuerySchemaDoesNotMatchTableSchema;
                                return true;
                            case "updatepolicy_faileddescendanttransaction": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_FailedDescendantTransaction;
                                return true;
                            case "updatepolicy_ingestionerror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_IngestionError;
                                return true;
                            case "updatepolicy_unknownerror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_UnknownError;
                                return true;
                            case "badrequest_missingjsonmappingtfailure": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MissingJsonMappingtFailure;
                                return true;
                            case "badrequest_invalidoremptyblob": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyBlob;
                                return true;
                            case "badrequest_databasenotexist": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_DatabaseNotExist;
                                return true;
                            case "badrequest_tablenotexist": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_TableNotExist;
                                return true;
                            case "badrequest_invalidkustoidentitytoken": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidKustoIdentityToken;
                                return true;
                            case "badrequest_urimissingsas": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_UriMissingSas;
                                return true;
                            case "badrequest_filetoolarge": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_FileTooLarge;
                                return true;
                            case "badrequest_novalidresponsefromengine": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_NoValidResponseFromEngine;
                                return true;
                            case "badrequest_tableaccessdenied": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_TableAccessDenied;
                                return true;
                            case "badrequest_messageexhausted": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MessageExhausted;
                                return true;
                            case "general_badrequest": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.General_BadRequest;
                                return true;
                            case "general_internalservererror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.General_InternalServerError;
                                return true;
                            case "updatepolicy_cyclic_update_not_allowed": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Cyclic_Update_Not_Allowed;
                                return true;
                            case "updatepolicy_transactional_not_allowed_in_streaming_ingestion": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion;
                                return true;
                            case "badrequest_invalidcsvmapping": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidCsvMapping;
                                return true;
                            case "badrequest_invalidmappingreference": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidMappingReference;
                                return true;
                            case "badrequest_mappingreferencewasnotfound": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_MappingReferenceWasNotFound;
                                return true;
                            case "badrequest_invalidjsonmapping": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidJsonMapping;
                                return true;
                            case "badrequest_formatnotsupported": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_FormatNotSupported;
                                return true;
                            case "badrequest_duplicatemapping": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_DuplicateMapping;
                                return true;
                            case "badrequest_corruptedmessage": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_CorruptedMessage;
                                return true;
                            case "badrequest_inconsistentmapping": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InconsistentMapping;
                                return true;
                            case "badrequest_syntaxerror": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_SyntaxError;
                                return true;
                            case "badrequest_invalidoremptytablename": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyTableName;
                                return true;
                            case "badrequest_emptydatabasename": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyDatabaseName;
                                return true;
                            case "badrequest_emptytenantidentifier": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyTenantIdentifier;
                                return true;
                            case "badrequest_emptymappingreference": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyMappingReference;
                                return true;
                            case "general_abandonedingestion": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.General_AbandonedIngestion;
                                return true;
                            case "general_throttledingestion": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.General_ThrottledIngestion;
                                return true;
                            case "general_transientschemamismatch": 
                                ret.v = Kusto.Data.Common.IngestionErrorCode.General_TransientSchemaMismatch;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v >>> 0;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Common.IngestionErrorCode.Unknown: 
                            return "Unknown error occurred";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_LowMemoryCondition: 
                            return "Low memory condition.";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_WrongNumberOfFields: 
                            return "Wrong number of fields.";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_InputStreamTooLarge: 
                            return "Input stream/record/field too large.";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_NoDataToIngest: 
                            return "No data streams to ingest";
                        case Kusto.Data.Common.IngestionErrorCode.Stream_ClosingQuoteMissing: 
                            return "Invalid csv format - closing quote missing.";
                        case Kusto.Data.Common.IngestionErrorCode.Download_SourceNotFound: 
                            return "Failed to download source from Azure storage - source not found";
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccessConditionNotSatisfied: 
                            return "Failed to download source from Azure storage - access condition not satisfied";
                        case Kusto.Data.Common.IngestionErrorCode.Download_Forbidden: 
                            return "Failed to download source from Azure storage - access forbidden";
                        case Kusto.Data.Common.IngestionErrorCode.Download_AccountNotFound: 
                            return "Failed to download source from Azure storage - account not found";
                        case Kusto.Data.Common.IngestionErrorCode.Download_BadRequest: 
                            return "Failed to download source from Azure storage - bad request";
                        case Kusto.Data.Common.IngestionErrorCode.Download_NotTransient: 
                            return "Failed to download source from Azure storage - not transient error";
                        case Kusto.Data.Common.IngestionErrorCode.Download_UnknownError: 
                            return "Failed to download source from Azure storage - unknown error";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_QuerySchemaDoesNotMatchTableSchema: 
                            return "Failed to invoke update policy. Query schema does not match table schema";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_FailedDescendantTransaction: 
                            return "Failed to invoke update policy. Failed descendant transactional update policy";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_IngestionError: 
                            return "Failed to invoke update policy. Ingestion Error occurred";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_UnknownError: 
                            return "Failed to invoke update policy. Unknown error occurred";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MissingJsonMappingtFailure: 
                            return "Json pattern was not ingested with jsonMapping parameter";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyBlob: 
                            return "Blob is invalid or empty zip archive";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DatabaseNotExist: 
                            return "Database does not exist";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableNotExist: 
                            return "Table does not exist";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidKustoIdentityToken: 
                            return "Invalid kusto identity token";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_UriMissingSas: 
                            return "Blob path without SAS from unknown blob storage";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FileTooLarge: 
                            return "File too large";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_NoValidResponseFromEngine: 
                            return "No valid reply from ingest command";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_TableAccessDenied: 
                            return "Access to table is denied";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MessageExhausted: 
                            return "Message is exhausted";
                        case Kusto.Data.Common.IngestionErrorCode.General_BadRequest: 
                            return "Bad request";
                        case Kusto.Data.Common.IngestionErrorCode.General_InternalServerError: 
                            return "Internal server error occurred";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Cyclic_Update_Not_Allowed: 
                            return "Failed to invoke update policy. Cyclic update is not allowed";
                        case Kusto.Data.Common.IngestionErrorCode.UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion: 
                            return "Failed to invoke update policy. Transactional update policy is not allowed in streaming ingestion";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidCsvMapping: 
                            return "Failed to parse csv mapping.";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidMappingReference: 
                            return "Invalid mapping reference.";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_MappingReferenceWasNotFound: 
                            return "Mapping reference wasn't found.";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidJsonMapping: 
                            return "Failed to parse json mapping.";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_FormatNotSupported: 
                            return "Format is not supported";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_DuplicateMapping: 
                            return "Ingestion properties contains ingestion mapping and ingestion mapping reference.";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_CorruptedMessage: 
                            return "Message is corrupted";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InconsistentMapping: 
                            return "Inconsistent ingestion mapping";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_SyntaxError: 
                            return "Syntax error";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_InvalidOrEmptyTableName: 
                            return "Table name is empty or invalid";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyDatabaseName: 
                            return "Database name is empty";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyTenantIdentifier: 
                            return "TenantIdentifier is empty";
                        case Kusto.Data.Common.IngestionErrorCode.BadRequest_EmptyMappingReference: 
                            return "MappingReference is empty";
                        case Kusto.Data.Common.IngestionErrorCode.General_AbandonedIngestion: 
                            return "Abandoned ingestion.";
                        case Kusto.Data.Common.IngestionErrorCode.General_ThrottledIngestion: 
                            return "Throttled ingestion.";
                        case Kusto.Data.Common.IngestionErrorCode.General_TransientSchemaMismatch: 
                            return "Schema of target table at start time doesn't match the one at commit time.";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * The IngestionErrorCode Category.
     *
     * @public
     * @class Kusto.Data.Common.IngestionErrorCategory
     */
    Bridge.define("Kusto.Data.Common.IngestionErrorCategory", {
        $kind: "enum",
        statics: {
            fields: {
                Unknown: 0,
                InternalServiceError: 1,
                BadFormat: 2,
                BadRequest: 3,
                BlobNotFound: 4,
                UpdatePolicyFailure: 5,
                EntityNotFound: 6,
                UserAccessNotAuthorized: 7,
                DataAccessNotAuthorized: 8,
                FileTooLarge: 9,
                ThrottledOnEngine: 10,
                DownloadFailed: 11
            }
        }
    });

    /**
     * The ingestion error code returned by a Kusto service.
     *
     * @public
     * @class Kusto.Data.Common.IngestionErrorCode
     * @augments number
     */
    Bridge.define("Kusto.Data.Common.IngestionErrorCode", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Unknown error occurred
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 0
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Unknown: 0,
                /**
                 * Low memory condition.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770503
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Stream_LowMemoryCondition: 2161770503,
                /**
                 * Wrong number of fields.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770504
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Stream_WrongNumberOfFields: 2161770504,
                /**
                 * Input stream/record/field too large.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770505
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Stream_InputStreamTooLarge: 2161770505,
                /**
                 * No data streams to ingest
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770506
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Stream_NoDataToIngest: 2161770506,
                /**
                 * Invalid csv format - closing quote missing.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770507
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Stream_ClosingQuoteMissing: 2161770507,
                /**
                 * Failed to download source from Azure storage - source not found
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770508
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_SourceNotFound: 2161770508,
                /**
                 * Failed to download source from Azure storage - access condition not satisfied
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770509
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_AccessConditionNotSatisfied: 2161770509,
                /**
                 * Failed to download source from Azure storage - access forbidden
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770510
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_Forbidden: 2161770510,
                /**
                 * Failed to download source from Azure storage - account not found
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770511
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_AccountNotFound: 2161770511,
                /**
                 * Failed to download source from Azure storage - bad request
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770512
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_BadRequest: 2161770512,
                /**
                 * Failed to download source from Azure storage - not transient error
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770513
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_NotTransient: 2161770513,
                /**
                 * Failed to download source from Azure storage - unknown error
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770514
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                Download_UnknownError: 2161770514,
                /**
                 * Failed to invoke update policy. Query schema does not match table schema
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770515
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_QuerySchemaDoesNotMatchTableSchema: 2161770515,
                /**
                 * Failed to invoke update policy. Failed descendant transactional update policy
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770516
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_FailedDescendantTransaction: 2161770516,
                /**
                 * Failed to invoke update policy. Ingestion Error occurred
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770517
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_IngestionError: 2161770517,
                /**
                 * Failed to invoke update policy. Unknown error occurred
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770518
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_UnknownError: 2161770518,
                /**
                 * Json pattern was not ingested with jsonMapping parameter
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770519
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_MissingJsonMappingtFailure: 2161770519,
                /**
                 * Blob is invalid or empty zip archive
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770520
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidOrEmptyBlob: 2161770520,
                /**
                 * Database does not exist
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770521
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_DatabaseNotExist: 2161770521,
                /**
                 * Table does not exist
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770522
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_TableNotExist: 2161770522,
                /**
                 * Invalid kusto identity token
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770523
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidKustoIdentityToken: 2161770523,
                /**
                 * Blob path without SAS from unknown blob storage
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770524
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_UriMissingSas: 2161770524,
                /**
                 * File too large
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770525
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_FileTooLarge: 2161770525,
                /**
                 * No valid reply from ingest command
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770526
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_NoValidResponseFromEngine: 2161770526,
                /**
                 * Access to table is denied
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770527
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_TableAccessDenied: 2161770527,
                /**
                 * Message is exhausted
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770528
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_MessageExhausted: 2161770528,
                /**
                 * Bad request
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770529
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                General_BadRequest: 2161770529,
                /**
                 * Internal server error occurred
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770530
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                General_InternalServerError: 2161770530,
                /**
                 * Failed to invoke update policy. Cyclic update is not allowed
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770531
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_Cyclic_Update_Not_Allowed: 2161770531,
                /**
                 * Failed to invoke update policy. Transactional update policy is not allowed in streaming ingestion
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770532
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                UpdatePolicy_Transactional_Not_Allowed_In_Streaming_Ingestion: 2161770532,
                /**
                 * Failed to parse csv mapping.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770533
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidCsvMapping: 2161770533,
                /**
                 * Invalid mapping reference.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770534
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidMappingReference: 2161770534,
                /**
                 * Mapping reference wasn't found.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770535
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_MappingReferenceWasNotFound: 2161770535,
                /**
                 * Failed to parse json mapping.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770536
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidJsonMapping: 2161770536,
                /**
                 * Format is not supported
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770537
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_FormatNotSupported: 2161770537,
                /**
                 * Ingestion properties contains ingestion mapping and ingestion mapping reference.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770538
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_DuplicateMapping: 2161770538,
                /**
                 * Message is corrupted
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770539
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_CorruptedMessage: 2161770539,
                /**
                 * Inconsistent ingestion mapping
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770540
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InconsistentMapping: 2161770540,
                /**
                 * Syntax error
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770541
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_SyntaxError: 2161770541,
                /**
                 * Table name is empty or invalid
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770542
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_InvalidOrEmptyTableName: 2161770542,
                /**
                 * Database name is empty
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770543
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_EmptyDatabaseName: 2161770543,
                /**
                 * TenantIdentifier is empty
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770544
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_EmptyTenantIdentifier: 2161770544,
                /**
                 * MappingReference is empty
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770545
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                BadRequest_EmptyMappingReference: 2161770545,
                /**
                 * Abandoned ingestion.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770546
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                General_AbandonedIngestion: 2161770546,
                /**
                 * Throttled ingestion.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770547
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                General_ThrottledIngestion: 2161770547,
                /**
                 * Schema of target table at start time doesn't match the one at commit time.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Common.IngestionErrorCode
                 * @constant
                 * @default 2161770548
                 * @type Kusto.Data.Common.IngestionErrorCode
                 */
                General_TransientSchemaMismatch: 2161770548
            }
        },
        $utype: System.UInt32
    });

    /** @namespace Kusto.Data */

    /**
     * DM Settings Types
     *
     * @public
     * @class Kusto.Data.DmSettingsType
     */
    Bridge.define("Kusto.Data.DmSettingsType", {
        $kind: "enum",
        statics: {
            fields: {
                AdminSettings: 0,
                DataObtainerServiceSettings: 1,
                DataAggregatorSettings: 2,
                DataObtainerSettings: 3,
                CloudQueueMessageManagerSettings: 4,
                CloudManagersSettings: 5,
                SchemaManagmentSettings: 6,
                CommonSettings: 7,
                DataImporterSettings: 8,
                All: 9
            }
        }
    });

    /**
     * Extensions for enum DmSettingsType
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.ExtendedDmSettingsType
     */
    Bridge.define("Kusto.Data.ExtendedDmSettingsType", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.DmSettingsType.AdminSettings: 
                            return "AdminSettings";
                        case Kusto.Data.DmSettingsType.DataObtainerServiceSettings: 
                            return "DataObtainerServiceSettings";
                        case Kusto.Data.DmSettingsType.DataAggregatorSettings: 
                            return "DataAggregatorSettings";
                        case Kusto.Data.DmSettingsType.DataObtainerSettings: 
                            return "DataObtainerSettings";
                        case Kusto.Data.DmSettingsType.CloudQueueMessageManagerSettings: 
                            return "CloudQueueMessageManagerSettings";
                        case Kusto.Data.DmSettingsType.CloudManagersSettings: 
                            return "CloudManagersSettings";
                        case Kusto.Data.DmSettingsType.SchemaManagmentSettings: 
                            return "SchemaManagmentSettings";
                        case Kusto.Data.DmSettingsType.CommonSettings: 
                            return "CommonSettings";
                        case Kusto.Data.DmSettingsType.DataImporterSettings: 
                            return "DataImporterSettings";
                        case Kusto.Data.DmSettingsType.All: 
                            return "All";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.DmSettingsType() };
                    return Kusto.Data.ExtendedDmSettingsType.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.DmSettingsType.AdminSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.DataObtainerServiceSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.DataAggregatorSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.DataObtainerSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.CloudQueueMessageManagerSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.CloudManagersSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.SchemaManagmentSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.CommonSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.DataImporterSettings: 
                            return true;
                        case Kusto.Data.DmSettingsType.All: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.DmSettingsType() };
                    if (Kusto.Data.ExtendedDmSettingsType.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "AdminSettings": 
                            ret.v = Kusto.Data.DmSettingsType.AdminSettings;
                            return true;
                        case "DataObtainerServiceSettings": 
                            ret.v = Kusto.Data.DmSettingsType.DataObtainerServiceSettings;
                            return true;
                        case "DataAggregatorSettings": 
                            ret.v = Kusto.Data.DmSettingsType.DataAggregatorSettings;
                            return true;
                        case "DataObtainerSettings": 
                            ret.v = Kusto.Data.DmSettingsType.DataObtainerSettings;
                            return true;
                        case "CloudQueueMessageManagerSettings": 
                            ret.v = Kusto.Data.DmSettingsType.CloudQueueMessageManagerSettings;
                            return true;
                        case "CloudManagersSettings": 
                            ret.v = Kusto.Data.DmSettingsType.CloudManagersSettings;
                            return true;
                        case "SchemaManagmentSettings": 
                            ret.v = Kusto.Data.DmSettingsType.SchemaManagmentSettings;
                            return true;
                        case "CommonSettings": 
                            ret.v = Kusto.Data.DmSettingsType.CommonSettings;
                            return true;
                        case "DataImporterSettings": 
                            ret.v = Kusto.Data.DmSettingsType.DataImporterSettings;
                            return true;
                        case "All": 
                            ret.v = Kusto.Data.DmSettingsType.All;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "adminsettings": 
                                ret.v = Kusto.Data.DmSettingsType.AdminSettings;
                                return true;
                            case "dataobtainerservicesettings": 
                                ret.v = Kusto.Data.DmSettingsType.DataObtainerServiceSettings;
                                return true;
                            case "dataaggregatorsettings": 
                                ret.v = Kusto.Data.DmSettingsType.DataAggregatorSettings;
                                return true;
                            case "dataobtainersettings": 
                                ret.v = Kusto.Data.DmSettingsType.DataObtainerSettings;
                                return true;
                            case "cloudqueuemessagemanagersettings": 
                                ret.v = Kusto.Data.DmSettingsType.CloudQueueMessageManagerSettings;
                                return true;
                            case "cloudmanagerssettings": 
                                ret.v = Kusto.Data.DmSettingsType.CloudManagersSettings;
                                return true;
                            case "schemamanagmentsettings": 
                                ret.v = Kusto.Data.DmSettingsType.SchemaManagmentSettings;
                                return true;
                            case "commonsettings": 
                                ret.v = Kusto.Data.DmSettingsType.CommonSettings;
                                return true;
                            case "dataimportersettings": 
                                ret.v = Kusto.Data.DmSettingsType.DataImporterSettings;
                                return true;
                            case "all": 
                                ret.v = Kusto.Data.DmSettingsType.All;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.DmSettingsType.AdminSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.DataObtainerServiceSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.DataAggregatorSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.DataObtainerSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.CloudQueueMessageManagerSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.CloudManagersSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.SchemaManagmentSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.CommonSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.DataImporterSettings: 
                            return "";
                        case Kusto.Data.DmSettingsType.All: 
                            return "";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Extensions for enum IngestionQueueType
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.ExtendedIngestionQueueType
     */
    Bridge.define("Kusto.Data.ExtendedIngestionQueueType", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.IngestionQueueType.All: 
                            return "All";
                        case Kusto.Data.IngestionQueueType.InputQueue: 
                            return "InputQueue";
                        case Kusto.Data.IngestionQueueType.InternalQueue: 
                            return "InternalQueue";
                        case Kusto.Data.IngestionQueueType.ReadyForAggregationQueue: 
                            return "ReadyForAggregationQueue";
                        case Kusto.Data.IngestionQueueType.SecuredReadyForAggregationQueue: 
                            return "SecuredReadyForAggregationQueue";
                        case Kusto.Data.IngestionQueueType.AggregatedReadyForImportQueue: 
                            return "AggregatedReadyForImportQueue";
                        case Kusto.Data.IngestionQueueType.FailedIngestionsQueue: 
                            return "FailedIngestionsQueue";
                        case Kusto.Data.IngestionQueueType.SuccessfulIngestionsQueue: 
                            return "SuccessfulIngestionsQueue";
                        case Kusto.Data.IngestionQueueType.AbandonedIngestionsQueue: 
                            return "AbandonedIngestionsQueue";
                        case Kusto.Data.IngestionQueueType.SecuredAbandonedIngestionsQueue: 
                            return "SecuredAbandonedIngestionsQueue";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.IngestionQueueType() };
                    return Kusto.Data.ExtendedIngestionQueueType.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.IngestionQueueType.All: 
                            return true;
                        case Kusto.Data.IngestionQueueType.InputQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.InternalQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.ReadyForAggregationQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.SecuredReadyForAggregationQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.AggregatedReadyForImportQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.FailedIngestionsQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.SuccessfulIngestionsQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.AbandonedIngestionsQueue: 
                            return true;
                        case Kusto.Data.IngestionQueueType.SecuredAbandonedIngestionsQueue: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.IngestionQueueType() };
                    if (Kusto.Data.ExtendedIngestionQueueType.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "0": 
                        case "All": 
                            ret.v = Kusto.Data.IngestionQueueType.All;
                            return true;
                        case "1": 
                        case "InputQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.InputQueue;
                            return true;
                        case "2": 
                        case "InternalQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.InternalQueue;
                            return true;
                        case "3": 
                        case "ReadyForAggregationQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.ReadyForAggregationQueue;
                            return true;
                        case "4": 
                        case "SecuredReadyForAggregationQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.SecuredReadyForAggregationQueue;
                            return true;
                        case "5": 
                        case "AggregatedReadyForImportQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.AggregatedReadyForImportQueue;
                            return true;
                        case "6": 
                        case "FailedIngestionsQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.FailedIngestionsQueue;
                            return true;
                        case "7": 
                        case "SuccessfulIngestionsQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.SuccessfulIngestionsQueue;
                            return true;
                        case "9": 
                        case "AbandonedIngestionsQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.AbandonedIngestionsQueue;
                            return true;
                        case "10": 
                        case "SecuredAbandonedIngestionsQueue": 
                            ret.v = Kusto.Data.IngestionQueueType.SecuredAbandonedIngestionsQueue;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "all": 
                                ret.v = Kusto.Data.IngestionQueueType.All;
                                return true;
                            case "inputqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.InputQueue;
                                return true;
                            case "internalqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.InternalQueue;
                                return true;
                            case "readyforaggregationqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.ReadyForAggregationQueue;
                                return true;
                            case "securedreadyforaggregationqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.SecuredReadyForAggregationQueue;
                                return true;
                            case "aggregatedreadyforimportqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.AggregatedReadyForImportQueue;
                                return true;
                            case "failedingestionsqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.FailedIngestionsQueue;
                                return true;
                            case "successfulingestionsqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.SuccessfulIngestionsQueue;
                                return true;
                            case "abandonedingestionsqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.AbandonedIngestionsQueue;
                                return true;
                            case "securedabandonedingestionsqueue": 
                                ret.v = Kusto.Data.IngestionQueueType.SecuredAbandonedIngestionsQueue;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.IngestionQueueType.All: 
                            return "";
                        case Kusto.Data.IngestionQueueType.InputQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.InternalQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.ReadyForAggregationQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.SecuredReadyForAggregationQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.AggregatedReadyForImportQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.FailedIngestionsQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.SuccessfulIngestionsQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.AbandonedIngestionsQueue: 
                            return "";
                        case Kusto.Data.IngestionQueueType.SecuredAbandonedIngestionsQueue: 
                            return "";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Ingestion Queue Types
     *
     * @public
     * @class Kusto.Data.IngestionQueueType
     */
    Bridge.define("Kusto.Data.IngestionQueueType", {
        $kind: "enum",
        statics: {
            fields: {
                All: 0,
                InputQueue: 1,
                InternalQueue: 2,
                ReadyForAggregationQueue: 3,
                SecuredReadyForAggregationQueue: 4,
                AggregatedReadyForImportQueue: 5,
                FailedIngestionsQueue: 6,
                SuccessfulIngestionsQueue: 7,
                AbandonedIngestionsQueue: 9,
                SecuredAbandonedIngestionsQueue: 10
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.AdminEngineRuleKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Start: 0,
                YieldShowCommandOptions: 0,
                YieldTableNamesForAdminOptions: 1,
                YieldFunctionNamesForAdminOptions: 2,
                YieldDatabaseNames: 3,
                YieldShowBasicAuthOptions: 4,
                YieldShowDatabasePrincipalsPoliciesAndSchemaOptions: 5,
                YieldShowDatabasesOptions: 6,
                YieldShowClusterPrincipalsOptions: 7,
                YieldSetDatabaseAdminsUsersViewersPrettyNameOptions: 8,
                YieldSetClusterAdminsUsersViewersDatabaseCreatorsOptions: 9,
                YieldSetTableAdminsOptions: 10,
                YieldAddDatabaseAdminsUsersViewersOptions: 11,
                YieldDropDatabaseOptions: 12,
                YieldAddClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions: 13,
                YieldDropClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions: 14,
                YieldAddClusterBlockedPrincipalsOptions: 15,
                YieldAddTableAdminsOptions: 16,
                YieldDropTableEntitiesOptions: 17,
                YieldDeleteTableEntitiesOptions: 18,
                YieldCreateTableEntitiesOptions: 19,
                YieldAlterTableEntitiesOptions: 20,
                YieldDropTableColumnsSyntaxOptions: 21,
                YieldSetDatabaseUsersNoneOptions: 22,
                YieldSetDatabaseAdminsNoneOptions: 23,
                YieldSetDatabaseViewersNoneOptions: 24,
                YieldSetClusterUsersNoneOptions: 25,
                YieldSetClusterAdminsNoneOptions: 26,
                YieldSetClusterViewersNoneOptions: 27,
                YieldSetClusterDatabaseCreatorsNoneOptions: 28,
                YieldSetTableAdminsNoneOptions: 29,
                YieldShowTableEntitiesOptions: 30,
                YieldAlterExtentTagsOptions: 31,
                YieldAttachExtentsOptions: 32,
                YieldAttachExtentsIntoTableOptions: 33,
                YieldDropExtentTagsOptions: 34,
                YieldMoveExtentsOptions: 35,
                YieldMoveSpecifiedExtentsOptions: 36,
                YieldMoveExtentsToTableOptions: 37,
                YieldReplaceCommandOptions: 38,
                YieldReplaceExtentsOptions: 39,
                YieldShowExtentsOptions: 40,
                YieldShowExtentsByEntityOptions: 41,
                YieldShowExtentsByEntityWithTagsFiltersOptions: 42,
                YieldSetCommandOptions: 43,
                YieldSetOrAppendCommandOptions: 44,
                YieldAddCommandOptions: 45,
                YieldAttachCommandOptions: 46,
                YieldDropCommandOptions: 47,
                YieldMoveCommandOptions: 48,
                YieldPoliciesOptions: 49,
                YieldClusterPoliciesOptions: 50,
                YieldDatabasePoliciesOptions: 51,
                YieldTablePoliciesOptions: 52,
                YieldColumnPoliciesOptions: 53,
                YieldAlterCommandOptions: 54,
                YieldAlterMergeCommandOptions: 55,
                YieldDeleteCommandOptions: 56,
                YieldCreateCommandOptions: 57,
                YieldMultiplePoliciesOptions: 58,
                YieldDatabaseCreatePersistencyOptions: 59,
                YieldCreateIfNotExistsOptions: 60,
                YieldAdminCommandsOptions: 61,
                YieldExportCommandOptions: 62,
                YieldExportCommandWithModifiersAndOptions: 63,
                YieldExportCommandNoModifiersAndOptions: 64,
                YieldAlterDatabaseCommandOptions: 65,
                YieldDeleteMultiplePoliciesOptions: 66,
                YieldIngestionDuplicationOptions: 67,
                YieldPurgeOptions: 68,
                YieldPurgeCleanupOptions: 69,
                YieldPurgeWhatIfOptions: 70,
                YieldPurgeWithPropertiesOptions: 71,
                YieldPurgeTableOptions: 72,
                YieldShowPrincipalCommandOptions: 73,
                YieldAlterFunctionEntitiesOptions: 74,
                YieldAlterMergePolicyRetentionOptions: 75,
                YieldAlterMergePolicyRetentionSoftDeleteDefinedOptions: 76,
                YieldAlterTimeSpanPolicyOptions: 77,
                YieldCreateOrAlterOptions: 78,
                YieldShowFabricOptions: 79,
                YieldRowStoreCreatePersistencyOptions: 80,
                YieldSetDatabaseIngestorsNoneOptions: 81,
                YieldSetTableIngestorsNoneOptions: 82
            },
            ctors: {
                init: function () {
                    this.None = Kusto.Data.IntelliSense.RuleKind.None;
                    this.Start = Kusto.Data.IntelliSense.RuleKind.Last;
                }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.AnalyzedCommand", {
        fields: {
            Command: null,
            Context: null
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ApplyPolicy", {
        statics: {
            fields: {
                NullApplyPolicy: null,
                AppendSpacePolicy: null,
                AppendPipePolicy: null,
                AppendStringLiteralArrayPolicy: null,
                StringComparisonPolicy: null,
                AppendCommaPolicy: null,
                AppendDoubleCommaPolicy: null,
                AppendSpaceStepBackPolicy: null,
                AppendSpaceAfterBracketPolicy: null,
                MoveAfterTheBracketPolicy: null,
                AppendAssignmentPolicy: null,
                AppendJoinClauseWithOpenningBracketPolicy: null,
                AppendJoinClauseWithoutOpenningBracketPolicy: null,
                AppendFindInClausePolicy: null,
                AppendSearchInClausePolicy: null,
                AppendFindInClauseWithoutOpenningBracketPolicy: null
            },
            ctors: {
                init: function () {
                    var $t;
                    this.NullApplyPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "", $t);
                    this.AppendSpacePolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " ", $t);
                    this.AppendPipePolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " | ", $t);
                    this.AppendStringLiteralArrayPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (\"\", \"\")", $t.OffsetPosition = 2, $t.OffsetToken = "(", $t);
                    this.StringComparisonPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " \"\" ", $t.OffsetPosition = -2, $t);
                    this.AppendCommaPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = ", ", $t.OffsetPosition = 0, $t);
                    this.AppendDoubleCommaPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = ", , ", $t.OffsetPosition = -2, $t);
                    this.AppendSpaceStepBackPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " ", $t.OffsetPosition = -2, $t);
                    this.AppendSpaceAfterBracketPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " ", $t.OffsetToken = "(", $t.OffsetPosition = 1, $t);
                    this.MoveAfterTheBracketPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "", $t.OffsetToken = ")", $t.OffsetPosition = 1, $t);
                    this.AppendAssignmentPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " = ", $t);
                    this.AppendJoinClauseWithOpenningBracketPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.OffsetPosition = -13, $t.Text = " (\r\n    \r\n) on Key1 ", $t);
                    this.AppendJoinClauseWithoutOpenningBracketPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.OffsetPosition = -13, $t.Text = "\r\n    \r\n) on Key1 ", $t);
                    this.AppendFindInClausePolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.OffsetPosition = -8, $t.Text = " () where ", $t);
                    this.AppendSearchInClausePolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.OffsetPosition = -2, $t.Text = " () ", $t);
                    this.AppendFindInClauseWithoutOpenningBracketPolicy = ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.OffsetPosition = -8, $t.Text = ") where ", $t);
                }
            }
        },
        props: {
            Text: null,
            OffsetPosition: 0,
            OffsetToken: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase", {
        statics: {
            fields: {
                CommonRegexOptions: 0,
                DefaultRegexOptions: 0,
                s_isCommandRegex: null,
                s_firstWordAfterPipeRegex: null
            },
            ctors: {
                init: function () {
                    this.CommonRegexOptions = 16;
                    this.DefaultRegexOptions = 0;
                    this.s_isCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_firstWordAfterPipeRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*(?<FirstWord>[\\w\\-]+)\\s+", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                }
            },
            methods: {
                FindRules: function (rules, command, commandContext, lastPart, keywordFromCommand) {
                    var $t;
                    $t = Bridge.getEnumerator(rules);
                    try {
                        while ($t.moveNext()) {
                            var r = $t.Current;
                            if (r.RequiredKeywords != null && r.RequiredKeywords.Count > 0) {
                                var hasKeywordMatch = false;
                                if (r.RequiresFullCommand) {
                                    // Check if command has one of the required keywords
                                    hasKeywordMatch = System.Linq.Enumerable.from(r.RequiredKeywords).any(function (keyword) {
                                            return System.String.contains(command,keyword);
                                        });
                                } else {
                                    hasKeywordMatch = (!System.String.isNullOrEmpty(keywordFromCommand) && r.RequiredKeywords.contains(keywordFromCommand));
                                }

                                if (!hasKeywordMatch) {
                                    continue;
                                }
                            }
                            if (r.IsMatch(commandContext, (r.RequiresFullCommand) ? command : lastPart)) {
                                return r;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                FindLastStatement: function (statements) {
                    if (System.String.isNullOrEmpty(statements)) {
                        return "";
                    }

                    return System.Linq.Enumerable.from(Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ParseAsStatements(statements, 59, false)).lastOrDefault(null, null);
                },
                ParseAsStatements: function (input, delimeter, trimDelimeter) {
                    var result = new (System.Collections.Generic.List$1(System.String)).ctor();

                    if (System.String.isNullOrEmpty(input)) {
                        return result;
                    }

                    var currentStatementStart = 0;
                    var chars = System.String.toCharArray(input, 0, input.length);
                    for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];

                        if (!!(ch === 34 | ch === 39)) {
                            i = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.SkipToBalancedChar(chars, ((i + 1) | 0), ch, System.Array.init([34, 39], System.Char));
                        }

                        var eofString = (i === ((chars.length - 1) | 0));
                        if (ch === delimeter || eofString) {
                            var len = (((i - currentStatementStart) | 0) + 1) | 0;
                            // Remove delimeter if was requested
                            if (trimDelimeter && ch === delimeter) {
                                len = (len - 1) | 0;
                            }

                            if (len > 0) {
                                result.add(input.substr(currentStatementStart, len));
                            }
                            currentStatementStart = (i + 1) | 0;
                        }
                    }

                    return result;
                },
                SkipToBalancedChar: function (chars, start, balancedChar, recursionChars) {
                    for (var i = start; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];
                        if (ch === balancedChar) {
                            // Found char that we've searched for
                            return i;
                        }

                        if (System.Array.contains(recursionChars, ch, System.Char)) {
                            i = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.SkipToBalancedChar(chars, ((i + 1) | 0), ch, recursionChars);
                        }
                    }

                    // if we got so far - the balanced char was not found
                    return ((chars.length - 1) | 0);
                },
                GetApproximateCommandLastPart: function (command, lastPart, firstWordAfterPipe) {
                    var parts = System.String.split(command, [124].map(function (i) {{ return String.fromCharCode(i); }}));
                    var last = System.Linq.Enumerable.from(parts).lastOrDefault(null, null);
                    lastPart.v = last;
                    if (parts.length > 1) {
                        lastPart.v = "|" + (last || "");
                    }

                    if (System.String.isNullOrEmpty(last)) {
                        firstWordAfterPipe.v = "";
                        return;
                    }

                    firstWordAfterPipe.v = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.GetFirstWordAfterPipe(last);
                },
                GetFirstWordAfterPipe: function (input) {
                    var match = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.s_firstWordAfterPipeRegex.match(input);
                    return match.getGroups().getByName("FirstWord").toString();
                }
            }
        },
        props: {
            Locker: null,
            GeneralRules: null,
            CommandRules: null,
            QueryParametersRules: null,
            DefaultRule: null,
            CommandToolTips: null,
            ContextConnection: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Locker = { };
            }
        },
        methods: {
            /**
             * Attempts to match any rule for input string
             *
             * @instance
             * @public
             * @this Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase
             * @memberof Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase
             * @param   {string}                                      command    
             * @param   {Kusto.Data.IntelliSense.IntelliSenseRule}    rule
             * @return  {boolean}
             */
            TryMatchAnyRule: function (command, rule) {
                var $t, $t1;
                var analyzedCommand = this.AnalyzeCommand$1(command, null);
                var commandContext = analyzedCommand.Context;
                var firstWordAfterPipe = { }, lastPart = { };
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.GetApproximateCommandLastPart(analyzedCommand.Command, lastPart, firstWordAfterPipe);
                var isCommand = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.s_isCommandRegex.isMatch(command);

                rule.v = null;
                if (isCommand) {
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: start matching rules for commands rules");
                    $t = Bridge.getEnumerator(this.CommandRules);
                    try {
                        while ($t.moveNext()) {
                            var r = $t.Current;
                            if (r.IsMatch(commandContext, (r.RequiresFullCommand) ? command : lastPart.v)) {
                                rule.v = r;
                                break;
                            }
                            //PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: rule {0} didn't match for any of commands rules", r.Kind);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                if (rule.v == null) {
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: start matching rules for general rules");
                    rule.v = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.FindRules(this.GeneralRules, command, commandContext, lastPart.v, firstWordAfterPipe.v);
                }

                if (rule.v == null) {
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: start matching rules for query parameters rules");
                    $t1 = Bridge.getEnumerator(this.QueryParametersRules);
                    try {
                        while ($t1.moveNext()) {
                            var r1 = $t1.Current;
                            if (r1.IsMatch(commandContext, (r1.RequiresFullCommand) ? command : lastPart.v)) {
                                rule.v = r1;
                                break;
                            }
                            //PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: rule {0} didn't match for any of query parameters rules", r.Kind);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }}

                if (rule.v != null && rule.v.IsContextual) {
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: rule {0} was found", [Bridge.box(rule.v.Kind, System.Int32)]);
                    // Update selection options per command context
                    this.UpdateProviderAvailableEntities(command, commandContext);
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: Entities were updated", [Bridge.box(rule.v.Kind, System.Int32)]);
                } else {
                    Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer.Tracer.TraceVerbose("TryMatchAnyRule: no rule was found");
                }
                return (rule.v != null);
            },
            TryMatchSpecificRule: function (command, commandContext, ruleKind, rule) {
                rule.v = null;
                var isCommand = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.s_isCommandRegex.isMatch(command);

                // If it is a command - try to match any command rules
                if (isCommand) {
                    rule.v = System.Linq.Enumerable.from(this.CommandRules).firstOrDefault(function (r) {
                            return r.Kind === ruleKind && r.IsMatch(commandContext, command);
                        }, null);
                }

                // If nothing found (or not command) - go for the rest of rules
                if (rule.v == null) {
                    rule.v = System.Linq.Enumerable.from(this.GeneralRules).firstOrDefault(function (r) {
                            return r.Kind === ruleKind && r.IsMatch(commandContext, command);
                        }, null);
                }

                if (rule.v != null && rule.v.IsContextual) {
                    // Update selection options per command context
                    this.UpdateProviderAvailableEntities(command, commandContext);
                }
                return (rule.v != null);
            },
            SetQueryParametersRule: function (queryParameters) { },
            Initialize: function () {
                this.CommandRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.GeneralRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.CommandToolTips = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTip)).ctor();
                this.QueryParametersRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CMRuleKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Start: 0,
                YieldAdminCommandsOptions: 0,
                YieldPipeOptions: 1,
                YieldOperatorsAfterPipe: 2,
                YieldShowCommandOptions: 3,
                YieldShowAccountCommandOptions: 4,
                YieldShowAccountsKeywordOptions: 5,
                YieldMoveAccountCommandOptions: 6,
                YieldMoveAccountSubscriptionCommandOptions: 7,
                YieldMoveCommandOptions: 8,
                YieldAlterCommandOptions: 9,
                YieldAddCommandOptions: 10,
                YieldDropCommandOptions: 11,
                YieldRemoveCommandOptions: 12,
                YieldCreateCommandOptions: 13,
                YieldDeleteCommandOptions: 14,
                YieldDetachCommandOptions: 15,
                YieldCheckCommandOptions: 16,
                YieldSetCommandOptions: 17,
                YieldServiceKeywordOptions: 18,
                YieldServiceOrClusterKeywordOptions: 19,
                YieldStorageAccountsKeywordOptions: 20,
                YieldStorageLogsIntoKeywordsOptions: 21,
                YieldInServiceKeywordOptions: 22,
                YieldPrincipalsKeywordOptions: 23,
                YieldOperationsKeywordOptions: 24,
                YieldPcCodeKeywordOptions: 25,
                YieldFromServiceKeywordOptions: 26,
                YieldFromAccountKeywordOptions: 27,
                YieldShowAuditLogCommandOptions: 28,
                YieldShowAuditLogFromCommandOptions: 29,
                YieldShowPurgesCommandOptions: 30,
                YieldShowPurgesFromCommandOptions: 31,
                YieldConfigurationKeywordOptions: 32,
                YieldConfigurationPropertySetKeywordOptions: 33,
                YieldConfigurationPropertyDropKeywordOptions: 34,
                YieldToKeywordOptions: 35,
                YieldConfigurationPropertyWithConsentKeywordOptions: 36,
                YieldAccountAlterOperationsKeywordOptions: 37,
                YieldAccountAddOperationsKeywordOptions: 38,
                YieldAccountRemoveOperationsKeywordOptions: 39,
                YieldAccountSetOperationsKeywordOptions: 40,
                YieldAccountRenameOperationsKeywordOptions: 41,
                YieldServiceAlterOperationsKeywordOptions: 42,
                YieldDatabaseKeywordOptions: 43,
                YieldMetadataKeywordOptions: 44,
                YieldAccountNames: 45,
                YieldDmServiceAddKeywordOptions: 46,
                YieldDmServiceDropKeywordOptions: 47,
                YieldDmServiceAlterKeywordOptions: 48,
                YieldServicesNames: 49,
                YieldServicesNamesCombinedWithOptions: 50,
                YieldTargetServiceOptions: 51,
                YieldWithPropertiesSuffix: 52,
                YieldWithEventHubPropertiesSuffix: 53,
                YieldInstallCommandOptions: 54,
                YieldReinstallCommandOptions: 55,
                YieldUninstallCommandOptions: 56,
                YieldMigrateServiceCommandOptions: 57,
                YieldDatabaseMoveCommandOptions: 58,
                YieldDatabaseMoveFromServiceCommandOptions: 59,
                YieldSetClusterPrincipalsCommandOptions: 60,
                YieldAddClusterPrincipalsCommandOptions: 61,
                YieldDropClusterPrincipalsCommandOptions: 62,
                YieldSetClusterPrincipalsNoneOptions: 63,
                YieldDropAccountPrincipalsCommandOptions: 64,
                YieldDatabaseCreateCommandOptions: 65,
                YieldServiceAndClusterCreateCommandOptions: 66,
                YieldShowPrincipalRolesCommandOptions: 67,
                YieldAddKeywordOptions: 68,
                YieldAlterServiceConfigurationPropertiesOptions: 69,
                YieldAlterServiceConfigurationCommandOptions: 70,
                YieldTableKeywordOptions: 71,
                YieldRecordsKeywordOptions: 72,
                YieldRetryCommandOptions: 73,
                YieldRetryPurgeCommandOptions: 74,
                YieldRetryPurgeOperationsInServiceCommandOptions: 75,
                YieldRetryPurgeOperationsInServiceServiceNameCommandOptions: 76,
                YieldRetryPurgeOperationsInServiceServiceNameFromCommandOptions: 77,
                YieldInKeywordOptions: 78,
                YieldFromKeywordOptions: 79,
                YieldAddServiceServiceNameOptions: 80,
                YieldLoadBalancerKeywordOptions: 81,
                YieldOperationKeywordOptions: 82
            },
            ctors: {
                init: function () {
                    this.None = Kusto.Data.IntelliSense.RuleKind.None;
                    this.Start = Kusto.Data.IntelliSense.RuleKind.Last;
                }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CompletionOption", {
        props: {
            Kind: 0,
            Value: null
        },
        ctors: {
            ctor: function (kind, value) {
                this.$initialize();
                this.Kind = kind;
                this.Value = value;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CompletionOptionCollection", {
        fields: {
            m_materializedOptions: null
        },
        props: {
            Kind: 0,
            Values: null,
            Priority: 0
        },
        ctors: {
            ctor: function (kind, values, priority) {
                if (priority === void 0) { priority = 0; }

                this.$initialize();
                this.Kind = kind;
                this.Values = values;
                this.Priority = priority;
            }
        },
        methods: {
            GetCompletionOptions: function () {
                if (this.m_materializedOptions == null) {
                    this.m_materializedOptions = System.Linq.Enumerable.from(this.Values).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CompletionOptionCollection.f1)).ToArray(Kusto.Data.IntelliSense.CompletionOption);
                }

                return this.m_materializedOptions;
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CompletionOptionCollection", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CompletionOptionCollection, {
        f1: function (o) {
            return new Kusto.Data.IntelliSense.CompletionOption(this.Kind, o);
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ContextOperation", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Union: 1,
                Intersect: 2
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.IntelliSenseRule", {
        props: {
            Kind: 0,
            RequiredKeywords: null,
            AfterApplyPolicies: null,
            BeforeApplyPolicies: null,
            DefaultAfterApplyPolicy: null,
            DefaultBeforeApplyPolicy: null
        },
        methods: {
            GetAfterApplyInfo: function (selectedOption) {
                var policy = { v : null };
                if (this.AfterApplyPolicies != null) {
                    this.AfterApplyPolicies.tryGetValue(selectedOption, policy);
                }
                return policy.v || this.DefaultAfterApplyPolicy || Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy;
            },
            GetBeforeApplyInfo: function (selectedOption) {
                var policy = { v : null };
                if (this.BeforeApplyPolicies != null) {
                    this.BeforeApplyPolicies.tryGetValue(selectedOption, policy);
                }
                return policy.v || this.DefaultBeforeApplyPolicy || Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommand", {
        statics: {
            fields: {
                s_newLineRegex: null,
                c_tabulation: null,
                s_removeWhiteSpacesAfterPipeRegex: null,
                s_joinStartRegex: null,
                s_joinEndRegex: null,
                s_makeSeriesOperatorRegex: null,
                s_operatorRegex: null,
                s_operatorsNotRequiringFullEntitiesResolve: null,
                s_nameOrListRegex: null,
                s_hasAssignmentOperationRegex: null,
                s_startsWithAlpha: null
            },
            ctors: {
                init: function () {
                    this.s_newLineRegex = new System.Text.RegularExpressions.Regex.ctor("[\\n\\r]", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.c_tabulation = "    ";
                    this.s_removeWhiteSpacesAfterPipeRegex = new System.Text.RegularExpressions.Regex.ctor("^\\|\\s+", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_joinStartRegex = new System.Text.RegularExpressions.Regex.ctor("(?<JoinOpPart>^\\s*\\|\\s*join\\s+(kind\\s*=\\s*\\w+\\s*)?)(?<Bracket>\\()?(?<PostJoinPart>.+$)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_joinEndRegex = new System.Text.RegularExpressions.Regex.ctor("(?!^.*\\bmake-series\\b.*$)((?<InnerJoinPart>^.*?)(?<Bracket>\\)?)\\s*\\b(?<JoinOnPart>on\\s+.+))", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesOperatorRegex = new System.Text.RegularExpressions.Regex.ctor("\\bmake-series\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_operatorRegex = new System.Text.RegularExpressions.Regex.ctor("\\|\\s*(?<Operator>[\\w-]+)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_operatorsNotRequiringFullEntitiesResolve = $asm.$.Kusto.Data.IntelliSense.CslCommand.f1(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_nameOrListRegex = "(?:\\w+)|(?:\\((\\w+)(,\\s*\\w+)*\\))";
                    this.s_hasAssignmentOperationRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*\\|\\s*(extend|parse|summarize|project|mvexpand|make-series|project-rename)\\s+" + (Kusto.Data.IntelliSense.CslCommand.s_nameOrListRegex || "") + ")|(^\\s*range)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_startsWithAlpha = new System.Text.RegularExpressions.Regex.ctor("^\\s*[a-z]", 1);
                }
            },
            methods: {
                UnionCommands: function (commands) {
                    var $t;
                    if (System.Linq.Enumerable.from(commands).count() < 2) {
                        return System.Linq.Enumerable.from(commands).firstOrDefault(null, null);
                    }

                    var firstCommand = System.Linq.Enumerable.from(commands).first();
                    // count is 2 or more
                    var result = ($t = new Kusto.Data.IntelliSense.CslCommand(), $t.m_tokens = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f2).toList(Kusto.Data.IntelliSense.CslCommandToken), $t.m_commandParts = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f3).toList(Kusto.Data.IntelliSense.CslCommandToken), $t.m_commentsParts = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f4).toList(Kusto.Data.IntelliSense.CslCommandToken), $t.m_clientDirectivesParts = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f5).toList(Kusto.Data.IntelliSense.CslCommandToken), $t.m_bracketParts = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f6).toList(Kusto.Data.IntelliSense.CslCommandToken), $t.Text = Bridge.toArray(System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommand.f7)).join(""), $t.IsRunnable = System.Linq.Enumerable.from(commands).any($asm.$.Kusto.Data.IntelliSense.CslCommand.f8), $t.RelativeStart = firstCommand.RelativeStart, $t.AbsolutePositionBias = firstCommand.AbsolutePositionBias, $t.ParseMode = firstCommand.ParseMode, $t);
                    result.Length = result.Text.length;

                    return result;
                },
                NormalizeCommandPart: function (partValue) {
                    partValue = partValue.trim();
                    partValue = Kusto.Data.IntelliSense.CslCommand.s_removeWhiteSpacesAfterPipeRegex.replace(partValue, "| ");
                    return partValue;
                },
                AppendTabulatedText: function (sb, level, text) {
                    Kusto.Data.IntelliSense.CslCommand.AppendTabulations(sb, level);
                    sb.append(text);
                },
                AppendTabulations: function (sb, level) {
                    if (level <= 0) {
                        return;
                    }

                    for (var j = 0; j < level; j = (j + 1) | 0) {
                        sb.append(Kusto.Data.IntelliSense.CslCommand.c_tabulation);
                    }
                },
                ResolveOperatorContext: function (part) {
                    if (part == null) {
                        return "";
                    }

                    if (System.String.indexOf(part.Text, " on ") > 0 && !Kusto.Data.IntelliSense.CslCommand.s_makeSeriesOperatorRegex.isMatch(part.Text)) {
                        return "";
                    }

                    return Kusto.Data.IntelliSense.CslCommand.s_operatorRegex.match(part.Text).getGroups().getByName("Operator").toString();
                },
                GetKnownEntities: function (rulesProvider, mapOfKnownEntities, mapOfOriginallyKnownEntities, part, commandBuilder, context, operatorContext, knownEntities, originallyKnownEntities) {
                    knownEntities.v = new (System.Collections.Generic.List$1(System.String)).ctor();

                    if (mapOfOriginallyKnownEntities.containsKey(context)) {
                        originallyKnownEntities.v = mapOfOriginallyKnownEntities.get(context);
                    } else {
                        originallyKnownEntities.v = new (System.Collections.Generic.List$1(System.String)).ctor();
                    }

                    if (part == null) {
                        if (mapOfKnownEntities.containsKey(context)) {
                            knownEntities.v = mapOfKnownEntities.get(context);
                        }
                        return false;
                    }

                    // Check if entities can be pulled from the tables
                    if (Kusto.Data.IntelliSense.CslCommand.s_operatorsNotRequiringFullEntitiesResolve.contains(operatorContext)) {
                        if (mapOfKnownEntities.containsKey(context)) {
                            knownEntities.v = mapOfKnownEntities.get(context);
                        }
                        return false;
                    }

                    var command = commandBuilder.toString();
                    return rulesProvider.GetKnownEntities(command, context, mapOfOriginallyKnownEntities, knownEntities, originallyKnownEntities);
                },
                IsMatchingRegex: function (commandPart, opRegex) {
                    if (System.String.isNullOrWhiteSpace(commandPart)) {
                        return false;
                    }
                    return opRegex.isMatch(commandPart);
                },
                StartsWithAlpha: function (text) {
                    if (System.String.isNullOrWhiteSpace(text)) {
                        return false;
                    }
                    return Kusto.Data.IntelliSense.CslCommand.s_startsWithAlpha.isMatch(text);
                }
            }
        },
        fields: {
            m_tokens: null,
            m_commandParts: null,
            m_commentsParts: null,
            m_clientDirectivesParts: null,
            m_bracketParts: null,
            /**
             * The next list holds parse states for each of the command parts
             This allows reusing the state when the command is slowly mutating
             as happens when user changes last command part
             *
             * @instance
             * @private
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @type System.Collections.Generic.List$1
             */
            m_commandPartsParseStates: null
        },
        props: {
            CslExpressionStartPosition: {
                get: function () {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commandParts)) {
                        return 0;
                    }

                    return this.m_commandParts.getItem(0).RelativeStart;
                }
            },
            CslExpressionLength: {
                get: function () {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commandParts)) {
                        return 0;
                    }

                    return ((System.Linq.Enumerable.from(this.m_commandParts).last().RelativeEnd - this.m_commandParts.getItem(0).RelativeStart) | 0);
                }
            },
            Tokens: {
                get: function () {
                    return this.m_tokens;
                }
            },
            CommandParts: {
                get: function () {
                    return this.m_commandParts;
                }
            },
            CommentParts: {
                get: function () {
                    return this.m_commentsParts;
                }
            },
            BracketParts: {
                get: function () {
                    return this.m_bracketParts;
                }
            },
            AllParts: {
                get: function () {
                    var linqParts = 0;
                    var result = null;
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commandParts)) {
                        linqParts = (linqParts + 1) | 0;
                        result = this.m_commandParts;
                    }

                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commentsParts)) {
                        linqParts = (linqParts + 1) | 0;
                        result = ((result != null) ? System.Linq.Enumerable.from(result).union(this.m_commentsParts) : Bridge.cast(this.m_commentsParts, System.Collections.Generic.IEnumerable$1(Kusto.Data.IntelliSense.CslCommandToken)));
                    }

                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_clientDirectivesParts)) {
                        linqParts = (linqParts + 1) | 0;
                        result = ((result != null) ? System.Linq.Enumerable.from(result).union(this.m_clientDirectivesParts) : Bridge.cast(this.m_clientDirectivesParts, System.Collections.Generic.IEnumerable$1(Kusto.Data.IntelliSense.CslCommandToken)));
                    }

                    if (linqParts > 1) {
                        return System.Linq.Enumerable.from(result).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommand.f9);
                    }

                    return result;
                }
            },
            Text: null,
            RelativeStart: 0,
            Length: 0,
            RelativeEnd: {
                get: function () {
                    return ((((this.RelativeStart + this.Length) | 0) - 1) | 0);
                }
            },
            AbsoluteStart: {
                get: function () {
                    return ((this.AbsolutePositionBias + this.RelativeStart) | 0);
                }
            },
            AbsoluteEnd: {
                get: function () {
                    return ((this.AbsolutePositionBias + this.RelativeEnd) | 0);
                }
            },
            AbsolutePositionBias: 0,
            IsRunnable: false,
            ParseMode: 0,
            /**
             * Optimization: keep on the command its context cache (mapping between different command parts to the command context)
             *
             * @instance
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @function ContextCache
             * @type System.Collections.Generic.Dictionary$2
             */
            ContextCache: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
            }
        },
        methods: {
            FormatAsString: function (separator, traits) {
                var $t;
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commandParts)) {
                    return "";
                }

                var parts = this.m_commandParts;
                if (System.Enum.hasFlag(traits, Bridge.box(Kusto.Data.IntelliSense.CslCommand.FormatTraits.IncludeComments, Kusto.Data.IntelliSense.CslCommand.FormatTraits, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommand.FormatTraits))) && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_commentsParts)) {
                    parts = System.Linq.Enumerable.from(parts).union(this.m_commentsParts).union(this.m_clientDirectivesParts).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommand.f10).toList(Kusto.Data.IntelliSense.CslCommandToken);
                }

                var sb = new System.Text.StringBuilder();
                var level = { v : 0 };
                var isFirstTime = true;
                $t = Bridge.getEnumerator(parts);
                try {
                    while ($t.moveNext()) {
                        var part = $t.Current;
                        var partValue = Kusto.Data.IntelliSense.CslCommand.s_newLineRegex.replace(part.Value, " ");

                        if (!isFirstTime) {
                            sb.append(separator);
                        }
                        isFirstTime = false;
                        // Append tabulations
                        Kusto.Data.IntelliSense.CslCommand.AppendTabulations(sb, level.v);

                        var wasHandled = false;
                        if (!wasHandled && System.Enum.hasFlag(traits, Bridge.box(Kusto.Data.IntelliSense.CslCommand.FormatTraits.IncludeComments, Kusto.Data.IntelliSense.CslCommand.FormatTraits, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommand.FormatTraits)))) {
                            wasHandled = this.HandleCommentsAndClientDirectives(separator, sb, level, part, partValue);
                        }

                        if (!wasHandled && System.Enum.hasFlag(traits, Bridge.box(Kusto.Data.IntelliSense.CslCommand.FormatTraits.TabulateOnFunctionBoundaries, Kusto.Data.IntelliSense.CslCommand.FormatTraits, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommand.FormatTraits)))) {
                            wasHandled = this.HandleFunctions(separator, sb, level, part);
                        }

                        if (!wasHandled && System.Enum.hasFlag(traits, Bridge.box(Kusto.Data.IntelliSense.CslCommand.FormatTraits.TabulateOnJoins, Kusto.Data.IntelliSense.CslCommand.FormatTraits, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommand.FormatTraits)))) {
                            wasHandled = this.HandleJoins(separator, sb, level, part, partValue);
                        }

                        if (!wasHandled) {
                            sb.append(Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(partValue));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return sb.toString();
            },
            HandleCommentsAndClientDirectives: function (separator, sb, level, part, partValue) {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.None$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, System.Linq.Enumerable.from(this.m_commentsParts).union(this.m_clientDirectivesParts), function (cp) {
                    return cp.AbsoluteStart === part.AbsoluteStart && cp.AbsoluteEnd === part.AbsoluteEnd;
                })) {
                    return false;
                }

                sb.append(partValue.trim());
                return true;
            },
            HandleFunctions: function (separator, sb, level, part) {
                var wasHandled = false;
                var processedStart = 0;
                var startRelativeIndex = System.String.indexOf(part.Value, String.fromCharCode(123));
                var startAbsoluteIndex = (part.AbsoluteStart + startRelativeIndex) | 0;

                if (startRelativeIndex >= 0 && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.None$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_tokens, function (t) {
                    return startAbsoluteIndex >= t.AbsoluteStart && startAbsoluteIndex <= t.AbsoluteEnd;
                })) {
                    var funcPrefix = part.Value.substr(0, startRelativeIndex).trim();
                    funcPrefix = Kusto.Data.IntelliSense.CslCommand.s_newLineRegex.replace(funcPrefix, " ");
                    sb.append(funcPrefix);
                    sb.append(separator);
                    sb.append("{");
                    sb.append(separator);
                    level.v = (level.v + 1) | 0;
                    wasHandled = true;
                    processedStart = (startRelativeIndex + 1) | 0;
                }

                var endRelativeIndex = System.String.indexOf(part.Value, String.fromCharCode(125));
                var endAbsoluteIndex = (part.AbsoluteStart + endRelativeIndex) | 0;
                if (endRelativeIndex >= 0 && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.None$1(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, this.m_tokens, function (t) {
                    return endAbsoluteIndex >= t.AbsoluteStart && endAbsoluteIndex <= t.AbsoluteEnd;
                })) {
                    var boddy = part.Value.substr(processedStart, ((endRelativeIndex - processedStart) | 0)).trim();
                    var funcSuffix = part.Value.substr(((endRelativeIndex + 1) | 0)).trim();
                    funcSuffix = Kusto.Data.IntelliSense.CslCommand.s_newLineRegex.replace(funcSuffix, " ");
                    if (wasHandled) {
                        Kusto.Data.IntelliSense.CslCommand.AppendTabulations(sb, level.v);
                    }
                    sb.append(boddy);
                    sb.append(separator);
                    sb.append("}");
                    level.v = (level.v - 1) | 0;
                    if (level.v < 0) {
                        level.v = 0;
                    }
                    Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, funcSuffix);
                    wasHandled = true;
                } else if (wasHandled) {
                    // This is a case where function was started in this cycle, and start of the function has to be tabulated
                    var boddy1 = part.Value.substr(processedStart).trim();
                    boddy1 = Kusto.Data.IntelliSense.CslCommand.s_newLineRegex.replace(boddy1, " ");
                    Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, boddy1);
                }

                return wasHandled;
            },
            HandleJoins: function (separator, sb, level, part, partValue) {
                var assumeJoinStartedWithBracket = false;
                var wasHandled = false;
                var remainingText = partValue;
                var joinStartMatch = Kusto.Data.IntelliSense.CslCommand.s_joinStartRegex.match(remainingText);
                var relativePosition = 0;
                if (joinStartMatch.getSuccess()) {
                    var joinOpPart = joinStartMatch.getGroups().getByName("JoinOpPart").toString();
                    sb.append(Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(joinOpPart));
                    sb.append(separator);
                    assumeJoinStartedWithBracket = !System.String.isNullOrEmpty(joinStartMatch.getGroups().getByName("Bracket").toString());
                    level.v = (level.v + 1) | 0;
                    remainingText = joinStartMatch.getGroups().getByName("PostJoinPart").toString();
                    relativePosition = joinStartMatch.getGroups().getByName("PostJoinPart").getIndex();
                    wasHandled = true;
                }

                var joinEndMatch = Kusto.Data.IntelliSense.CslCommand.s_joinEndRegex.match(remainingText);
                if (joinEndMatch.getSuccess() && System.Linq.Enumerable.from(this.m_tokens).any(function (t) {
                        return t.TokenKind === Kusto.Data.IntelliSense.CslCommandToken.Kind.SubOperatorToken && Bridge.referenceEquals(t.Value, "on") && t.AbsoluteStart === ((((joinEndMatch.getGroups().getByName("JoinOnPart").getIndex() + part.AbsoluteStart) | 0) + relativePosition) | 0);
                    })) {
                    var joinInnerPart = Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(joinEndMatch.getGroups().getByName("InnerJoinPart").toString());
                    var onJoinPart = Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(joinEndMatch.getGroups().getByName("JoinOnPart").toString());

                    var hasBracket = !System.String.isNullOrEmpty(joinEndMatch.getGroups().getByName("Bracket").toString());
                    var shouldCloseBracket = hasBracket || assumeJoinStartedWithBracket;

                    var openBrackets = Kusto.Cloud.Platform.Utils.ExtendedString.CountNonOverlappingSubstrings$1(joinInnerPart, "(");
                    var closeBrackets = Kusto.Cloud.Platform.Utils.ExtendedString.CountNonOverlappingSubstrings$1(joinInnerPart, ")");
                    if (hasBracket) {
                        if (openBrackets > closeBrackets) {
                            shouldCloseBracket = false;
                            joinInnerPart = (joinInnerPart || "") + ")";
                        }
                    }

                    if (joinStartMatch.getSuccess()) {
                        if (assumeJoinStartedWithBracket) {
                            Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, ((level.v - 1) | 0), "(");
                            sb.append(separator);
                        }
                        Kusto.Data.IntelliSense.CslCommand.AppendTabulations(sb, level.v);
                    }

                    level.v = (level.v - 1) | 0;
                    if (level.v < 0) {
                        level.v = 0;
                    }
                    if (!System.String.isNullOrEmpty(joinInnerPart)) {
                        sb.append(joinInnerPart);
                        sb.append(separator);
                        if (shouldCloseBracket) {
                            Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, ")");
                            sb.append(separator);
                        }

                        Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(onJoinPart));
                    } else {
                        //if joinInnerPart is not available, trimming trailing tabulation
                        var tabLength = Kusto.Data.IntelliSense.CslCommand.c_tabulation.length;
                        sb.replace(Kusto.Data.IntelliSense.CslCommand.c_tabulation, "", ((sb.getLength() - tabLength) | 0), tabLength);
                        var bracketClosed = false;
                        if (shouldCloseBracket) {
                            sb.append(")");
                            sb.append(separator);
                            bracketClosed = true;
                        }

                        if (bracketClosed) {
                            Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(onJoinPart));
                        } else {
                            sb.append(onJoinPart);
                        }
                    }

                    wasHandled = true;
                } else if (joinStartMatch.getSuccess()) {
                    if (assumeJoinStartedWithBracket) {
                        Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, ((level.v - 1) | 0), "(");
                        sb.append(separator);
                    }
                    Kusto.Data.IntelliSense.CslCommand.AppendTabulatedText(sb, level.v, Kusto.Data.IntelliSense.CslCommand.NormalizeCommandPart(remainingText));
                }

                return wasHandled;
            },
            /**
             * Optimization: instead of re-parsing tokens, copy them from the already parsed command that has the same text
             *
             * @instance
             * @this Kusto.Data.IntelliSense.CslCommand
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @param   {Kusto.Data.IntelliSense.CslCommand}    other
             * @return  {void}
             */
            AcquireTokens: function (other) {
                this.m_tokens = System.Linq.Enumerable.from(other.m_tokens).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CslCommand.f11)).toList(Kusto.Data.IntelliSense.CslCommandToken);

                this.m_commandParts = System.Linq.Enumerable.from(other.m_commandParts).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CslCommand.f11)).toList(Kusto.Data.IntelliSense.CslCommandToken);

                this.m_commentsParts = System.Linq.Enumerable.from(other.m_commentsParts).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CslCommand.f11)).toList(Kusto.Data.IntelliSense.CslCommandToken);

                this.m_clientDirectivesParts = System.Linq.Enumerable.from(other.m_clientDirectivesParts).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CslCommand.f11)).toList(Kusto.Data.IntelliSense.CslCommandToken);

                this.m_bracketParts = System.Linq.Enumerable.from(other.m_bracketParts).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.CslCommand.f11)).toList(Kusto.Data.IntelliSense.CslCommandToken);
            },
            /**
             * Re-parse the command string
             *
             * @instance
             * @this Kusto.Data.IntelliSense.CslCommand
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @param   {Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider}    rulesProvider        
             * @param   {Kusto.Data.IntelliSense.ParseMode}                       parseMode            
             * @param   {Kusto.Data.IntelliSense.CslCommand}                      previousCandidate
             * @return  {void}
             */
            ParseTokens: function (rulesProvider, parseMode, previousCandidate) {
                var tokens = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                if (System.String.isNullOrEmpty(this.Text)) {
                    this.m_tokens = tokens;
                    return;
                }

                if (rulesProvider != null) {
                    rulesProvider.ResetState();
                    if (previousCandidate != null && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(System.Int32, Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, previousCandidate.ContextCache)) {
                        rulesProvider.ContextCache = new (System.Collections.Generic.Dictionary$2(System.Int32,Kusto.Data.IntelliSense.KustoCommandContext))(previousCandidate.ContextCache);
                    }
                }

                // Create a text indexer that takes care of breaking text into simple tokens and 
                // basic constructs (comments, string literals, rest)
                var allowQueryParameters = (rulesProvider != null) ? rulesProvider.AllowQueryParameters : false;
                var indexer = new Kusto.Data.IntelliSense.CslCommandIndexer(allowQueryParameters);
                indexer.AntiTokenizers = new (System.Collections.Generic.HashSet$1(System.Char)).$ctor1(System.Array.init([45, 95, 40], System.Char));
                indexer.TokenStarters = System.Array.init([46], System.Char);
                indexer.TokenTerminators = new (System.Collections.Generic.HashSet$1(System.Char)).$ctor1(System.Array.init([40, 46], System.Char));
                indexer.IndexText(this.Text);

                var recognizedTokens = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_commandParts = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                var commandParts = indexer.GetCommandPartsPositions();
                this.AddCategorizedTokens(this.m_commandParts, null, commandParts, Kusto.Data.IntelliSense.CslCommandToken.Kind.CommandPartToken);

                this.m_commentsParts = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                var commentsParts = indexer.GetCommentsPositions();
                this.AddCategorizedTokens(this.m_commentsParts, null, commentsParts, Kusto.Data.IntelliSense.CslCommandToken.Kind.CommentToken);

                this.m_clientDirectivesParts = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                var clientDirectivesPositions = indexer.GetClientDirectivesPositions();
                this.AddCategorizedTokens(this.m_clientDirectivesParts, null, clientDirectivesPositions, Kusto.Data.IntelliSense.CslCommandToken.Kind.ClientDirectiveToken);

                this.m_bracketParts = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                this.AddCategorizedTokens(this.m_bracketParts, null, indexer.GetBracketsPositions(), Kusto.Data.IntelliSense.CslCommandToken.Kind.BracketRangeToken);

                this.AddCategorizedTokens(tokens, recognizedTokens, commentsParts, Kusto.Data.IntelliSense.CslCommandToken.Kind.CommentToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, clientDirectivesPositions, Kusto.Data.IntelliSense.CslCommandToken.Kind.ClientDirectiveToken);
                if (allowQueryParameters) {
                    this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetQueryParametersPositions(), Kusto.Data.IntelliSense.CslCommandToken.Kind.QueryParametersToken);
                }
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetStringLiteralsPositions(), Kusto.Data.IntelliSense.CslCommandToken.Kind.StringLiteralToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.ControlCommandsTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.ControlCommandToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.CslCommandsTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.CslCommandToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.OperatorCommandTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.SubOperatorsTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.SubOperatorToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.JoinKindTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.SubOperatorToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.ReduceByKindTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.SubOperatorToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.DataTypesTokens), Kusto.Data.IntelliSense.CslCommandToken.Kind.DataTypeToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.FunctionsTokens, 40), Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken);
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(Kusto.Data.IntelliSense.CslCommandParser.PluginTokens, 40), Kusto.Data.IntelliSense.CslCommandToken.Kind.PluginToken);
                if (rulesProvider != null) {
                    this.AddEntitiesTokens(rulesProvider, tokens, recognizedTokens, indexer, commandParts, previousCandidate);
                }

                tokens.Sort$2($asm.$.Kusto.Data.IntelliSense.CslCommand.f12); // In-place sorting
                // Find tokens that are exceeding end or overlapping
                this.ValidateTokensOutput(tokens, this.Text);

                if (parseMode === Kusto.Data.IntelliSense.ParseMode.TokenizeAllText) {
                    this.EnsureAllTextIsAnnotated(indexer, tokens, recognizedTokens);
                    tokens.Sort$2($asm.$.Kusto.Data.IntelliSense.CslCommand.f12); // In-place sorting
                }

                this.m_tokens = tokens;

                // Capture command context cache from rules provider and store it on the command
                if (rulesProvider != null) {
                    this.ContextCache = rulesProvider.ContextCache;
                }
            },
            ValidateTokensOutput: function (tokens, text) {
                var $t;
                var invalidTokens = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandToken)).ctor();
                var currentEnd = 0;
                var maxLen = text.length;

                // Look for overlapping tokens or those that exceed text length
                for (var i = 0; i < System.Linq.Enumerable.from(tokens).count(); i = (i + 1) | 0) {
                    var t = tokens.getItem(i);
                    if (t.RelativeEnd < currentEnd || t.RelativeStart < currentEnd || t.RelativeEnd > maxLen) {
                        invalidTokens.add(t);
                    } else {
                        currentEnd = t.RelativeEnd;
                    }
                }

                $t = Bridge.getEnumerator(invalidTokens);
                try {
                    while ($t.moveNext()) {
                        var tokenToRemove = $t.Current;
                        tokens.remove(tokenToRemove);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            /**
             * Adds tokens that consist of tables, columns and calculated columns entities
             *
             * @instance
             * @private
             * @this Kusto.Data.IntelliSense.CslCommand
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @param   {Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider}    rulesProvider       
             * @param   {System.Collections.Generic.List$1}                       tokens              
             * @param   {System.Collections.Generic.List$1}                       recognizedTokens    
             * @param   {Kusto.Data.IntelliSense.CslCommandIndexer}               indexer             
             * @param   {System.Collections.Generic.IList$1}                      commandParts        
             * @param   {Kusto.Data.IntelliSense.CslCommand}                      refernceCommand
             * @return  {void}
             */
            AddEntitiesTokens: function (rulesProvider, tokens, recognizedTokens, indexer, commandParts, refernceCommand) {
                // Mark table names
                this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetAllTokenPositions(rulesProvider.TableNames), Kusto.Data.IntelliSense.CslCommandToken.Kind.TableToken);

                this.m_commandPartsParseStates = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommand.AddEntitiesTokensState)).ctor();

                // Now we have a list of tokens
                var commandBuilder = new System.Text.StringBuilder();

                var letVariables = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(rulesProvider.FunctionNames); // Consume all default functions

                var canUseReference = (refernceCommand != null);
                var state = null;
                var analyzedCommand = null;

                for (var i = 0; i < ((System.Array.getCount(commandParts, Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition) + 1) | 0); i = (i + 1) | 0) {
                    var prevPart = (i > 0) ? System.Array.getItem(commandParts, ((i - 1) | 0), Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition) : null;
                    var part = { v : (i < System.Array.getCount(commandParts, Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)) ? System.Array.getItem(commandParts, i, Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition) : null };
                    state = (state != null) ? state.Clone() : new Kusto.Data.IntelliSense.CslCommand.AddEntitiesTokensState();

                    if (part.v != null) {
                        commandBuilder.append(part.v.Text);
                    }

                    // check if reference part is equal to the current part
                    // It's pity that it is impossible to use object?.property notation
                    // since bridge.net does not support this
                    canUseReference = !!(canUseReference & ((part.v != null && refernceCommand != null && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.CslCommandToken, refernceCommand.CommandParts)) && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommand.AddEntitiesTokensState, refernceCommand.m_commandPartsParseStates) && System.Linq.Enumerable.from(refernceCommand.m_commandPartsParseStates).count() > i && System.Linq.Enumerable.from(refernceCommand.CommandParts).count() > i && System.String.equals(part.v.Text, System.Linq.Enumerable.from(refernceCommand.CommandParts).elementAt(i).Value)));

                    if (canUseReference) {
                        var referencePart = System.Linq.Enumerable.from(refernceCommand.CommandParts).elementAt(i);
                        var offset = { v : (part.v.Start - referencePart.RelativeStart) | 0 };
                        var capturedTokens = System.Linq.Enumerable.from(refernceCommand.Tokens).where((function ($me, part) {
                                return function (t) {
                                    return (t.TokenKind === Kusto.Data.IntelliSense.CslCommandToken.Kind.CalculatedColumnToken || t.TokenKind === Kusto.Data.IntelliSense.CslCommandToken.Kind.TableColumnToken || t.TokenKind === Kusto.Data.IntelliSense.CslCommandToken.Kind.TableToken || t.TokenKind === Kusto.Data.IntelliSense.CslCommandToken.Kind.LetVariablesToken) && (t.RelativeStart >= part.v.Start && t.RelativeEnd <= part.v.End);
                                };
                            })(this, part)).select((function ($me, offset) {
                            return function (t) {
                                // Shift by the offset relative to the old token command
                                var clonedToken = Bridge.as(t.clone(), Kusto.Data.IntelliSense.CslCommandToken);
                                clonedToken.RelativeStart = (clonedToken.RelativeStart + offset.v) | 0;
                                return clonedToken;
                            };
                        })(this, offset)).ToArray(Kusto.Data.IntelliSense.CslCommandToken);

                        tokens.AddRange(capturedTokens);
                        recognizedTokens.AddRange(indexer.GetTokenPositionsInRange(System.Linq.Enumerable.from(capturedTokens).select($asm.$.Kusto.Data.IntelliSense.CslCommand.f13), part.v.Start, part.v.End));

                        this.AddLetStatementTokens(tokens, recognizedTokens, indexer, letVariables, part.v);

                        state = refernceCommand.m_commandPartsParseStates.getItem(i).Clone();
                        this.m_commandPartsParseStates.add(state);
                        continue; // Move to next part
                    }

                    if (part.v != null) {
                        this.AddLetStatementTokens(tokens, recognizedTokens, indexer, letVariables, part.v);
                    }

                    if (analyzedCommand == null) {
                        var command = commandBuilder.toString();
                        analyzedCommand = rulesProvider.AnalyzeCommand$1(command, refernceCommand);
                    } else if (part.v != null) {
                        analyzedCommand = rulesProvider.AnalyzeCommand(analyzedCommand, part.v.Text);
                    }

                    var tableContext = analyzedCommand.Context;
                    if (tableContext.IsEmpty()) {
                        continue;
                    }

                    var operatorContext = Kusto.Data.IntelliSense.CslCommand.ResolveOperatorContext(part.v);

                    var knownEntities = { };
                    var originallyKnownEntities = { };
                    var wasFullyResolved = Kusto.Data.IntelliSense.CslCommand.GetKnownEntities(rulesProvider, state.MapOfKnownEntities, state.MapOfOriginallyKnownEntities, part.v, commandBuilder, tableContext, operatorContext, knownEntities, originallyKnownEntities);

                    if (part.v != null) {
                        // The next updates list of remote tables
                        rulesProvider.ResolveKnownEntitiesFromContext(tableContext);

                        var calculatedColumns = System.Linq.Enumerable.from(knownEntities.v).except(originallyKnownEntities.v);
                        var availableTableColumns = System.Linq.Enumerable.from(originallyKnownEntities.v).intersect(knownEntities.v);
                        this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetTokenPositionsInRange(availableTableColumns, part.v.Start, part.v.End), Kusto.Data.IntelliSense.CslCommandToken.Kind.TableColumnToken);
                        this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetTokenPositionsInRange(calculatedColumns, part.v.Start, part.v.End), Kusto.Data.IntelliSense.CslCommandToken.Kind.CalculatedColumnToken);
                        this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetTokenPositionsInRange(rulesProvider.RemoteTableNames, part.v.Start, part.v.End), Kusto.Data.IntelliSense.CslCommandToken.Kind.TableToken);
                    }


                    if (!wasFullyResolved && part.v != null) {
                        var newCalculatedColumns = new (System.Collections.Generic.List$1(System.String)).ctor();
                        var result = rulesProvider.ResolveEntitiesFromCommand((part.v.Text || "") + " | ", newCalculatedColumns, knownEntities.v);
                        switch (result) {
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities: 
                                knownEntities.v = newCalculatedColumns;
                                break;
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None: 
                                break;
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities: 
                                knownEntities.v = System.Linq.Enumerable.from(knownEntities.v).union(newCalculatedColumns).toList(System.String);
                                break;
                        }
                    }

                    state.MapOfKnownEntities.set(tableContext, knownEntities.v);

                    // If the operation has an assignment operation - handle it by having another iteration of the appended text
                    if (prevPart != null && Kusto.Data.IntelliSense.CslCommand.IsMatchingRegex(prevPart.Text, Kusto.Data.IntelliSense.CslCommand.s_hasAssignmentOperationRegex) && state.MapOfPreviousCalculatedEntities.containsKey(tableContext)) {
                        var prevCalculatedColumns = state.MapOfPreviousCalculatedEntities.get(tableContext);
                        if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(System.String, prevCalculatedColumns)) {
                            var calculatedColumnTokens = indexer.GetTokenPositionsInRange(prevCalculatedColumns, prevPart.Start, prevPart.End);
                            if (System.Linq.Enumerable.from(calculatedColumnTokens).any()) {
                                this.AddCategorizedTokens(tokens, recognizedTokens, calculatedColumnTokens, Kusto.Data.IntelliSense.CslCommandToken.Kind.CalculatedColumnToken);
                            }
                        }
                    }

                    state.MapOfPreviousCalculatedEntities.set(tableContext, System.Linq.Enumerable.from(knownEntities.v).except(originallyKnownEntities.v).toList(System.String));
                    this.m_commandPartsParseStates.add(state);

                }
            },
            AddLetStatementTokens: function (tokens, recognizedTokens, indexer, letVariables, part) {
                // Collect new let variables
                var letVariable = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveLetVariable(part.Text);
                if (!System.String.isNullOrEmpty(letVariable)) {
                    letVariables.add(letVariable);
                }
                if (letVariables.Count > 0) {
                    this.AddCategorizedTokens(tokens, recognizedTokens, indexer.GetTokenPositionsInRange(letVariables, part.Start, part.End), Kusto.Data.IntelliSense.CslCommandToken.Kind.LetVariablesToken);
                }
            },
            AddCategorizedTokens: function (target, recognizedTokenList, textTokens, tokenKind) {
                if (recognizedTokenList != null) {
                    recognizedTokenList.AddRange(textTokens);
                }
                target.AddRange(System.Linq.Enumerable.from(textTokens).select(Bridge.fn.bind(this, function (t) {
                        var $t;
                        return ($t = new Kusto.Data.IntelliSense.CslCommandToken(t.Text, this.RelativeStart, tokenKind), $t.Length = t.Length, $t.RelativeStart = t.Start, $t);
                    })));
            },
            /**
             * When requested - this function takes care that between all previous tokens that were
             recognized - we will add a 'Unrecognized' tokens (e.g. so those can have specific color in UI)
             *
             * @instance
             * @private
             * @this Kusto.Data.IntelliSense.CslCommand
             * @memberof Kusto.Data.IntelliSense.CslCommand
             * @param   {Kusto.Data.IntelliSense.CslCommandIndexer}    indexer             
             * @param   {System.Collections.Generic.List$1}            tokens              
             * @param   {System.Collections.Generic.List$1}            recognizedTokens
             * @return  {void}
             */
            EnsureAllTextIsAnnotated: function (indexer, tokens, recognizedTokens) {
                if (tokens == null) {
                    return;
                }

                this.AddUnrecognizedTokens(indexer, tokens, recognizedTokens);

                tokens.Sort$2($asm.$.Kusto.Data.IntelliSense.CslCommand.f12);

                var start = 0;
                // After all other tokens are present
                var tokensCount = tokens.Count; // cache this value = we are going to add more items to the list
                for (var i = 0; i < tokensCount; i = (i + 1) | 0) {
                    var token = tokens.getItem(i);
                    if (start < token.RelativeStart) {
                        var newTokenLen = (token.RelativeStart - start) | 0;
                        if (newTokenLen > 0) {
                            var tokenText = this.Text.substr(start, newTokenLen);
                            this.AddPlainOrUnrecognizedTokens(tokens, start, tokenText);
                        }
                    }
                    start = token.RelativeEnd;
                }

                // Add text tokens
                if (start < this.Length) {
                    var tokenText1 = this.Text.substr(start, ((this.Length - start) | 0));
                    this.AddPlainOrUnrecognizedTokens(tokens, start, tokenText1);
                }
            },
            AddUnrecognizedTokens: function (indexer, tokens, recognizedTokens) {
                var $t;
                var unrecognizedTokens = indexer.GetUnrecognizedTokenPositions(recognizedTokens);
                $t = Bridge.getEnumerator(unrecognizedTokens, Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        this.AddPlainOrUnrecognizedTokens(tokens, t.Start, t.Text);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            AddPlainOrUnrecognizedTokens: function (tokens, tokenStart, text) {
                var $t;
                var chars = System.String.toCharArray(text, 0, text.length);
                var startTextIndex = -1;
                var endTextIndex = chars.length;
                for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                    if (!System.Char.isWhiteSpace(String.fromCharCode(chars[System.Array.index(i, chars)]))) {
                        endTextIndex = (i + 1) | 0;
                        startTextIndex = (startTextIndex >= 0) ? startTextIndex : i;
                    }
                }

                if (startTextIndex > 0) {
                    var prefixText = text.substr(0, startTextIndex);
                    var prefixToken = ($t = new Kusto.Data.IntelliSense.CslCommandToken(prefixText, this.RelativeStart, Kusto.Data.IntelliSense.CslCommandToken.Kind.PlainTextToken), $t.Length = startTextIndex, $t.RelativeStart = tokenStart, $t);
                    tokens.add(prefixToken);
                } else {
                    startTextIndex = 0;
                }

                var tokenText = text.substr(startTextIndex, ((endTextIndex - startTextIndex) | 0));
                var tokenKind = Kusto.Data.IntelliSense.CslCommand.StartsWithAlpha(tokenText) ? Kusto.Data.IntelliSense.CslCommandToken.Kind.UnknownToken : Kusto.Data.IntelliSense.CslCommandToken.Kind.PlainTextToken;
                var token = ($t = new Kusto.Data.IntelliSense.CslCommandToken(tokenText, this.RelativeStart, tokenKind), $t.Length = tokenText.length, $t.RelativeStart = ((tokenStart + startTextIndex) | 0), $t);
                tokens.add(token);

                if (endTextIndex < chars.length) {
                    var suffixText = text.substr(endTextIndex, ((chars.length - endTextIndex) | 0));
                    var suffixToken = ($t = new Kusto.Data.IntelliSense.CslCommandToken(suffixText, this.RelativeStart, Kusto.Data.IntelliSense.CslCommandToken.Kind.PlainTextToken), $t.Length = suffixText.length, $t.RelativeStart = ((tokenStart + endTextIndex) | 0), $t);
                    tokens.add(suffixToken);
                }
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslCommand", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslCommand, {
        f1: function (_o1) {
            _o1.add("distinct");
            _o1.add("extend");
            _o1.add("project");
            _o1.add("project-rename");
            _o1.add("mvexpand");
            _o1.add("where");
            _o1.add("filter");
            _o1.add("parse");
            _o1.add("limit");
            _o1.add("count");
            _o1.add("order");
            _o1.add("sort");
            _o1.add("reduce");
            _o1.add("take");
            _o1.add("summarize");
            _o1.add("top");
            _o1.add("top-nested");
            _o1.add("top-hitters");
            _o1.add("render");
            _o1.add("fork");
            _o1.add("find");
            _o1.add("sample");
            _o1.add("sample-distinct");
            _o1.add("search");
            _o1.add("make-series");
            return _o1;
        },
        f2: function (c) {
            return c.m_tokens;
        },
        f3: function (c) {
            return c.m_commandParts;
        },
        f4: function (c) {
            return c.m_commentsParts;
        },
        f5: function (c) {
            return c.m_clientDirectivesParts;
        },
        f6: function (c) {
            return c.m_bracketParts;
        },
        f7: function (c) {
            return c.Text;
        },
        f8: function (c) {
            return c.IsRunnable;
        },
        f9: function (p) {
            return p.AbsoluteStart;
        },
        f10: function (p) {
            return p.RelativeStart;
        },
        f11: function (t) {
            var token = Bridge.as(t.clone(), Kusto.Data.IntelliSense.CslCommandToken);
            token.AbsolutePositionBias = this.RelativeStart;
            return token;
        },
        f12: function (x, y) {
            return x.CompareTo(y);
        },
        f13: function (ct) {
            return ct.Value;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommand.AddEntitiesTokensState", {
        $kind: "nested class",
        fields: {
            MapOfKnownEntities: null,
            MapOfPreviousCalculatedEntities: null,
            MapOfOriginallyKnownEntities: null
        },
        ctors: {
            init: function () {
                this.MapOfKnownEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.MapOfPreviousCalculatedEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.MapOfOriginallyKnownEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
            }
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.CslCommand.AddEntitiesTokensState(), $t.MapOfKnownEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))(this.MapOfKnownEntities), $t.MapOfOriginallyKnownEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))(this.MapOfOriginallyKnownEntities), $t.MapOfPreviousCalculatedEntities = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))(this.MapOfPreviousCalculatedEntities), $t);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommand.FormatTraits", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                IncludeComments: 1,
                TabulateOnJoins: 2,
                TabulateOnFunctionBoundaries: 4
            }
        },
        $flags: true
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommand.PrivateTracer", {
        $kind: "nested class",
        statics: {
            fields: {
                Tracer: null
            },
            ctors: {
                init: function () {
                    this.Tracer = new Kusto.Data.IntelliSense.CslCommand.PrivateTracer();
                }
            }
        },
        methods: {
            TraceVerbose: function (format, list) {
                if (list === void 0) { list = []; }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandIndexer", {
        statics: {
            fields: {
                MultiLineRegexOptions: 0,
                SingleLineRegexOptions: 0,
                s_defaultCommentRegex: null,
                s_defaultClientDirectivesRegex: null,
                s_defaultStringLiteralsRegex: null,
                s_defaultQueryParametersRegex: null,
                s_matchingBrackets: null
            },
            ctors: {
                init: function () {
                    this.MultiLineRegexOptions = 2;
                    this.SingleLineRegexOptions = 16;
                    this.s_defaultCommentRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*//.*?(\\n|$))", Kusto.Data.IntelliSense.CslCommandIndexer.MultiLineRegexOptions);
                    this.s_defaultClientDirectivesRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*#.*?(\\n|$))", Kusto.Data.IntelliSense.CslCommandIndexer.MultiLineRegexOptions);
                    this.s_defaultStringLiteralsRegex = new System.Text.RegularExpressions.Regex.ctor("(@?'.*?\\'|@?\\\".*?\\\")", Kusto.Data.IntelliSense.CslCommandIndexer.MultiLineRegexOptions);
                    this.s_defaultQueryParametersRegex = new System.Text.RegularExpressions.Regex.ctor("\\{([a-zA-Z]\\w+?)\\}", Kusto.Data.IntelliSense.CslCommandIndexer.MultiLineRegexOptions);
                    this.s_matchingBrackets = $asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f1(new (System.Collections.Generic.Dictionary$2(System.Char,System.Char))());
                }
            },
            methods: {
                AddToCollection: function (text, chars, tokenStart, scanStart, target) {
                    var $t;
                    var endOfArray = { };
                    var terminators = System.Array.init([10, 13], System.Char);
                    var token = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = tokenStart, $t.End = Kusto.Data.IntelliSense.CslCommandIndexer.ReadTill(chars, ((scanStart + 1) | 0), terminators, null, endOfArray), $t);

                    if (token.End > token.Start) {
                        if (endOfArray.v) {
                            token.End = (token.End - 1) | 0;
                        }
                        var len = (((token.End - token.Start) | 0) + 1) | 0;
                        token.Text = text.substr(token.Start, len);
                        target.add(token);
                    }
                    return token.End;
                },
                ReadTill: function (chars, i, terminators, escaping, endOfArray) {
                    endOfArray.v = true;
                    var foundTerminators = new (System.Collections.Generic.HashSet$1(System.Char)).ctor();
                    for (; i < chars.length; i = (i + 1) | 0) {
                        // If one terminator found, consume all others
                        if (System.Linq.Enumerable.from(foundTerminators).any()) {
                            // Consume terminators (but only once)
                            if (System.Array.contains(terminators, chars[System.Array.index(i, chars)], System.Char) && !foundTerminators.contains(chars[System.Array.index(i, chars)])) {
                                foundTerminators.add(chars[System.Array.index(i, chars)]);
                                continue;
                            }

                            endOfArray.v = false;
                            i = (i - 1) | 0; // Move one back - to the previous terminator
                            break;
                        }

                        if (System.Array.contains(terminators, chars[System.Array.index(i, chars)], System.Char)) {
                            foundTerminators.add(chars[System.Array.index(i, chars)]);
                            continue;
                        }

                        if (escaping != null && System.Linq.Enumerable.from(escaping).any(function (t) {
                                return chars[System.Array.index(i, chars)] === t;
                            })) {
                            // Move to next char
                            i = (i + 1) | 0;
                        }
                    }

                    if (i > chars.length) {
                        return chars.length;
                    }
                    return i;
                },
                ReadVerbatimTill: function (chars, i, terminators, endOfArray) {
                    endOfArray.v = true;
                    var escapeSequence = 0;
                    for (; i < chars.length; i = (i + 1) | 0) {
                        if (System.Array.contains(terminators, chars[System.Array.index(i, chars)], System.Char)) {
                            escapeSequence = (escapeSequence + 1) | 0;
                            if (escapeSequence % 2 !== 0 && i < ((chars.length - 1) | 0) && !System.Array.contains(terminators, chars[System.Array.index(((i + 1) | 0), chars)], System.Char)) {
                                endOfArray.v = false;
                                break;
                            }
                        }
                    }

                    return i;
                },
                CaptureTokensUsingRegex: function (text, regexList, tokenList) {
                    var $t, $t1, $t2, $t3;
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.System.Text.RegularExpressions.Regex, regexList)) {
                        return;
                    }

                    $t = Bridge.getEnumerator(regexList);
                    try {
                        while ($t.moveNext()) {
                            var commentRegex = $t.Current;
                            var matches = commentRegex.matches(text);
                            $t1 = Bridge.getEnumerator(matches);
                            try {
                                while ($t1.moveNext()) {
                                    var m = Bridge.cast($t1.Current, System.Text.RegularExpressions.Match);
                                    $t2 = Bridge.getEnumerator(m.getCaptures());
                                    try {
                                        while ($t2.moveNext()) {
                                            var c = Bridge.cast($t2.Current, System.Text.RegularExpressions.Capture);
                                            var token = ($t3 = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t3.Start = c.getIndex(), $t3.End = ((((c.getIndex() + c.getLength()) | 0) - 1) | 0), $t3.Text = c.getValue(), $t3);
                                            tokenList.add(token);
                                        }
                                    } finally {
                                        if (Bridge.is($t2, System.IDisposable)) {
                                            $t2.System$IDisposable$Dispose();
                                        }
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}
            }
        },
        fields: {
            m_tokensAndPositions: null,
            m_commentTokenPositions: null,
            m_clientDirectivesTokenPositions: null,
            m_stringLiteralsPositions: null,
            m_queryParametersPositions: null,
            m_commandPartsPositions: null,
            m_bracketPartsPositions: null,
            m_sourceText: null,
            m_commentRegexCollection: null,
            m_clientDirectivesRegexCollection: null,
            m_stringLiteralsRegexCollection: null,
            m_queryParametersRegexCollection: null
        },
        props: {
            AntiTokenizers: null,
            TokenTerminators: null,
            TokenStarters: null
        },
        ctors: {
            init: function () {
                this.m_tokensAndPositions = new (System.Collections.Generic.Dictionary$2(System.String,System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)))();
                this.m_commentTokenPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_clientDirectivesTokenPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_stringLiteralsPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_queryParametersPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_commandPartsPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_bracketPartsPositions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                this.m_commentRegexCollection = new (System.Collections.Generic.List$1(System.Text.RegularExpressions.Regex)).ctor();
                this.m_clientDirectivesRegexCollection = new (System.Collections.Generic.List$1(System.Text.RegularExpressions.Regex)).ctor();
                this.m_stringLiteralsRegexCollection = new (System.Collections.Generic.List$1(System.Text.RegularExpressions.Regex)).ctor();
                this.m_queryParametersRegexCollection = new (System.Collections.Generic.List$1(System.Text.RegularExpressions.Regex)).ctor();
            },
            ctor: function (indexQueryParameters) {
                this.$initialize();
                this.m_commentRegexCollection.add(Kusto.Data.IntelliSense.CslCommandIndexer.s_defaultCommentRegex);
                this.m_clientDirectivesRegexCollection.add(Kusto.Data.IntelliSense.CslCommandIndexer.s_defaultClientDirectivesRegex);
                this.m_stringLiteralsRegexCollection.add(Kusto.Data.IntelliSense.CslCommandIndexer.s_defaultStringLiteralsRegex);

                if (indexQueryParameters) {
                    this.m_queryParametersRegexCollection.add(Kusto.Data.IntelliSense.CslCommandIndexer.s_defaultQueryParametersRegex);
                }
            }
        },
        methods: {
            IndexText: function (text) {
                var $t;
                this.m_tokensAndPositions.clear();
                this.m_sourceText = text;

                // Split text into words
                var chars = System.String.toCharArray(text, 0, text.length);

                // First, detect comments and string literals
                this.DetectCommentsAndStringLiterals(text);
                var skipRanges = this.GetTokenLookupSkipRanges(text.length);

                var tokenLookupState = Kusto.Data.IntelliSense.CslCommandIndexer.State.LookingForTokenStart;
                var tokenBuilder = null;
                var tokenPosition = null;
                var commandPartPosition = null;
                var bracketsStack = new (System.Collections.Generic.Stack$1(System.Object)).ctor();
                for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                    var isInsideTokenLookupSkipRange = skipRanges[System.Array.index(i, skipRanges)];
                    var isInsideCommentRange = (System.Linq.Enumerable.from(this.m_commentTokenPositions).where(function (r) {
                            return i >= r.Start && i <= r.End;
                        }).any());
                    var c = chars[System.Array.index(i, chars)];
                    var isAfterWhiteSpace = (i === 0) || System.Char.isWhiteSpace(String.fromCharCode(chars[System.Array.index(((i - 1) | 0), chars)]));

                    var canStartNewPart = true;
                    // Check if there is an existing part already
                    if (commandPartPosition != null && (((c === 124 || c === 59) && !isInsideTokenLookupSkipRange) || isInsideCommentRange || i === ((chars.length - 1) | 0))) {
                        if (i === ((chars.length - 1) | 0) || c === 59) {
                            commandPartPosition.End = i;
                            canStartNewPart = false;
                        } else {
                            commandPartPosition.End = (((i - 1) | 0));
                        }
                        var len = (((commandPartPosition.End - commandPartPosition.Start) | 0) + 1) | 0;
                        if (len > 1) {
                            var partText = text.substr(commandPartPosition.Start, len);
                            commandPartPosition.Text = partText;
                            // avoiding to consider a single newline symbol as an independent command part
                            if (!System.String.equals(partText, "\n")) {
                                this.m_commandPartsPositions.add(commandPartPosition);
                            }
                        }
                        commandPartPosition = null;
                    }
                    // Add new command part (separated by '|') if it was detected
                    if (commandPartPosition == null && !isInsideCommentRange && canStartNewPart) {
                        commandPartPosition = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = i, $t.End = i, $t);
                    }

                    // Brackets check
                    if (!isInsideTokenLookupSkipRange) {
                        if (System.Array.contains(Kusto.Data.IntelliSense.CslCommandIndexer.s_matchingBrackets.getKeys(), c, System.Char)) {
                            if (System.Linq.Enumerable.from(bracketsStack).any() && bracketsStack.Peek().Item1 === c) {
                                var bracketItem = bracketsStack.Pop();
                                var bracketToken = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = bracketItem.Item2, $t.End = i, $t);
                                bracketToken.Text = text.substr(bracketToken.Start, ((((bracketToken.End - bracketToken.Start) | 0) + 1) | 0));
                                this.m_bracketPartsPositions.add(bracketToken);
                            } else {
                                bracketsStack.Push({ Item1: Kusto.Data.IntelliSense.CslCommandIndexer.s_matchingBrackets.get(c), Item2: i });
                            }
                        }
                    }

                    switch (tokenLookupState) {
                        case Kusto.Data.IntelliSense.CslCommandIndexer.State.LookingForTokenStart: 
                            if (!isInsideTokenLookupSkipRange && ((this.IsPartOfTheToken(c) && !this.IsTokenTerminator(c)) || (isAfterWhiteSpace && this.IsTokenStarter(c)))) {
                                tokenBuilder = new System.Text.StringBuilder();
                                tokenPosition = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = i, $t.End = i, $t);
                                tokenBuilder.append(String.fromCharCode(c));
                                tokenLookupState = Kusto.Data.IntelliSense.CslCommandIndexer.State.LookingForTokenEnd;
                            }
                            break;
                        case Kusto.Data.IntelliSense.CslCommandIndexer.State.LookingForTokenEnd: 
                            var isTokenEnd = false;
                            if (!isInsideTokenLookupSkipRange && this.IsPartOfTheToken(c)) {
                                if (this.IsTokenTerminator(c)) {
                                    tokenPosition.TokenTerminator = c;
                                    isTokenEnd = true;
                                } else {
                                    tokenBuilder.append(String.fromCharCode(c));
                                    tokenPosition.End = i;
                                }
                            } else {
                                isTokenEnd = true;
                            }
                            if (isTokenEnd || i === ((chars.length - 1) | 0)) {
                                tokenPosition.Text = tokenBuilder.toString();
                                this.AddTokenPosition(tokenPosition);
                                // Token has ended
                                tokenLookupState = Kusto.Data.IntelliSense.CslCommandIndexer.State.LookingForTokenStart;
                            }
                            break;
                    }
                }
            },
            GetTokenLookupSkipRanges: function (size) {
                var ranges = new (System.Collections.Generic.List$1(System.Object)).ctor();
                ranges.AddRange(System.Linq.Enumerable.from(this.m_stringLiteralsPositions).select($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f2));
                ranges.AddRange(System.Linq.Enumerable.from(this.m_commentTokenPositions).select($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f2));
                ranges.AddRange(System.Linq.Enumerable.from(this.m_clientDirectivesTokenPositions).select($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f2));
                ranges.AddRange(System.Linq.Enumerable.from(this.m_queryParametersPositions).select($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f2));
                ranges.Sort$2($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f3);

                var rIndex = 0;
                var currentSkipRange = System.Linq.Enumerable.from(ranges).firstOrDefault(null, null);
                var result = System.Array.init(size, false, System.Boolean);
                for (var i = 0; i < size && currentSkipRange != null; i = (i + 1) | 0) {
                    if (i >= currentSkipRange.Item1) {
                        result[System.Array.index(i, result)] = true;
                    }
                    if (currentSkipRange.Item2 === i) {
                        currentSkipRange = System.Linq.Enumerable.from(ranges).elementAtOrDefault(((rIndex = (rIndex + 1) | 0)), null);
                    }
                }

                return result;
            },
            GetCommandPartsPositions: function () {
                return this.m_commandPartsPositions;
            },
            GetCommentsPositions: function () {
                return this.m_commentTokenPositions;
            },
            GetClientDirectivesPositions: function () {
                return this.m_clientDirectivesTokenPositions;
            },
            GetStringLiteralsPositions: function () {
                return this.m_stringLiteralsPositions;
            },
            GetQueryParametersPositions: function () {
                return this.m_queryParametersPositions;
            },
            GetBracketsPositions: function () {
                return this.m_bracketPartsPositions;
            },
            GetUnrecognizedTokenPositions: function (recognizedTokens) {
                return System.Linq.Enumerable.from(this.m_tokensAndPositions.getValues()).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f4).except(recognizedTokens);
            },
            GetTokenPositionsInRange: function (searchForTokens, rangeStart, rangeEnd) {
                var $t;
                var result = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, searchForTokens)) {
                    return result;
                }

                $t = Bridge.getEnumerator(searchForTokens, System.String);
                try {
                    while ($t.moveNext()) {
                        var token = $t.Current;
                        if (System.String.isNullOrEmpty(token)) {
                            continue;
                        }
                        if (this.m_tokensAndPositions.containsKey(token)) {
                            var tokensInRange = System.Linq.Enumerable.from(this.m_tokensAndPositions.get(token)).where(function (t) {
                                    return t.Start >= rangeStart && t.End <= rangeEnd;
                                });
                            if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition, tokensInRange)) {
                                result.AddRange(tokensInRange);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }return result;
            },
            GetAllTokensSortedByPosition: function () {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.System.Collections.Generic.KeyValuePair$2(System.String,System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)), this.m_tokensAndPositions)) {
                    return null;
                }

                return System.Linq.Enumerable.from(this.m_tokensAndPositions).selectMany($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f5).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer.f6);
            },
            GetAllTokenPositions: function (tokens, tokenSuffix) {
                var $t;
                if (tokenSuffix === void 0) { tokenSuffix = 0; }
                var result = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor();
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, tokens)) {
                    return result;
                }

                $t = Bridge.getEnumerator(tokens, System.String);
                try {
                    while ($t.moveNext()) {
                        var token = $t.Current;
                        if (this.m_tokensAndPositions.containsKey(token)) {
                            result.AddRange(System.Linq.Enumerable.from(this.m_tokensAndPositions.get(token)).where(function (t) {
                                    return t.TokenTerminator === tokenSuffix;
                                }));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }return result;
            },
            IsPartOfTheToken: function (c) {
                return (System.Char.isDigit(c) || System.Char.isLetter(c)) || (this.AntiTokenizers != null && this.AntiTokenizers.contains(c));
            },
            IsTokenTerminator: function (c) {
                return (this.TokenTerminators != null && this.TokenTerminators.contains(c));
            },
            IsTokenStarter: function (c) {
                return (this.TokenStarters != null && System.Array.contains(this.TokenStarters, c, System.Char));
            },
            DetectCommentsAndStringLiterals: function (text) {
                Kusto.Data.IntelliSense.CslCommandIndexer.CaptureTokensUsingRegex(text, this.m_queryParametersRegexCollection, this.m_queryParametersPositions);
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.None(Bridge.global.Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition, this.m_queryParametersPositions)) {
                    // If there are no query parameters - 
                    // take more simple and more performant path:
                    this.DetectCommentsAndStringLiterals_Simple(text);
                } else {
                    // Query parameters exist in the command - therefore
                    // take complex and more expensive path: 
                    this.DetectCommentsAndStringLiterals_Complex(text);
                }
            },
            DetectCommentsAndStringLiterals_Simple: function (text) {
                var chars = System.String.toCharArray(text, 0, text.length);
                var state = 0;
                for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                    var ch = chars[System.Array.index(i, chars)];
                    switch (state) {
                        case 0: 
                            if (ch === 64) {
                                state = 1;
                            } else if (ch === 39 || ch === 34) {
                                i = this.AddStringLiteralToken(text, chars, i, i, ch, false);
                            } else if (ch === 47) {
                                state = 2;
                            } else if (ch === 35) {
                                i = this.AddClientDirectiveToken(text, chars, i, i);
                                state = 0;
                            }
                            break;
                        case 1:  // Looking for string literals
                            if (ch === 39 || ch === 34) {
                                i = this.AddStringLiteralToken(text, chars, ((i - 1) | 0), i, ch, true);
                            }
                            state = 0;
                            break;
                        case 2:  // Looking for comment
                            if (ch === 47) {
                                i = this.AddCommentToken(text, chars, ((i - 1) | 0), i);
                            }
                            state = 0;
                            break;
                    }
                }
            },
            AddCommentToken: function (text, chars, tokenStart, scanStart) {
                return Kusto.Data.IntelliSense.CslCommandIndexer.AddToCollection(text, chars, tokenStart, scanStart, this.m_commentTokenPositions);
            },
            AddClientDirectiveToken: function (text, chars, tokenStart, scanStart) {
                return Kusto.Data.IntelliSense.CslCommandIndexer.AddToCollection(text, chars, tokenStart, scanStart, this.m_clientDirectivesTokenPositions);
            },
            AddStringLiteralToken: function (text, chars, start, position, ch, ifVerbatim) {
                var $t;
                var endOfArray = { };
                var token = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = start, $t.End = ifVerbatim ? Kusto.Data.IntelliSense.CslCommandIndexer.ReadVerbatimTill(chars, ((position + 1) | 0), System.Array.init([ch], System.Char), endOfArray) : Kusto.Data.IntelliSense.CslCommandIndexer.ReadTill(chars, ((position + 1) | 0), System.Array.init([ch], System.Char), System.Array.init([92], System.Char), endOfArray), $t);

                if (token.End > token.Start) {
                    if (endOfArray.v) {
                        token.End = (token.End - 1) | 0;
                    }
                    var len = (((token.End - token.Start) | 0) + 1) | 0;
                    token.Text = text.substr(token.Start, len);
                    this.m_stringLiteralsPositions.add(token);
                }
                return token.End;
            },
            DetectCommentsAndStringLiterals_Complex: function (text) {
                var $t;
                Kusto.Data.IntelliSense.CslCommandIndexer.CaptureTokensUsingRegex(text, this.m_commentRegexCollection, this.m_commentTokenPositions);
                Kusto.Data.IntelliSense.CslCommandIndexer.CaptureTokensUsingRegex(text, this.m_clientDirectivesRegexCollection, this.m_clientDirectivesTokenPositions);

                // Ignore tokens inside comments
                for (var i = (this.m_queryParametersPositions.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    var slp = { v : this.m_queryParametersPositions.getItem(i) };
                    if (System.Linq.Enumerable.from(this.m_commentTokenPositions).where((function ($me, slp) {
                            return function (comment) {
                                return comment.Start <= slp.v.Start && comment.End >= slp.v.End;
                            };
                        })(this, slp)).any()) {
                        this.m_queryParametersPositions.removeAt(i);
                    }
                }

                Kusto.Data.IntelliSense.CslCommandIndexer.CaptureTokensUsingRegex(text, this.m_stringLiteralsRegexCollection, this.m_stringLiteralsPositions);
                // Ignore tokens inside comments
                for (var i1 = (this.m_stringLiteralsPositions.Count - 1) | 0; i1 >= 0; i1 = (i1 - 1) | 0) {
                    var slp1 = { v : this.m_stringLiteralsPositions.getItem(i1) };
                    if (System.Linq.Enumerable.from(this.m_commentTokenPositions).where((function ($me, slp1) {
                            return function (comment) {
                                return comment.Start <= slp1.v.Start && comment.End >= slp1.v.End;
                            };
                        })(this, slp1)).any()) {
                        this.m_stringLiteralsPositions.removeAt(i1);
                    }
                }

                // Split string tokens if they contain query parameters
                for (var i2 = (this.m_queryParametersPositions.Count - 1) | 0; i2 >= 0; i2 = (i2 - 1) | 0) {
                    var qpp = { v : this.m_queryParametersPositions.getItem(i2) };
                    var slp2 = System.Linq.Enumerable.from(this.m_stringLiteralsPositions).where((function ($me, qpp) {
                            return function (s) {
                                return s.Start <= qpp.v.Start && s.End >= qpp.v.End;
                            };
                        })(this, qpp)).firstOrDefault(null, null);

                    if (slp2 != null) {
                        var newSlp = ($t = new Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition(), $t.Start = ((qpp.v.End + 1) | 0), $t.End = slp2.End, $t.Text = slp2.Text.substr(((((qpp.v.End - slp2.Start) | 0) + 1) | 0)), $t);

                        slp2.End = (qpp.v.Start - 1) | 0;
                        slp2.Text = slp2.Text.substr(0, slp2.Length);
                        this.m_stringLiteralsPositions.add(newSlp);
                    }
                }
            },
            AddTokenPosition: function (tokenPosition) {
                if (!this.m_tokensAndPositions.containsKey(tokenPosition.Text)) {
                    this.m_tokensAndPositions.add(tokenPosition.Text, new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition)).ctor());
                }

                this.m_tokensAndPositions.get(tokenPosition.Text).add(tokenPosition);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslCommandIndexer", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslCommandIndexer, {
        f1: function (_o1) {
            _o1.add(40, 41);
            _o1.add(41, 40);
            _o1.add(91, 93);
            _o1.add(93, 91);
            _o1.add(123, 125);
            _o1.add(125, 123);
            return _o1;
        },
        f2: function (p) {
            return { Item1: p.Start, Item2: p.End };
        },
        f3: function (r1, r2) {
            return Bridge.compare(r1.Item1, r2.Item1);
        },
        f4: function (t) {
            return t;
        },
        f5: function (kvp) {
            return kvp.value;
        },
        f6: function (t) {
            return t.Start;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandIndexer.State", {
        $kind: "nested enum",
        statics: {
            fields: {
                LookingForTokenStart: 0,
                LookingForTokenEnd: 1,
                InsideComment: 2,
                InsideStringLiteral: 3
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandIndexer.TokenPosition", {
        $kind: "nested class",
        props: {
            Text: null,
            Start: 0,
            End: 0,
            TokenTerminator: 0,
            Length: {
                get: function () {
                    return ((((this.End - this.Start) | 0) + 1) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                // Explicitly set to '\0' to overcome Bridge.Net bug 3182:
                // http://forums.bridge.net/forum/bridge-net-pro/bugs/3182-comparing-0-to-unassigned-char-returns-false
                this.TokenTerminator = 0;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandParser", {
        statics: {
            fields: {
                ControlCommandsTokens: null,
                CslCommandsTokens: null,
                ChartRenderTypesTokens: null,
                ChartRenderKindTokens: null,
                SubOperatorsTokens: null,
                JoinKindTokens: null,
                ReduceByKindTokens: null,
                DataTypesTokens: null,
                ScalarFunctionsDateTimeTokens: null,
                ScalarFunctionsNoDateTimeTokens: null,
                SingleParameterFunctionsDateTimeTokens: null,
                ZeroParameterFunctionsNoDateTimeTokens: null,
                SingleParameterFunctionsNoDateTimeTokens: null,
                IntrinsicFunctionTokens: null,
                TwoParameterFunctionsTokens: null,
                ThreeParameterFunctionsTokens: null,
                ManyParametersFunctionsTokens: null,
                PromotedOperatorCommandTokens: null,
                ClientDirectiveTokens: null,
                OperatorCommandTokens: null,
                SummarizeAggregationSingleParameterTokens: null,
                SummarizeAggregationTwoParametersTokens: null,
                SummarizeAggregationThreeParametersTokens: null,
                SummarizeAggregationManyParametersTokens: null,
                MakeSeriesAggregationTokens: null,
                PluginTokens: null,
                DatetimeFunctionsTokens: null,
                ScalarFunctionsTokens: null,
                SingleParameterFunctionsTokens: null,
                SummarizeAggregationTokens: null,
                SummarizeAggregationAliasesTokens: null,
                SortedSummarizeAggregators: null,
                SortedMakeSeriesAggregationTokens: null,
                SortedDatetimeFunctions: null,
                SortedExtendFunctions: null,
                FunctionsTokens: null,
                SortedEvaluateFunctions: null,
                s_isCommentLineRegex: null
            },
            ctors: {
                init: function () {
                    this.ControlCommandsTokens = System.Array.init([".add", ".alter", ".alter-merge", ".attach", ".append", ".create", ".create-merge", ".create-set", ".create-or-alter", ".define", ".detach", ".delete", ".drop", ".drop-pretend", ".dup-next-ingest", ".dup-next-failed-ingest", ".ingest", ".export", ".load", ".move", ".purge", ".purge-cleanup", ".remove", ".replace", ".save", ".set", ".set-or-append", ".set-or-replace", ".show", ".rename", "async", "data", "into", "ifnotexists", "whatif", "compressed", "monitoring", "metadata", "folder", "docstring", "details", "hot", "records", "until", "as", "csv", "tsv", "json", "sql", "policy", "encoding", "retention", "merge", "policies", "update", "ingestiontime", "caching", "querythrottling", "sharding", "callout", "querylimit", "restricted_view_access", "softdelete", "harddelete", "rowstore", "rowstores", "seal", "writeaheadlog", "streamingingestion", "rowstore_references", "follower"], System.String);
                    this.CslCommandsTokens = System.Array.init(["set", "let", "restrict", "access", "alias", "pattern", "declare", "query_parameters"], System.String);
                    this.ChartRenderTypesTokens = System.Linq.Enumerable.from(System.Array.init(["columnchart", "barchart", "piechart", "timechart", "anomalychart", "linechart", "ladderchart", "pivotchart", "areachart", "stackedareachart", "scatterchart", "timepivot", "timeline"], System.String)).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f1).ToArray(System.String);
                    this.ChartRenderKindTokens = System.Array.init(["default", "stacked", "stacked100", "unstacked"], System.String);
                    this.SubOperatorsTokens = System.Linq.Enumerable.from(System.Array.init(["like", "notlike", "contains", "notcontains", "!contains", "contains_cs", "!contains_cs", "startswith", "!startswith", "has", "!has", "has_cs", "!has_cs", "hasprefix", "!hasprefix", "hassuffix", "!hassuffix", "matches", "regex", "in", "!in", "endswith", "!endswith", "between", "!between", "extent", "database", "diagnostics", "admins", "basicauth", "cache", "capacity", "cluster", "databases", "extents", "journal", "memory", "extentcontainers", "viewers", "unrestrictedviewers", "tags", "prettyname", "blockedprincipals", "operations", "password", "principal", "principals", "settings", "schema", "table", "tables", "user", "users", "ingestors", "monitors", "version", "roles", "fabric", "locks", "services", "nodes", "commands", "queries", "query", "function", "functions", "by", "on", "of", "true", "false", "and", "or", "asc", "desc", "nulls", "last", "first", "with", "withsource", "kind", "flags", "from", "to", "step", "ingestion", "failures", "mapping", "mappings", "geneva", "eventhub", "source", "sources", "types", "application", "period", "reason", "title"], System.String)).union(Kusto.Data.IntelliSense.CslCommandParser.ChartRenderTypesTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ChartRenderKindTokens).distinct().ToArray(System.String);
                    this.JoinKindTokens = System.Array.init(["anti", "inner", "innerunique", "fullouter", "leftanti", "leftantisemi", "leftouter", "leftsemi", "rightanti", "rightantisemi", "rightsemi", "rightouter"], System.String);
                    this.ReduceByKindTokens = System.Array.init(["mining"], System.String);
                    this.DataTypesTokens = System.Array.init(["date", "time", "timespan", "datetime", "int", "long", "real", "float", "string", "bool", "boolean", "double", "dynamic", "decimal"], System.String);
                    this.ScalarFunctionsDateTimeTokens = System.Array.init(["now", "ago", "datetime", "ingestion_time"], System.String);
                    this.ScalarFunctionsNoDateTimeTokens = System.Array.init(["time", "timespan", "dynamic", "decimal"], System.String);
                    this.SingleParameterFunctionsDateTimeTokens = System.Array.init(["todatetime", "between", "!between"], System.String);
                    this.ZeroParameterFunctionsNoDateTimeTokens = System.Array.init(["row_number", "extent_id", "extent_tags", "pi", "pack_all", "rowstore_ordinal_range"], System.String);
                    this.SingleParameterFunctionsNoDateTimeTokens = System.Array.init(["strlen", "tostring", "toupper", "tolower", "typeof", "reverse", "parsejson", "parse_json", "parse_xml", "tobool", "toboolean", "todynamic", "toobject", "toint", "tolong", "toguid", "todouble", "toreal", "totimespan", "tohex", "todecimal", "isempty", "isnotempty", "isnull", "isnotnull", "isnan", "isinf", "isfinite", "dayofweek", "dayofmonth", "dayofyear", "weekofyear", "monthofyear", "sqrt", "rand", "log", "log10", "log2", "exp", "exp2", "exp10", "abs", "degrees", "radians", "sign", "sin", "cos", "tan", "asin", "acos", "atan", "cot", "getmonth", "getyear", "arraylength", "gettype", "cursor_after", "gamma", "loggamma", "dcount_hll", "parse_ipv4", "parse_url", "parse_path", "parse_version", "parse_urlquery", "url_encode", "url_decode", "binary_not", "not", "toscalar", "materialize", "series_stats", "series_fit_line", "series_fit_2lines", "series_stats_dynamic", "series_fit_line_dynamic", "series_fit_2lines_dynamic", "base64_encodestring", "base64_decodestring", "hash_sha256", "ceiling", "string_size"], System.String);
                    this.IntrinsicFunctionTokens = System.Array.init(["cluster", "database", "table"], System.String);
                    this.TwoParameterFunctionsTokens = System.Array.init(["bin", "columnifexists", "floor", "countof", "hash", "round", "pow", "binary_and", "binary_or", "binary_xor", "binary_shift_left", "binary_shift_right", "datepart", "datetime_part", "repeat", "series_seasonal", "series_outliers", "series_add", "series_subtract", "series_multiply", "series_divide", "series_greater", "series_greater_equals", "series_less", "series_less_equals", "series_equals", "series_not_equals", "rank_tdigest", "percentrank_tdigest", "trim", "trim_start", "trim_end", "startofday", "startofweek", "startofmonth", "startofyear", "endofday", "endofweek", "endofmonth", "endofyear", "series_fill_backward", "series_fill_forward", "atan2", "format_datetime", "format_timespan", "strrep", "strcat_array", "parse_user_agent", "strcmp", "row_cumsum", "point", "distance"], System.String);
                    this.ThreeParameterFunctionsTokens = System.Array.init(["iff", "iif", "range", "replace", "translate", "series_iir", "bin_at", "series_fill_const", "series_decompose", "datetime_diff", "datetime_add"], System.String);
                    this.ManyParametersFunctionsTokens = System.Array.init(["extract", "extractjson", "extractall", "strcat", "strcat_delim", "substring", "indexof", "split", "case", "coalesce", "max_of", "min_of", "percentile_tdigest", "zip", "pack", "pack_array", "array_concat", "welch_test", "series_fir", "series_periods_detect", "prev", "next", "tdigest_merge", "hll_merge", "series_fill_linear", "series_periods_validate", "datatable", "make_datetime", "make_timespan", "make_string"], System.String);
                    this.PromotedOperatorCommandTokens = System.Array.init(["where", "count", "extend", "join", "limit", "order", "project", "project-away", "project-rename", "render", "sort", "summarize", "distinct", "take", "top", "top-nested", "top-hitters", "union", "mvexpand", "reduce", "evaluate", "parse", "sample", "sample-distinct", "make-series", "getschema", "serialize", "invoke"], System.String);
                    this.ClientDirectiveTokens = System.Array.init(["connect"], System.String);
                    this.OperatorCommandTokens = System.Linq.Enumerable.from(System.Array.init(["filter", "fork", "facet", "range", "consume", "find", "search", "print"], System.String)).union(Kusto.Data.IntelliSense.CslCommandParser.PromotedOperatorCommandTokens).ToArray(System.String);
                    this.SummarizeAggregationSingleParameterTokens = System.Array.init(["count", "countif", "dcount", "dcountif", "sum", "min", "max", "avg", "avgif", "any", "makelist", "makeset", "make_dictionary", "stdev", "stdevif", "varianceif", "variance", "buildschema", "hll", "hll_merge", "tdigest", "tdigest_merge"], System.String);
                    this.SummarizeAggregationTwoParametersTokens = System.Array.init(["percentile", "sumif"], System.String);
                    this.SummarizeAggregationThreeParametersTokens = System.Array.init(["percentilew"], System.String);
                    this.SummarizeAggregationManyParametersTokens = System.Array.init(["arg_min", "arg_max", "percentilesw_array", "percentilesw", "percentiles_array", "percentiles"], System.String);
                    this.MakeSeriesAggregationTokens = System.Array.init(["count", "countif", "dcount", "dcountif", "sum", "min", "max", "avg", "any", "stdev", "stdevp", "variance", "variancep", "sumif"], System.String);
                    this.PluginTokens = System.Array.init(["autocluster", "diffpatterns", "basket", "extractcolumns"], System.String);
                    this.DatetimeFunctionsTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ScalarFunctionsDateTimeTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsDateTimeTokens).ToArray(System.String);
                    this.ScalarFunctionsTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ScalarFunctionsDateTimeTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ScalarFunctionsNoDateTimeTokens).ToArray(System.String);
                    this.SingleParameterFunctionsTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsDateTimeTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsNoDateTimeTokens).ToArray(System.String);
                    this.SummarizeAggregationTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationSingleParameterTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationManyParametersTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationThreeParametersTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationTwoParametersTokens).ToArray(System.String);
                    this.SummarizeAggregationAliasesTokens = System.Array.init(["argmax", "argmin"], System.String);
                    this.SortedSummarizeAggregators = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationTokens).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f2).select($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f3).ToArray(System.String);
                    this.SortedMakeSeriesAggregationTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.MakeSeriesAggregationTokens).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f2).select($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f3).ToArray(System.String);
                    this.SortedDatetimeFunctions = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.DatetimeFunctionsTokens).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f2).select($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f3).ToArray(System.String);
                    this.SortedExtendFunctions = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ManyParametersFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ScalarFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ZeroParameterFunctionsNoDateTimeTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.TwoParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ThreeParameterFunctionsTokens).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f2).select($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f3).ToArray(System.String);
                    this.FunctionsTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ManyParametersFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ScalarFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ZeroParameterFunctionsNoDateTimeTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.TwoParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.ThreeParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationTokens).union(Kusto.Data.IntelliSense.CslCommandParser.IntrinsicFunctionTokens).ToArray(System.String);
                    this.SortedEvaluateFunctions = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.PluginTokens).orderBy($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f2).ToArray(System.String);
                    this.s_isCommentLineRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*//", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                }
            },
            methods: {
                IsAdminCommand$1: function (query, queryWithoutLeadingComments) {
                    return Kusto.Data.IntelliSense.CslCommandParser.IsStartingWithPrefix(query, ".", queryWithoutLeadingComments);
                },
                IsAdminCommand: function (command) {
                    var commandWithoutLeadingComments = { };
                    return Kusto.Data.IntelliSense.CslCommandParser.IsAdminCommand$1(command, commandWithoutLeadingComments);
                },
                IsStartingWithPrefix: function (query, prefix, queryWithoutLeadingComments) {
                    queryWithoutLeadingComments.v = query.trim();
                    var lines = System.String.split(query, System.Array.init(["\n"], System.String), null, 1);
                    for (var i = 0; i < lines.length; i = (i + 1) | 0) {
                        var line = lines[System.Array.index(i, lines)];
                        if (System.String.startsWith(System.String.trimStart(line), prefix)) {
                            if (i > 0) {
                                queryWithoutLeadingComments.v = Bridge.toArray(System.Linq.Enumerable.from(lines).skip(i)).join("\n").trim();
                            }
                            return true;
                        }

                        if (!Kusto.Data.IntelliSense.CslCommandParser.s_isCommentLineRegex.isMatch(line)) {
                            if (i > 0) {
                                queryWithoutLeadingComments.v = Bridge.toArray(System.Linq.Enumerable.from(lines).skip(i)).join("\n").trim();
                            }
                            // If it is not a comment line - and it is not starting with dot - it is not a command
                            return false;
                        }
                    }

                    return false;
                },
                IsClientDirective: function (command, directiveWithoutLeadingComments) {
                    return Kusto.Data.IntelliSense.CslCommandParser.IsStartingWithPrefix(command, "#", directiveWithoutLeadingComments);
                }
            }
        },
        fields: {
            m_hashedCommands: null,
            m_rulesProvider: null
        },
        props: {
            Results: null
        },
        ctors: {
            ctor: function () {
                this.$initialize();
                this.Reset();
            }
        },
        methods: {
            Reset: function () {
                this.m_hashedCommands = new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.CslCommand))();
                this.Results = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommand)).ctor();
            },
            Parse: function (rulesProvider, text, parseMode) {
                var results = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommand)).ctor();

                // Check if previous parsing was done using other rules provider
                if (!Bridge.referenceEquals(this.m_rulesProvider, rulesProvider)) {
                    this.Reset();
                    this.m_rulesProvider = rulesProvider;
                }

                var parsedCommands = Kusto.Data.IntelliSense.CslCommandParser.CslCommandTokenizer.GetCommands(text);
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.CslCommand, parsedCommands)) {
                    // Go over current commands and see if update needed
                    for (var i = 0; i < parsedCommands.Count; i = (i + 1) | 0) {
                        var newCommand = parsedCommands.getItem(i);
                        newCommand.ParseMode = parseMode;

                        var wasFound = this.FetchFromCache(parseMode, newCommand);
                        if (!wasFound) {
                            var previousCandidate = (this.Results != null) ? System.Linq.Enumerable.from(this.Results).elementAtOrDefault(i, null) : null;
                            newCommand.ParseTokens(rulesProvider, parseMode, previousCandidate);
                        }
                        results.add(newCommand);
                    }
                }

                this.m_hashedCommands = System.Linq.Enumerable.from(Kusto.Cloud.Platform.Utils.ExtendedEnumerable.DistinctBy(Bridge.global.Kusto.Data.IntelliSense.CslCommand, System.String, results, $asm.$.Kusto.Data.IntelliSense.CslCommandParser.f4)).toDictionary($asm.$.Kusto.Data.IntelliSense.CslCommandParser.f4, $asm.$.Kusto.Data.IntelliSense.CslCommandParser.f5, System.String, Bridge.global.Kusto.Data.IntelliSense.CslCommand);
                this.Results = results;
                return results;
            },
            FetchFromCache: function (parseMode, newCommand) {
                var wasFound = false;
                var previouslyParsedCommand = { };
                if (this.m_hashedCommands.tryGetValue(newCommand.Text, previouslyParsedCommand)) {
                    if (previouslyParsedCommand.v.ParseMode === parseMode) {
                        // Command was already parsed and was not changed - use its parsed strings
                        newCommand.AcquireTokens(previouslyParsedCommand.v);
                        wasFound = true;
                    }
                }

                return wasFound;
            },
            Clone: function () {
                var parser = new Kusto.Data.IntelliSense.CslCommandParser();
                parser.m_hashedCommands = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(System.String, Bridge.global.Kusto.Data.IntelliSense.CslCommand, this.m_hashedCommands) ? new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.CslCommand))(this.m_hashedCommands) : new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.CslCommand))();
                parser.m_rulesProvider = this.m_rulesProvider;
                parser.Results = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.CslCommand, this.Results) ? System.Linq.Enumerable.from(this.Results).toList(Bridge.global.Kusto.Data.IntelliSense.CslCommand) : new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommand)).ctor();
                return parser;
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslCommandParser", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslCommandParser, {
        f1: function (t) {
            return t;
        },
        f2: function (f) {
            return f;
        },
        f3: function (f) {
            return (f || "") + "()";
        },
        f4: function (c) {
            return c.Text;
        },
        f5: function (c) {
            return c;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandParser.CslCommandTokenizer", {
        $kind: "nested class",
        statics: {
            methods: {
                GetCommands: function (text) {
                    var $t;
                    var result = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CslCommand)).ctor();
                    if (System.String.isNullOrEmpty(text)) {
                        return result;
                    }

                    var command = null;
                    var mode = 0;
                    var endOfStream = false;
                    var expectedNewLine = 0;
                    var chars = System.Linq.Enumerable.from(text).ToArray();
                    for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];
                        endOfStream = (i === ((chars.length - 1) | 0));
                        if (endOfStream) {
                            if (mode === 0) {
                                command = ($t = new Kusto.Data.IntelliSense.CslCommand(), $t.RelativeStart = i, $t);
                            }
                            mode = 2; // Force completion
                        }

                        switch (mode) {
                            case 0:  // Starting new command
                                command = ($t = new Kusto.Data.IntelliSense.CslCommand(), $t.RelativeStart = i, $t);
                                mode = 1;
                                break;
                            case 1:  // Collecting command, looking for first newline
                                if (ch === 13 || ch === 10) {
                                    expectedNewLine = ch;
                                    mode = 2;
                                }
                                break;
                            case 2: 
                                if (ch === expectedNewLine || endOfStream) {
                                    if (command != null) {
                                        // Command termination
                                        while (!endOfStream) {
                                            // Peek at next symbol
                                            if (chars[System.Array.index(((i + 1) | 0), chars)] === 13 || chars[System.Array.index(((i + 1) | 0), chars)] === 10) {
                                                i = (i + 1) | 0;
                                            } else {
                                                break; // exit 'while' that appends empty lines
                                            }
                                            endOfStream = (i === ((chars.length - 1) | 0));
                                        }
                                        var commandLength = (((i - command.RelativeStart) | 0) + 1) | 0;
                                        command.Text = text.substr(command.RelativeStart, commandLength);
                                        command.Length = commandLength;
                                        command.IsRunnable = !System.String.isNullOrWhiteSpace(command.Text);
                                        result.add(command);
                                    }
                                    mode = 0; // Clean new line
                                    command = null;
                                } else if (System.Char.isWhiteSpace(String.fromCharCode(ch))) {
                                    // stay in this mode
                                } else {
                                    mode = 1;
                                }
                                break;
                        }
                    }

                    return result;
                }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandToken", {
        inherits: [System.ICloneable],
        props: {
            AbsolutePositionBias: 0,
            Value: null,
            TokenKind: 0,
            AbsoluteStart: {
                get: function () {
                    return ((this.RelativeStart + this.AbsolutePositionBias) | 0);
                }
            },
            AbsoluteEnd: {
                get: function () {
                    return ((this.RelativeEnd + this.AbsolutePositionBias) | 0);
                }
            },
            RelativeStart: 0,
            Length: 0,
            RelativeEnd: {
                get: function () {
                    return ((this.RelativeStart + this.Length) | 0);
                }
            }
        },
        alias: ["clone", "System$ICloneable$clone"],
        ctors: {
            ctor: function (value, absolutePositionBias, tokenKind) {
                this.$initialize();
                this.Value = value;
                this.TokenKind = tokenKind;
                this.AbsolutePositionBias = absolutePositionBias;
            }
        },
        methods: {
            CompareTo: function (other) {
                if (other == null) {
                    return 1;
                }

                if (this.RelativeStart === other.RelativeStart) {
                    return 0;
                }

                return (this.RelativeStart < other.RelativeStart) ? -1 : 1;
            },
            clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.CslCommandToken(this.Value, this.AbsolutePositionBias, this.TokenKind), $t.RelativeStart = this.RelativeStart, $t.Length = this.Length, $t);
            },
            equals: function (obj) {
                var other = Bridge.as(obj, Kusto.Data.IntelliSense.CslCommandToken);
                if (other == null) {
                    return false;
                }

                return Bridge.referenceEquals(this.Value, other.Value) && this.TokenKind === other.TokenKind && this.RelativeStart === other.RelativeStart && this.RelativeEnd === other.RelativeEnd && this.AbsolutePositionBias === other.AbsolutePositionBias;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.Value) ^ Bridge.getHashCode(this.TokenKind) ^ this.RelativeStart ^ this.RelativeEnd ^ this.AbsolutePositionBias;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslCommandToken.Kind", {
        $kind: "nested enum",
        statics: {
            fields: {
                TableToken: 2,
                TableColumnToken: 4,
                OperatorToken: 8,
                SubOperatorToken: 16,
                CalculatedColumnToken: 32,
                StringLiteralToken: 64,
                FunctionNameToken: 128,
                UnknownToken: 256,
                CommentToken: 512,
                PlainTextToken: 1024,
                DataTypeToken: 2048,
                ControlCommandToken: 4096,
                CommandPartToken: 8192,
                QueryParametersToken: 16384,
                CslCommandToken: 32768,
                LetVariablesToken: 65536,
                PluginToken: 131072,
                BracketRangeToken: 262144,
                ClientDirectiveToken: 524288,
                IsRecognizedEntity: 536870912,
                IsMismatchedTokenValue: 1073741824
            }
        },
        $flags: true
    });

    Bridge.define("Kusto.Data.IntelliSense.CslDocumentation", {
        statics: {
            fields: {
                s_instance: null
            },
            props: {
                Instance: {
                    get: function () {
                        if (Kusto.Data.IntelliSense.CslDocumentation.s_instance == null) {
                            Kusto.Data.IntelliSense.CslDocumentation.s_instance = new Kusto.Data.IntelliSense.CslDocumentation();
                            Kusto.Data.IntelliSense.CslDocumentation.s_instance.Initialize();
                        }
                        return Kusto.Data.IntelliSense.CslDocumentation.s_instance;
                    }
                }
            }
        },
        fields: {
            m_documentation: null
        },
        props: {
            Topics: {
                get: function () {
                    if (this.m_documentation == null) {
                        return System.Linq.Enumerable.empty();
                    }

                    return System.Linq.Enumerable.from(this.m_documentation).select($asm.$.Kusto.Data.IntelliSense.CslDocumentation.f1);
                }
            }
        },
        ctors: {
            init: function () {
                this.m_documentation = new (System.Collections.Generic.Dictionary$2(System.Object,Kusto.Data.IntelliSense.CslTopicDocumentation))();
            }
        },
        methods: {
            AddTopic: function (topic) {
                var key = { Item1: topic.TokenKind, Item2: topic.Name };
                this.m_documentation.set(key, topic);
            },
            GetTopic: function (option) {
                if (option.Kind === Kusto.Data.IntelliSense.OptionKind.Operator) {
                    return this.GetTopic$1(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, option.Value);
                } else if (option.Kind === Kusto.Data.IntelliSense.OptionKind.FunctionAggregation || option.Kind === Kusto.Data.IntelliSense.OptionKind.FunctionScalar) {
                    return this.GetTopic$1(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, System.String.trim(option.Value, [40, 41]));
                }

                return null;
            },
            GetTopic$1: function (tokenKind, name) {
                var key = { Item1: tokenKind, Item2: name };
                var result = { };
                this.m_documentation.tryGetValue(key, result);
                return result.v;
            },
            equals: function (obj) {
                if (obj == null) {
                    return false;
                }

                var other = Bridge.as(obj, Kusto.Data.IntelliSense.CslDocumentation);
                if (other == null) {
                    return false;
                }

                if (this.m_documentation.count !== other.m_documentation.count) {
                    return false;
                }

                if (System.Linq.Enumerable.from(other.m_documentation).except(this.m_documentation).any()) {
                    return false;
                }

                if (System.Linq.Enumerable.from(this.m_documentation).except(other.m_documentation).any()) {
                    return false;
                }

                return true;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.m_documentation);
            },
            Initialize: function () {
                if (System.Linq.Enumerable.from(this.m_documentation).any()) {
                    return;
                }
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "!between", "Matches the input that is outside the inclusive range.", "Table1 | where Num1 !between (1 .. 10)\r\n    Table1 | where Time !between (datetime(2017-01-01) .. datetime(2017-01-01))\r\n\r\n`!between` can operate on any numeric, datetime, or timespan expression.\r\n \r\n**Syntax**\r\n\r\n*T* `|` `where` *expr* `!between` `(`*leftRange*` .. `*rightRange*`)`   \r\n \r\nIf *expr* expression is datetime - another syntactic sugar syntax is provided:\r\n\r\n*T* `|` `where` *expr* `!between` `(`*leftRangeDateTime*` .. `*rightRangeTimespan*`)`   \r\n\r\n**Arguments**\r\n\r\n* *T* - The tabular input whose records are to be matched.\r\n* *expr* - the expression to filter.\r\n* *leftRange* - expression of the left range (inclusive).\r\n* *rightRange* - expression of the rihgt range (inclusive).\r\n\r\n**Returns**\r\n\r\nRows in *T* for which the predicate of (*expr* < *leftRange* or *expr* > *rightRange*) evaluates to `true`.", "**Filtering numeric values using '!between' operator**  \r\n\r\n\r\n```\r\nrange x from 1 to 10 step 1\r\n| where x !between (5 .. 9)\r\n```\r\n\r\n|x|\r\n|---|\r\n|1|\r\n|2|\r\n|3|\r\n|4|\r\n|10|\r\n\r\n**Filtering datetime using 'between' operator**  \r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| where StartTime !between (datetime(2007-07-27) .. datetime(2007-07-30))\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|58590|\r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| where StartTime !between (datetime(2007-07-27) .. 3d)\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|58590|", "https://kusto.azurewebsites.net/docs/query/notbetweenoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "abs", "Calculates the absolute value of the input.", "**Syntax**\r\n\r\n`abs(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: An integer or real number, or a timespan value.\r\n\r\n**Returns**\r\n\r\n* Absolute value of x.", "", "https://kusto.azurewebsites.net/docs/query/abs-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "acos", "Returns the angle whose cosine is the specified number (the inverse operation of [`cos()`](cosfunction.md)) .", "**Syntax**\r\n\r\n`acos(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number in range [-1, 1].\r\n\r\n**Returns**\r\n\r\n* The value of the arc cosine of `x`\r\n* `null` if `x` < -1 or `x` > 1", "", "https://kusto.azurewebsites.net/docs/query/acosfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "ago", "Subtracts the given timespan from the current UTC clock time.", "ago(1h)\r\n    ago(1d)\r\n\r\nLike `now()`, this function can be used multiple times\r\nin a statement and the UTC clock time being referenced will be the same\r\nfor all instantiations.\r\n\r\n**Syntax**\r\n\r\n`ago(`*a_timespan*`)`\r\n\r\n**Arguments**\r\n\r\n* *a_timespan*: Interval to subtract from the current UTC clock time\r\n(`now()`).\r\n\r\n**Returns**\r\n\r\n`now() - a_timespan`", "All rows with a timestamp in the past hour:\r\n\r\n\r\n```\r\nT | where Timestamp > ago(1h)\r\n```", "https://kusto.azurewebsites.net/docs/query/agofunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "any", "Returns random non-empty value from the specified expression values.", "This is useful, for example, when some column has a large number of values\r\n(e.g., an \"error text\" column) and you want to sample that column once per a unique value of the compound group key.\r\n\r\nNote that there are *no guarantees* about which record will be returned; the algorithm for selecting\r\nthat record is undocumented and one should not assume it is stable.\r\n\r\n* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `any(` (*Expr* [`,` *Expr2* ...] | `*`) `)` ...\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Expr2* .. *ExprN*: Additional expressions that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nRandomly selects one row of the group and returns the value of the specified expression.\r\n\r\nWhen used used with a single parameter (single column) - `any()` will return a non-null value if such present.", "Show Random Continent:\r\n\r\n    Continents | summarize any(Continent)\r\n\r\n![alt text](./images/aggregations/any1.png \"any1\")\r\n\r\n\r\nShow all the details for a random row:\r\n\r\n    Continents | summarize any(*) \r\n\r\n![alt text](./images/aggregations/any2.png \"any2\")\r\n\r\n\r\nShow all the details for each random continent:\r\n\r\n   Continents | summarize any(*) by Continent\r\n\r\n![alt text](./images/aggregations/any3.png \"any3\")", "https://kusto.azurewebsites.net/docs/query/any-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "arg_max", "Finds a row in the group that maximises *ExprToMaximize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` [`(`*NameExprToMaximize* `,` *NameExprToReturn* [`,` ...] `)=`] `arg_max` `(`*ExprToMaximize*, `*` | *ExprToReturn*  [`,` ...]`)`\r\n\r\n**Arguments**\r\n\r\n* *ExprToMaximize*: Expression that will be used for aggregation calculation. \r\n* *ExprToReturn*: Expression that will be used for returning the value when *ExprToMaximize* is\r\n  maximum. Expression to return may be a wildcard (*) to return all columns of the input table.\r\n* *NameExprToMaximize*: An optional name for the result column representing *ExprToMaximize*.\r\n* *NameExprToReturn*: Additional optional names for the result columns representing *ExprToReturn*.\r\n\r\n**Returns**\r\n\r\nFinds a row in the group that maximises *ExprToMaximize*, and \r\nreturns the value of *ExprToReturn* (or `*` to return the entire row).", "See examples for [arg_min()](arg-min-aggfunction.md) aggregation function", "https://kusto.azurewebsites.net/docs/query/arg-max-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "arg_min", "Finds a row in the group that minimizes *ExprToMinimize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` [`(`*NameExprToMinimize* `,` *NameExprToReturn* [`,` ...] `)=`] `arg_min` `(`*ExprToMinimize*, `*` | *ExprToReturn*  [`,` ...]`)`\r\n\r\n**Arguments**\r\n\r\n* *ExprToMinimize*: Expression that will be used for aggregation calculation. \r\n* *ExprToReturn*: Expression that will be used for returning the value when *ExprToMinimize* is\r\n  minimum. Expression to return may be a wildcard (*) to return all columns of the input table.\r\n* *NameExprToMinimize*: An optional name for the result column representing *ExprToMinimize*.\r\n* *NameExprToReturn*: Additional optional names for the result columns representing *ExprToReturn*.\r\n\r\n**Returns**\r\n\r\nFinds a row in the group that minimizes *ExprToMinimize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "Show cheapest supplier of each product:\r\n\r\n    Supplies | summarize arg_min(Price, Supplier) by Product\r\n\r\nShow all the details, not just the supplier name:\r\n\r\n    Supplies | summarize arg_min(Price, *) by Product\r\n\r\nFind the southernmost city in each continent, with its country:\r\n\r\n    PageViewLog \r\n    | summarize (latitude, min_lat_City, min_lat_country)=arg_min(latitude, City, country) \r\n      by continent\r\n\r\n![alt text](./images/aggregations/argmin.png \"argmin\")\r\n \r\n **Notes**\r\n\r\nWhen using a wildcard (`*`) as *ExprToReturn*, it is **strongly recommended** that\r\nthe input to the `summarize` operator will be restricted to include only the columns\r\nthat are used following that operator, as the optimization rule to automatically \r\nproject-away such columns is currently not implemented. In other words, make sure\r\nto introduce a projection similar to the marked line below:\r\n\r\n<!--- csl --->\r\n```\r\ndatatable(a:string, b:string, c:string, d:string) [...]\r\n| project a, b, c // <-- Add this projection to remove d\r\n| summarize arg_min(a, *)\r\n| project B=b, C=c\r\n```", "https://kusto.azurewebsites.net/docs/query/arg-min-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "argmax", "Finds a row in the group that maximises *ExprToMaximize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` [`(`*NameExprToMaximize* `,` *NameExprToReturn* [`,` ...] `)=`] `argmax` `(`*ExprToMaximize*, `*` | *ExprToReturn*  [`,` ...]`)`\r\n\r\n**Arguments**\r\n\r\n* *ExprToMaximize*: Expression that will be used for aggregation calculation. \r\n* *ExprToReturn*: Expression that will be used for returning the value when *ExprToMaximize* is\r\n  maximum. Expression to return may be a wildcard (*) to return all columns of the input table.\r\n* *NameExprToMaximize*: An optional name for the result column representing *ExprToMaximize*.\r\n* *NameExprToReturn*: Additional optional names for the result columns representing *ExprToReturn*.\r\n\r\n**Returns**\r\n\r\nFinds a row in the group that maximises *ExprToMaximize*, and \r\nreturns the value of *ExprToReturn* (or `*` to return the entire row).", "See examples for [argmin()](argmin-aggfunction.md) aggregation function\r\n\r\n**Notes**\r\n\r\nWhen using a wildcard (`*`) as *ExprToReturn*, it is **strongly recommended** that\r\nthe input to the `summarize` operator will be restricted to include only the columns\r\nthat are used following that operator, as the optimization rule to automatically \r\nproject-away such columns is currently not implemented. In other words, make sure\r\nto introduce a projection similar to the marked line below:\r\n\r\n<!--- csl --->\r\n```\r\ndatatable(a:string, b:string, c:string, d:string) [...]\r\n| project a, b, c // <-- Add this projection to remove d\r\n| summarize argmax(a, *)\r\n| project B=max_a_b, C=max_a_c\r\n```", "https://kusto.azurewebsites.net/docs/query/argmax-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "argmin", "Finds a row in the group that minimizes *ExprToMinimize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` [`(`*NameExprToMinimize* `,` *NameExprToReturn* [`,` ...] `)=`] `argmin` `(`*ExprToMinimize*, `*` | *ExprToReturn*  [`,` ...]`)`\r\n\r\n**Arguments**\r\n\r\n* *ExprToMinimize*: Expression that will be used for aggregation calculation. \r\n* *ExprToReturn*: Expression that will be used for returning the value when *ExprToMinimize* is\r\n  minimum. Expression to return may be a wildcard (*) to return all columns of the input table.\r\n* *NameExprToMinimize*: An optional name for the result column representing *ExprToMinimize*.\r\n* *NameExprToReturn*: Additional optional names for the result columns representing *ExprToReturn*.\r\n\r\n**Returns**\r\n\r\nFinds a row in the group that minimizes *ExprToMinimize*, and returns the value of *ExprToReturn* (or `*` to return the entire row).", "Show cheapest supplier of each product:\r\n\r\n    Supplies | summarize argmin(Price, Supplier) by Product\r\n\r\nShow all the details, not just the supplier name:\r\n\r\n    Supplies | summarize argmin(Price, *) by Product\r\n\r\nFind the southernmost city in each continent, with its country:\r\n\r\n    PageViewLog \r\n    | summarize (latitude, City, country)=argmin(latitude, City, country) \r\n      by continent\r\n\r\n![alt text](./images/aggregations/argmin.png \"argmin\")\r\n \r\n **Notes**\r\n\r\nWhen using a wildcard (`*`) as *ExprToReturn*, it is **strongly recommended** that\r\nthe input to the `summarize` operator will be restricted to include only the columns\r\nthat are used following that operator, as the optimization rule to automatically \r\nproject-away such columns is currently not implemented. In other words, make sure\r\nto introduce a projection similar to the marked line below:\r\n\r\n<!--- csl --->\r\n```\r\ndatatable(a:string, b:string, c:string, d:string) [...]\r\n| project a, b, c // <-- Add this projection to remove d\r\n| summarize argmin(a, *)\r\n| project B=max_a_b, C=max_a_c\r\n```", "https://kusto.azurewebsites.net/docs/query/argmin-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "array_concat", "Concatenates a number of dynamic arrays to a single array.", "**Syntax**\r\n\r\n`array_concat(`*arr1*`[`,` *arr2*, ...]`)`\r\n\r\n**Arguments**\r\n\r\n* *arr1...arrN*: Input arrays to be concatenated into a dynamic array. All arguments must be dynamic arrays (see [pack_array](packarrayfunction.md)). \r\n\r\n**Returns**\r\n\r\nDynamic array of arrays with arr1, arr2, ... , arrN.", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| extend a1 = pack_array(x,y,z), a2 = pack_array(x, y)\r\n| project array_concat(a1, a2)\r\n```\r\n\r\n|Column1|\r\n|---|\r\n|[1,2,4,1,2]|\r\n|[2,4,8,2,4]|\r\n|[3,6,12,3,6]|", "https://kusto.azurewebsites.net/docs/query/arrayconcatfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "array_length", "Calculates the number of elements in a dynamic array.", "**Syntax**\r\n\r\n`array_length(`*array*`)`\r\n\r\n**Arguments**\r\n\r\n* *array*: A `dynamic` value.\r\n\r\n**Returns**\r\n\r\nThe number of elements in *array*, or `null` if *array* is not an array.", "```\r\nprint array_length(parsejson('[1, 2, 3, \"four\"]')) == 4\r\n\r\nprint array_length(parsejson('[8]')) == 1\r\n\r\nprint array_length(parsejson('[{}]')) == 1\r\n\r\nprint array_length(parsejson('[]')) == 0\r\n\r\nprint array_length(parsejson('{}')) == null\r\n\r\nprint array_length(parsejson('21')) == null\r\n```", "https://kusto.azurewebsites.net/docs/query/arraylengthfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "As", "`As` operator temporarily binds a name to the operator's input tabular expression.", "**Syntax**\r\n\r\n`T | as *name*`\r\n\r\n**Arguments**\r\n\r\n* *T*: A tabular expression.\r\n* *name*: A temporary name for the tabular expression. \r\n\r\n**Notes**\r\n* The name given by `as` will be used in the `withsource=` column of [union](./unionoperator.md), the `source-` column of [find](./findoperator.md) and the `$table` column of [search](./searchoperator.md)\r\n* The tabular expression named using 'as' in a [join](./joinoperator.md)'s 'left side' can be used when the [join](./joinoperator.md)'s 'right side'", "```\r\n// 1. In the following 2 example the union's generated TableName column will consist of 'T1' and 'T2'\r\nrange x from 1 to 10 step 1 \r\n| as T1 \r\n| union withsource=TableName T2\r\n\r\nunion withsource=TableName (range x from 1 to 10 step 1 | as T1), T2\r\n\r\n// 2. In the following example, the 'left side' of the join will be: \r\n//      MyLogTable filtered by type == \"Event\" and Name == \"Start\"\r\n//    and the 'right side' of the join will be: \r\n//      MyLogTable filtered by type == \"Event\" and Name == \"Stop\"\r\nMyLogTable  \r\n| where type == \"Event\"\r\n| as T\r\n| where Name == \"Start\"\r\n| join (\r\n    T\r\n    | where Name == \"Stop\"\r\n) on ActivityId\r\n```", "https://kusto.azurewebsites.net/docs/query/asoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "asin", "Returns the angle whose sine is the specified number (the inverse operation of [`sin()`](sinfunction.md)) .", "**Syntax**\r\n\r\n`asin(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number in range [-1, 1].\r\n\r\n**Returns**\r\n\r\n* The value of the arc sine of `x`\r\n* `null` if `x` < -1 or `x` > 1", "", "https://kusto.azurewebsites.net/docs/query/asinfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "atan", "Returns the angle whose tangent is the specified number (the inverse operation of [`tan()`](tanfunction.md)) .", "**Syntax**\r\n\r\n`atan(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The value of the arc tangent of `x`", "", "https://kusto.azurewebsites.net/docs/query/atanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "atan2", "Calculates the angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x).", "**Syntax**\r\n\r\n`atan2(`*y*`,`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: X coordinate (a real number).\r\n* *y*: Y coordinate (a real number).\r\n\r\n**Returns**\r\n\r\n* The angle, in radians, between the positive x-axis and the ray from the origin to the point (y, x).", "```\r\nprint atan2_0 = atan2(1,1) // Pi / 4 radians (45 degrees)\r\n| extend atan2_1 = atan2(0,-1) // Pi radians (180 degrees)\r\n| extend atan2_2 = atan2(-1,0) // - Pi / 2 radians (-90 degrees)\r\n\r\n```\r\n\r\n|atan2_0|atan2_1|atan2_2|\r\n|---|---|---|\r\n|0.785398163397448|3.14159265358979|-1.5707963267949|", "https://kusto.azurewebsites.net/docs/query/atan2function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "avg", "Calculates the average of *Expr* across the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `avg(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe average value of *Expr* across the group.", "", "https://kusto.azurewebsites.net/docs/query/avg-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "avgif", "Calculates the [average](avg-aggfunction.md) of *Expr* across the group for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `avgif(`*Expr*`, `*Predicate*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Predicate*:  predicate that if true, the *Expr* calculated value will be added to the average.\r\n\r\n**Returns**\r\n\r\nThe average value of *Expr* across the group where *Predicate* evaluates to `true`.", "```\r\nrange x from 1 to 100 step 1\r\n| summarize avgif(x, x%2 == 0)\r\n```\r\n\r\n|avgif_x|\r\n|---|\r\n|51|", "https://kusto.azurewebsites.net/docs/query/avgif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "base64_decodestring", "Decodes a base64 string to a UTF-8 string", "**Syntax**\r\n\r\n`base64_decodestring(`*String*`)`\r\n\r\n**Arguments**\r\n\r\n* *String*: Input string to be decoded from base64 to UTF8-8 string.\r\n\r\n**Returns**\r\n\r\nReturns UTF-8 string decoded from base64 string.", "```\r\nprint Quine=base64_decodestring(\"S3VzdG8=\")\r\n```\r\n\r\n|Quine|\r\n|-----|\r\n|Kusto|\r\n\r\nTrying to decode a base64 string which was generated from invalid UTF-8 encoding will return null:\r\n\r\n\r\n```\r\nprint Empty=base64_decodestring(\"U3RyaW5n0KHR0tGA0L7Rh9C60LA=\")\r\n```\r\n\r\n|Empty|\r\n|-----|\r\n||", "https://kusto.azurewebsites.net/docs/query/base64decodestringfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "base64_encodestring", "Encodes a string as base64 string", "**Syntax**\r\n\r\n`base64_encodestring(`*String*`)`\r\n\r\n**Arguments**\r\n\r\n* *String*: Input string to be encoded as base64 string.\r\n\r\n\r\n**Returns**\r\n\r\nReturns the string encoded as base64 string.", "```\r\nprint Quine=base64_encodestring(\"Kusto\")\r\n```\r\n\r\n|Quine   |\r\n|--------|\r\n|S3VzdG8=|", "https://kusto.azurewebsites.net/docs/query/base64encodestringfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "beta_cdf", "Returns the standard cumulative beta distribution function.", "beta_cdf(0.2, 10.0, 50.0)\r\n\r\nIf probability = beta_cdf(x,...), then beta_inv(probability,...) = x. \r\n\r\nThe beta distribution is commonly used to study variation in the percentage of something across samples, such as the fraction of the day people spend watching television.\r\n\r\n**Syntax**\r\n\r\n`beta_cdf(`*x*`, `*alpha*`, `*beta*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A value at which to evaluate the function.\r\n* *alpha*: A parameter of the distribution.\r\n* *beta*: A parameter of the distribution.\r\n\r\n**Returns**\r\n\r\n* The [cumulative beta distribution function](https://en.wikipedia.org/wiki/Beta_distribution#Cumulative_distribution_function).\r\n\r\n**Remarks**\r\n\r\nIf any argument is nonnumeric, beta_cdf() returns null value.\r\n\r\nIf x < 0 or x > 1, beta_cdf() returns NaN value.\r\n\r\nIf alpha â¤ 0 or beta â¤ 0, beta_cdf() returns the NaN value.", "```\r\ndatatable(x:double, alpha:double, beta:double, comment:string)\r\n[\r\n    0.9, 10.0, 20.0, \"Valid input\",\r\n    1.5, 10.0, 20.0, \"x > 1, yields NaN\",\r\n    double(-10), 10.0, 20.0, \"x < 0, yields NaN\",\r\n    0.1, double(-1.0), 20.0, \"alpha is < 0, yields NaN\"\r\n]\r\n| extend b = beta_cdf(x, alpha, beta)\r\n```\r\n\r\n|x|alpha|beta|comment|b|\r\n|---|---|---|---|---|\r\n|0.9|10|20|Valid input|0.999999999999959|\r\n|1.5|10|20|x > 1, yields NaN|NaN|\r\n|-10|10|20|x < 0, yields NaN|NaN|\r\n|0.1|-1|20|alpha is < 0, yields NaN|NaN|\r\n\r\n\r\n**See also**\r\n\r\n\r\n* For computing the inverse of the beta cumulative probability density function, see [beta-inv()](./beta-invfunction.md).\r\n* For computing probability density function, see [beta-pdf()](./beta-pdffunction.md).", "https://kusto.azurewebsites.net/docs/query/beta-cdffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "beta_inv", "Returns the inverse of the beta cumulative probability beta density function.", "beta_inv(0.1, 10.0, 50.0)\r\n\r\nIf probability = beta_cdf(x,...), then beta_inv(probability,...) = x. \r\n\r\nThe beta distribution can be used in project planning to model probable completion times given an expected completion time and variability.\r\n\r\n**Syntax**\r\n\r\n`beta_inv(`*probability*`, `*alpha*`, `*beta*`)`\r\n\r\n**Arguments**\r\n\r\n* *probability*: A probability associated with the beta distribution.\r\n* *alpha*: A parameter of the distribution.\r\n* *beta*: A parameter of the distribution.\r\n\r\n**Returns**\r\n\r\n* The inverse of the beta cumulative probability density function [beta_cdf()](./beta-cdffunction.md)\r\n\r\n**Remarks**\r\n\r\nIf any argument is nonnumeric, beta_inv() returns null value.\r\n\r\nIf alpha â¤ 0 or beta â¤ 0, beta_inv() returns the null value.\r\n\r\nIf probability â¤ 0 or probability > 1, beta_inv() returns the NaN value.\r\n\r\nGiven a value for probability, beta_inv() seeks that value x such that beta_cdf(x, alpha, beta) = probability.", "```\r\ndatatable(p:double, alpha:double, beta:double, comment:string)\r\n[\r\n    0.1, 10.0, 20.0, \"Valid input\",\r\n    1.5, 10.0, 20.0, \"p > 1, yields null\",\r\n    0.1, double(-1.0), 20.0, \"alpha is < 0, yields NaN\"\r\n]\r\n| extend b = beta_inv(p, alpha, beta)\r\n```\r\n\r\n|p|alpha|beta|comment|b|\r\n|---|---|---|---|---|\r\n|0.1|10|20|Valid input|0.226415022388749|\r\n|1.5|10|20|p > 1, yields null||\r\n|0.1|-1|20|alpha is < 0, yields NaN|NaN|\r\n\r\n**See also**\r\n\r\n* For computing cumulative beta distribution function, see [beta-cdf()](./beta-cdffunction.md).\r\n* For computing probability beta density function, see [beta-pdf()](./beta-pdffunction.md).", "https://kusto.azurewebsites.net/docs/query/beta-invfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "beta_pdf", "Returns the probability density beta function.", "beta_pdf(0.2, 10.0, 50.0)\r\n\r\nThe beta distribution is commonly used to study variation in the percentage of something across samples, such as the fraction of the day people spend watching television.\r\n\r\n**Syntax**\r\n\r\n`beta_pdf(`*x*`, `*alpha*`, `*beta*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A value at which to evaluate the function.\r\n* *alpha*: A parameter of the distribution.\r\n* *beta*: A parameter of the distribution.\r\n\r\n**Returns**\r\n\r\n* The [probability beta density function](https://en.wikipedia.org/wiki/Beta_distribution#Probability_density_function).\r\n\r\n**Remarks**\r\n\r\nIf any argument is nonnumeric, beta_pdf() returns null value.\r\n\r\nIf x â¤ 0 or 1 â¤ x, beta_pdf() returns NaN value.\r\n\r\nIf alpha â¤ 0 or beta â¤ 0, beta_pdf() returns the NaN value.", "```\r\ndatatable(x:double, alpha:double, beta:double, comment:string)\r\n[\r\n    0.5, 10.0, 20.0, \"Valid input\",\r\n    1.5, 10.0, 20.0, \"x > 1, yields NaN\",\r\n    double(-10), 10.0, 20.0, \"x < 0, yields NaN\",\r\n    0.1, double(-1.0), 20.0, \"alpha is < 0, yields NaN\"\r\n]\r\n| extend r = beta_pdf(x, alpha, beta)\r\n```\r\n\r\n|x|alpha|beta|comment|r|\r\n|---|---|---|---|---|\r\n|0.5|10|20|Valid input|0.746176019310951|\r\n|1.5|10|20|x > 1, yields NaN|NaN|\r\n|-10|10|20|x < 0, yields NaN|NaN|\r\n|0.1|-1|20|alpha is < 0, yields NaN|NaN|\r\n\r\n**See also**\r\n\r\n* For computing the inverse of the beta cumulative probability density function, see [beta-inv()](./beta-invfunction.md).\r\n* For the standard cumulative beta distribution function, see [beta-cdf()](./beta-cdffunction.md).", "https://kusto.azurewebsites.net/docs/query/beta-pdffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "between", "Matches the input that is inside the inclusive range.", "Table1 | where Num1 between (1 .. 10)\r\n    Table1 | where Time between (datetime(2017-01-01) .. datetime(2017-01-01))\r\n\r\n`between` can operate on any numeric, datetime, or timespan expression.\r\n \r\n**Syntax**\r\n\r\n*T* `|` `where` *expr* `between` `(`*leftRange*` .. `*rightRange*`)`   \r\n \r\nIf *expr* expression is datetime - another syntactic sugar syntax is provided:\r\n\r\n*T* `|` `where` *expr* `between` `(`*leftRangeDateTime*` .. `*rightRangeTimespan*`)`   \r\n\r\n**Arguments**\r\n\r\n* *T* - The tabular input whose records are to be matched.\r\n* *expr* - the expression to filter.\r\n* *leftRange* - expression of the left range (inclusive).\r\n* *rightRange* - expression of the rihgt range (inclusive).\r\n\r\n**Returns**\r\n\r\nRows in *T* for which the predicate of (*expr* >= *leftRange* and *expr* <= *rightRange*) evaluates to `true`.", "**Filtering numeric values using 'between' operator**  \r\n\r\n\r\n```\r\nrange x from 1 to 100 step 1\r\n| where x between (50 .. 55)\r\n```\r\n\r\n|x|\r\n|---|\r\n|50|\r\n|51|\r\n|52|\r\n|53|\r\n|54|\r\n|55|\r\n\r\n**Filtering datetime using 'between' operator**  \r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| where StartTime between (datetime(2007-07-27) .. datetime(2007-07-30))\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|476|\r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| where StartTime between (datetime(2007-07-27) .. 3d)\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|476|", "https://kusto.azurewebsites.net/docs/query/betweenoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "bin", "Rounds values down to an integer multiple of a given bin size.", "Used a lot in the [`summarize by ...`](./summarizeoperator.md) query. \r\nIf you have a scattered set of values, they will be grouped into a smaller set of specific values.\r\n\r\nAlias to `floor()` function.\r\n\r\n**Syntax**\r\n\r\n`bin(`*value*`,`*roundTo*`)`\r\n\r\n**Arguments**\r\n\r\n* *value*: A number, date, or timespan. \r\n* *roundTo*: The \"bin size\". A number, date or timespan that divides *value*. \r\n\r\n**Returns**\r\n\r\nThe nearest multiple of *roundTo* below *value*.  \r\n \r\n `(toint((value/roundTo))) * roundTo`", "Expression | Result\r\n---|---\r\n`bin(4.5, 1)` | `4.0`\r\n`bin(time(16d), 7d)` | `14d`\r\n`bin(datetime(1970-05-11 13:45:07), 1d)`|  `datetime(1970-05-11)`\r\n\r\n\r\nThe following expression calculates a histogram of durations,\r\nwith a bucket size of 1 second:\r\n\r\n\r\n```\r\nT | summarize Hits=count() by bin(Duration, 1s)\r\n```", "https://kusto.azurewebsites.net/docs/query/binfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "bin_at", "Rounds values down to a fixed-size \"bin\", with control over the bin's starting point.\r\n(See also [`bin function`](./binfunction.md).)", "**Syntax**\r\n\r\n`bin_at` `(`*Expression*`,` *BinSize*`, ` *FixedPoint*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expression*: A scalar expression of a numeric type (including `datetime` and `timespan`)\r\n  indicating the value to round.\r\n* *BinSize*: A scalar constant of the same type as *Expression* indicating\r\n  the size of each bin. \r\n* *FixedPoint*: A scalar constant of the same type as *Expression* indicating\r\n  one value of *Expression* which is a \"fixed point\" (that is, a value `fixed_point`\r\n  for which `bin_at(fixed_point, bin_size, fixed_point) == fixed_point`.)\r\n\r\n**Returns**\r\n\r\nThe nearest multiple of *BinSize* below *Expression*, shifted so that *FixedPoint*\r\nwill be translated into itself.", "|Expression                                                                    |Result                           |Comments                   |\r\n|------------------------------------------------------------------------------|---------------------------------|---------------------------|\r\n|`bin_at(6.5, 2.5, 7)`                                                         |`4.5`                            ||\r\n|`bin_at(time(1h), 1d, 12h)`                                                   |`-12h`                           ||\r\n|`bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0))`|`datetime(2017-05-14 12:00:00.0)`|All bins will be at noon   |\r\n|`bin_at(datetime(2017-05-17 10:20:00.0), 7d, datetime(2017-06-04 00:00:00.0))`|`datetime(2017-05-14 00:00:00.0)`|All bins will be on Sundays|\r\n\r\n\r\nIn the following example, notice that the `\"fixed point\"` arg is returned as one of the bins and the other bins are aligned to it based on the `bin_size`. Also note that each datetime bin represents the starting time of that bin:\r\n\r\n\r\n```\r\n\r\ndatatable(Date:datetime, Num:int)[\r\ndatetime(2018-02-24T15:14),3,\r\ndatetime(2018-02-23T16:14),4,\r\ndatetime(2018-02-26T15:14),5]\r\n| summarize sum(Num) by bin_at(Date, 1d, datetime(2018-02-24 15:14:00.0000000)) \r\n\r\n\r\n```\r\n\r\n|Date|sum_Num|\r\n|---|---|\r\n|2018-02-23 15:14:00.0000000|4|\r\n|2018-02-24 15:14:00.0000000|3|\r\n|2018-02-26 15:14:00.0000000|5|", "https://kusto.azurewebsites.net/docs/query/binatfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "bin_auto", "Rounds values down to a fixed-size \"bin\", with control over the bin size and starting point provided by a query property.", "**Syntax**\r\n\r\n`bin_auto` `(` *Expression* `)`\r\n\r\n**Arguments**\r\n\r\n* *Expression*: A scalar expression of a numeric type indicating the value to round.\r\n\r\n**Client Request Properties**\r\n\r\n* `query_bin_auto_size`: A numeric literal indicating the size of each bin.\r\n* `query_bin_auto_at`: A numeric literal indicating one value of *Expression* which is a \"fixed point\" (that is, a value `fixed_point`\r\n  for which `bin_auto(fixed_point)` == `fixed_point`.)\r\n\r\n**Returns**\r\n\r\nThe nearest multiple of `query_bin_auto_at` below *Expression*, shifted so that `query_bin_auto_at`\r\nwill be translated into itself.", "```\r\nset query_bin_auto_size=1h;\r\nset query_bin_auto_at=datetime(2017-01-01 00:05);\r\nrange Timestamp from datetime(2017-01-01 00:05) to datetime(2017-01-01 02:00) step 1m\r\n| summarize count() by bin_auto(Timestamp)\r\n```\r\n\r\n|Timestamp                    | count_|\r\n|-----------------------------|-------|\r\n|2017-01-01 00:05:00.0000000  | 60    |\r\n|2017-01-01 01:05:00.0000000  | 56    |", "https://kusto.azurewebsites.net/docs/query/bin-autofunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_and", "Returns a result of the bitwise `and` operation between two values", "binary_and(x,y)\t\r\n\r\n**Syntax**\r\n\r\n`binary_and(`*num1*`,` *num2* `)`\r\n\r\n**Arguments**\r\n\r\n* *num1*, *num2*: long numbers.\r\n\r\n**Returns**\r\n\r\nReturns logical AND operation on a pair of numbers: num1 & num2.", "", "https://kusto.azurewebsites.net/docs/query/binary-andfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_not", "Returns a bitwise negation of the input value.", "binary_not(x)\r\n\r\n**Syntax**\r\n\r\n`binary_not(`*num1*`)`\r\n\r\n**Arguments**\r\n\r\n* *num1*: numeric \r\n\r\n**Returns**\r\n\r\nReturns logical NOT operation on a number: num1.", "", "https://kusto.azurewebsites.net/docs/query/binary-notfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_or", "Returns a result of the bitwise `or` operation of the two values", "binary_or(x,y)\r\n\r\n**Syntax**\r\n\r\n`binary_or(`*num1*`,` *num2* `)`\r\n\r\n**Arguments**\r\n\r\n* *num1*, *num2*: long numbers.\r\n\r\n**Returns**\r\n\r\nReturns logical OR operation on a pair of numbers: num1 | num2.", "", "https://kusto.azurewebsites.net/docs/query/binary-orfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_shift_left", "Returns binary shift left operation on a pair of numbers", "binary_shift_left(x,y)\t\r\n\r\n**Syntax**\r\n\r\n`binary_shift_left(`*num1*`,` *num2* `)`\r\n\r\n**Arguments**\r\n\r\n* *num1*, *num2*: int numbers.\r\n\r\n**Returns**\r\n\r\nReturns binary shift left operation on a pair of numbers: num1 << (num2%64).\r\nIf n is negative a NULL value is returned.", "", "https://kusto.azurewebsites.net/docs/query/binary-shift-leftfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_shift_right", "eturns binary shift right operation on a pair of numbers", "binary_shift_right(x,y)\t\r\n\r\n**Syntax**\r\n\r\n`binary_shift_right(`*num1*`,` *num2* `)`\r\n\r\n**Arguments**\r\n\r\n* *num1*, *num2*: long numbers.\r\n\r\n**Returns**\r\n\r\nReturns binary shift right operation on a pair of numbers: num1 >> (num2%64).\r\nIf n is negative a NULL value is returned.", "", "https://kusto.azurewebsites.net/docs/query/binary-shift-rightfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "binary_xor", "Returns a result of the bitwise `xor` operation of the two values", "binary_xor(x,y)\r\n\t\r\n**Syntax**\r\n\r\n`binary_xor(`*num1*`,` *num2* `)`\r\n\r\n**Arguments**\r\n\r\n* *num1*, *num2*: long numbers.\r\n\r\n**Returns**\r\n\r\nReturns logical XOR operation on a pair of numbers: num1 ^ num2.", "", "https://kusto.azurewebsites.net/docs/query/binary-xorfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "buildschema", "Returns the minimal schema that admits all values of *DynamicExpr*.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `buildschema(`*DynamicExpr*`)`\r\n\r\n**Arguments**\r\n\r\n* *DynamicExpr*: Expression that will be used for aggregation calculation. The parameter column type should be `dynamic`. \r\n\r\n**Returns**\r\n\r\nThe maximum value of *Expr* across the group.\r\n\r\n**Tip** \r\nIf `buildschema(json_column)` gives a syntax error:\r\n*Is your `json_column` a string rather than a dynamic object?* \r\nIf so, you need to use `buildschema(parsejson(json_column))`.", "Assume the input column has three dynamic values:\r\n\r\n||\r\n|---|\r\n|`{\"x\":1, \"y\":3.5}`|\r\n|`{\"x\":\"somevalue\", \"z\":[1, 2, 3]}`|\r\n|`{\"y\":{\"w\":\"zzz\"}, \"t\":[\"aa\", \"bb\"], \"z\":[\"foo\"]}`|\r\n||\r\n\r\nThe resulting schema would be:\r\n\r\n    { \r\n      \"x\":[\"int\", \"string\"], \r\n      \"y\":[\"double\", {\"w\": \"string\"}], \r\n      \"z\":{\"`indexer`\": [\"int\", \"string\"]}, \r\n      \"t\":{\"`indexer`\": \"string\"} \r\n    }\r\n\r\nThe schema tells us that:\r\n\r\n* The root object is a container with four properties named x, y, z and t.\r\n* The property called \"x\" that could be either of type \"int\" or of type \"string\".\r\n* The property called \"y\" that could of either of type \"double\", or another container with a property called \"w\" of type \"string\".\r\n* The ``indexer`` keyword indicates that \"z\" and \"t\" are arrays.\r\n* Each item in the array \"z\" is either an int or a string.\r\n* \"t\" is an array of strings.\r\n* Every property is implicitly optional, and any array may be empty.\r\n\r\n### Schema model\r\n\r\nThe syntax of the returned schema is:\r\n\r\n    Container ::= '{' Named-type* '}';\r\n    Named-type ::= (name | '\"`indexer`\"') ':' Type;\r\n\tType ::= Primitive-type | Union-type | Container;\r\n    Union-type ::= '[' Type* ']';\r\n    Primitive-type ::= \"int\" | \"string\" | ...;\r\n\r\nThey are equivalent to a subset of the TypeScript type annotations, encoded as a Kusto dynamic value. In Typescript, the example schema would be:\r\n\r\n    var someobject: \r\n    { \r\n      x?: (number | string), \r\n      y?: (number | { w?: string}), \r\n      z?: { [n:number] : (int | string)},\r\n      t?: { [n:number]: string } \r\n    }", "https://kusto.azurewebsites.net/docs/query/buildschema-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "case", "Evaluates a list of predicates and returns the first result expression whose predicate is satisfied.", "If neither of the predicates return `true`, the result of the last expression (the `else`) is returned.\r\nAll odd arguments (count starts at 1) must be expressions that evaluate to a  `boolean` value.\r\nAll even arguments (the `then`s) and the last argument (the `else`) must be of the same type.\r\n\r\n**Syntax**\r\n\r\n`case(`*predicate_1*`,` *then_1*,\r\n       *predicate_2*`,` *then_2*,\r\n       *predicate_3*`,` *then_3*,\r\n       *else*`)`\r\n\r\n**Arguments**\r\n\r\n* *predicate_i*: An expression that evaluates to a `boolean` value.\r\n* *then_i*: An expression that gets evaluated and its value is returned from the function if *predicate_i* is the first predicate that evaluates to `true`.\r\n* *else*: An expression that gets evaluated and its value is returned from the function if neither of the *predicate_i* evaluate to `true`.\r\n\r\n**Returns**\r\n\r\nThe value of the first *then_i* whose *predicate_i* evaluates to `true`, or the value of *else* if neither of the predicates are satisfied.", "```\r\nrange Size from 1 to 15 step 2\r\n| extend bucket = case(Size <= 3, \"Small\", \r\n                       Size <= 10, \"Medium\", \r\n                       \"Large\")\r\n```\r\n\r\n|Size|bucket|\r\n|---|---|\r\n|1|Small|\r\n|3|Small|\r\n|5|Medium|\r\n|7|Medium|\r\n|9|Medium|\r\n|11|Large|\r\n|13|Large|\r\n|15|Large|", "https://kusto.azurewebsites.net/docs/query/casefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "ceiling", "Calculates the smallest integer greater than, or equal to, the specified numeric expression.", "**Syntax**\r\n\r\n`ceiling(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The smallest integer greater than, or equal to, the specified numeric expression.", "```\r\nprint c1 = ceiling(-1.1), c2 = ceiling(0), c3 = ceiling(0.9)\r\n\r\n```\r\n\r\n|c1|c2|c3|\r\n|---|---|---|\r\n|-1|0|1|", "https://kusto.azurewebsites.net/docs/query/ceilingfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "cluster", "Changes the reference of the query to a remote cluster.", "cluster('help').database('Sample').SomeTable\r\n \r\n**Syntax**\r\n\r\n`cluster(`*stringConstant*`)`\r\n\r\n**Arguments**\r\n\r\n* *stringConstant*: Name of the cluster that is referenced. Cluster name can be either \r\nas fully qualified DNS name or as a stirng that will be suffixied with `.kusto.windows.net`. Argument has to be _constant_ prior of query execution, i.e. cannot come from sub-query evaluation.\r\n\r\n**Notes**\r\n\r\n* For accessing database within the same cluster - use [database()](databasefunction.md) function.\r\n* More information about cross-cluster and cross-database queries available [here](cross-cluster-or-database-queries.md)", "### Use cluster() to access remote cluster \r\n\r\nThe next query can be run on any of the Kusto clusters.\r\n\r\n\r\n```\r\ncluster('help').database('Samples').StormEvents | count\r\n\r\ncluster('help.kusto.windows.net').database('Samples').StormEvents | count  \r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use cluster() inside let statements \r\n\r\nThe same query as above can be rewritten to use inline function (let statement) that \r\nreceives a parameter `clusterName` - which is passed into the cluster() function.\r\n\r\n\r\n```\r\nlet foo = (clusterName:string)\r\n{\r\n    cluster(clusterName).database('Samples').StormEvents | count\r\n};\r\nfoo('help')\r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use cluster() inside Functions \r\n\r\nThe same query as above can be rewritten to be used in a function that \r\nreceives a parameter `clusterName` - which is passed into the cluster() function.\r\n\r\n\r\n```\r\n.create function foo(clusterName:string)\r\n{\r\n    cluster(clusterName).database('Samples').StormEvents | count\r\n};\r\n```\r\n\r\n**Note:** such functions can be used only locally and not in the cross-cluster query.", "https://kusto.azurewebsites.net/docs/query/clusterfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "coalesce", "Evaluates a list of expressions and returns the first non-null (or non-empty for string) expression.", "coalesce(tolong(\"not a number\"), tolong(\"42\"), 33) == 42\r\n\r\n**Syntax**\r\n\r\n`coalesce(`*expr_1*`, `*expr_2`, ...)\r\n\r\n**Arguments**\r\n\r\n* *expr_i*: A scalar expression, to be evaluated.\r\n\r\n- All arguments must be of the same type.\r\n- Maximum of 64 arguments is supported.\r\n\r\n\r\n**Returns**\r\n\r\nThe value of the first *expr_i* whose value is not null (or not-empty for string expressions).", "```\r\nprint result=coalesce(tolong(\"not a number\"), tolong(\"42\"), 33)\r\n```\r\n\r\n|result|\r\n|---|\r\n|42|", "https://kusto.azurewebsites.net/docs/query/coalescefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "consume", "Pulls all the data from its source tabular expression without actually doing anything with it.", "T | consume\r\n\r\nThe `consume` operator pulls all the data from its source tabular expression\r\nwithout actually doing anything with it. It can be used for estimating the\r\ncost of a query without actually delivering the results back to the client.\r\n(The estimation is not exact for a variety of reasons; for example, `consume`\r\nis calculated distributively, so `T | consume` will not even deliver the table's\r\ndata between the nodes of the cluster.)", "", "https://kusto.azurewebsites.net/docs/query/consumeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "cos", "Returns the cosine function.", "**Syntax**\r\n\r\n`cos(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The result of `cos(x)`", "", "https://kusto.azurewebsites.net/docs/query/cosfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "cot", "Calculates the trigonometric cotangent of the specified angle, in radians.", "**Syntax**\r\n\r\n`cot(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The cotangent function value for `x`", "", "https://kusto.azurewebsites.net/docs/query/cotfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "count", "Returns a count of the records per summarization group (or in total if summarization is done without grouping).", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n* Use the [countif](countif-aggfunction.md) aggregation function\r\n  to count only records for which some predicate returns `true`.\r\n\r\n**Syntax**\r\n\r\nsummarize `count()`\r\n\r\n**Returns**\r\n\r\nReturns a count of the records per summarization group (or in total if summarization is done without grouping).", "", "https://kusto.azurewebsites.net/docs/query/count-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "count", "Returns the number of records in the input record set.", "**Syntax**\r\n\r\n`T | count`\r\n\r\n**Arguments**\r\n\r\n* *T*: The tabular data whose records are to be counted.\r\n\r\n**Returns**\r\n\r\nThis function returns a table with a single record and column of type\r\n`long`. The value of the only cell is the number of records in *T*.", "```\r\nStormEvents | count\r\n```", "https://kusto.azurewebsites.net/docs/query/countoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "countif", "Returns a count of rows for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\nSee also - [count()](count-aggfunction.md) function, which counts rows without predicate expression.\r\n\r\n**Syntax**\r\n\r\nsummarize `countif(`*Predicate*`)`\r\n\r\n**Arguments**\r\n\r\n* *Predicate*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nReturns a count of rows for which *Predicate* evaluates to `true`.\r\n\r\n**Tip**\r\n\r\nUse `summarize countif(filter)` instead of `where filter | summarize count()`", "", "https://kusto.azurewebsites.net/docs/query/countif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "countof", "Counts occurrences of a substring in a string. Plain string matches may overlap; regex matches do not.", "countof(\"The cat sat on the mat\", \"at\") == 3\r\n    countof(\"The cat sat on the mat\", @\"\\b.at\\b\", \"regex\") == 3\r\n\r\n**Syntax**\r\n\r\n`countof(`*text*`,` *search* [`,` *kind*]`)`\r\n\r\n**Arguments**\r\n\r\n* *text*: A string.\r\n* *search*: The plain string or [regular expression](./re2.md) to match inside *text*.\r\n* *kind*: `\"normal\"|\"regex\"` Default `normal`. \r\n\r\n**Returns**\r\n\r\nThe number of times that the search string can be matched in the container. Plain string matches may overlap; regex matches do not.", "|||\r\n|---|---\r\n|`countof(\"aaa\", \"a\")`| 3 \r\n|`countof(\"aaaa\", \"aa\")`| 3 (not 2!)\r\n|`countof(\"ababa\", \"ab\", \"normal\")`| 2\r\n|`countof(\"ababa\", \"aba\")`| 2\r\n|`countof(\"ababa\", \"aba\", \"regex\")`| 1\r\n|`countof(\"abcabc\", \"a.c\", \"regex\")`| 2", "https://kusto.azurewebsites.net/docs/query/countoffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "current_principal", "Returns the current principal running this query.", "**Syntax**\r\n\r\n`current_principal()`\r\n\r\n**Returns**\r\n\r\nThe current principal FQN as a `string`.", "```\r\n.show queries | where Principal == current_principal()\r\n```", "https://kusto.azurewebsites.net/docs/query/current-principalfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "cursor_after", "A predicate over the records of a table to compare their ingestion time\r\nagainst a database cursor.", "**Syntax**\r\n\r\n`cursor_after` `(` *RHS* `)`\r\n\r\n**Arguments**\r\n\r\n* *RHS*: Either an empty string literal, or a valid database cursor value.\r\n\r\n**Returns**\r\n\r\nA scalar value of type `bool` that indicates whether the record was ingested\r\nafter the database cursor *RHS* (`true`) or not (`false`).\r\n\r\n**Comments**\r\n\r\nSee [Database Cursor](../concepts/databasecursor.md) for a detailed\r\nexplanation of this function, the scenario in which it should be used, its\r\nrestrictions, and side-effects.\r\n\r\nThis function can only be invoked on records of a table which has the\r\n[IngestionTime policy](../concepts/ingestiontimepolicy.md) enabled.", "", "https://kusto.azurewebsites.net/docs/query/cursorafterfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "cursor_before_or_at", "A predicate over the records of a table to compare their ingestion time\r\nagainst a database cursor.", "**Syntax**\r\n\r\n`cursor_before_or_at` `(` *RHS* `)`\r\n\r\n**Arguments**\r\n\r\n* *RHS*: Either an empty string literal, or a valid database cursor value.\r\n\r\n**Returns**\r\n\r\nA scalar value of type `bool` that indicates whether the record was ingested\r\nbefore or at the database cursor *RHS* (`true`) or not (`false`).\r\n\r\n**Comments**\r\n\r\nSee [Database Cursor](../concepts/databasecursor.md) for a detailed\r\nexplanation of this function, the scenario in which it should be used, its\r\nrestrictions, and side-effects.\r\n\r\nThis function can only be invoked on records of a table which has the\r\n[IngestionTime policy](../concepts/ingestiontimepolicy.md) enabled.", "", "https://kusto.azurewebsites.net/docs/query/cursorbeforeoratfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "database", "Changes the reference of the query to a specific database within the cluster scope.", "database('Sample').StormEvents\r\n    cluster('help').database('Sample').StormEvents\r\n\r\n**Syntax**\r\n\r\n`database(`*stringConstant*`)`\r\n\r\n**Arguments**\r\n\r\n* *stringConstant*: Name of the database that is referenced. Database identified can be either `DatabaseName` or `PrettyName`. Argument has to be _constant_ prior of query execution, i.e. cannot come from sub-query evaluation.\r\n\r\n**Notes**\r\n\r\n* For accessing remote cluster and remote database, see [cluster()](clusterfunction.md) scope function.\r\n* More information about cross-cluster and cross-database queries available [here](cross-cluster-or-database-queries.md)", "### Use database() to access table of other database. \r\n\r\n\r\n```\r\ndatabase('Samples').StormEvents | count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use database() inside let statements \r\n\r\nThe same query as above can be rewritten to use inline function (let statement) that \r\nreceives a parameter `dbName` - which is passed into the database() function.\r\n\r\n\r\n```\r\nlet foo = (dbName:string)\r\n{\r\n    database(dbName).StormEvents | count\r\n};\r\nfoo('help')\r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use database() inside Functions \r\n\r\nThe same query as above can be rewritten to be used in a function that \r\nreceives a parameter `dbName` - which is passed into the database() function.\r\n\r\n\r\n```\r\n.create function foo(dbName:string)\r\n{\r\n    database(dbName).StormEvents | count\r\n};\r\n```\r\n\r\n**Note:** such functions can be used only locally and not in the cross-cluster query.", "https://kusto.azurewebsites.net/docs/query/databasefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "datatable", "Returns a table whose schema and values are defined in the query itself.", "Note that this operator does not have a pipeline input.\r\n\r\n**Syntax**\r\n\r\n`datatable` `(` *ColumnName* `:` *ColumnType* [`,` ...] `)` `[` *ScalarValue* [`,` *ScalarValue* ...] `]`\r\n\r\n**Arguments**\r\n\r\n* *ColumnName*, *ColumnType*: These define the schema of the table. The Syntax\r\n  used is precisely the same as the syntax used when defining a table\r\n  (see [.create table](../management/tables.md#create-table)).\r\n* *ScalarValue*: A constant scalar value to insert into the table. The number of values\r\n  must be an integer multiple of the columns in the table, and the *n*'th value\r\n  must have a type that corresponds to column *n* % *NumColumns*.\r\n\r\n**Returns**\r\n\r\nThis operator returns a data table of the given schema and data.", "```\r\ndatatable (Date:datetime, Event:string)\r\n    [datetime(1910-06-11), \"Born\",\r\n     datetime(1930-01-01), \"Enters Ecole Navale\",\r\n     datetime(1953-01-01), \"Published first book\",\r\n     datetime(1997-06-25), \"Died\"]\r\n| where strlen(Event) > 4\r\n```", "https://kusto.azurewebsites.net/docs/query/datatableoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "datetime_add", "Calculates a new [datetime](./scalar-data-types/datetime.md) from a specified datepart multiplied by a specified amount, added to a specified [datetime](./scalar-data-types/datetime.md).", "**Syntax**\r\n\r\n`datetime_add(`*period*`,`*amount*`,`*datetime*`)`\r\n\r\n**Arguments**\r\n\r\n* `period`: [string](./scalar-data-types/string.md). \r\n* `amount`: [integer](./scalar-data-types/int.md).\r\n* `datetime`: [datetime](./scalar-data-types/datetime.md) value.\r\n\r\nPossible values of *period*: \r\n- Year\r\n- Quarter\r\n- Month\r\n- Week\r\n- Day\r\n- Hour\r\n- Minute\r\n- Second\r\n- Millisecond\r\n- Microsecond\r\n- Nanosecond\r\n\r\n**Returns**\r\n\r\nA date after a certain time/date interval has been added.", "```\r\nprint  year = datetime_add('year',1,make_datetime(2017,1,1)),\r\nquarter = datetime_add('quarter',1,make_datetime(2017,1,1)),\r\nmonth = datetime_add('month',1,make_datetime(2017,1,1)),\r\nweek = datetime_add('week',1,make_datetime(2017,1,1)),\r\nday = datetime_add('day',1,make_datetime(2017,1,1)),\r\nhour = datetime_add('hour',1,make_datetime(2017,1,1)),\r\nminute = datetime_add('minute',1,make_datetime(2017,1,1)),\r\nsecond = datetime_add('second',1,make_datetime(2017,1,1))\r\n\r\n```\r\n\r\n|year|quarter|month|week|day|hour|minute|second|\r\n|---|---|---|---|---|---|---|---|\r\n|2018-01-01 00:00:00.0000000|2017-04-01 00:00:00.0000000|2017-02-01 00:00:00.0000000|2017-01-08 00:00:00.0000000|2017-01-02 00:00:00.0000000|2017-01-01 01:00:00.0000000|2017-01-01 00:01:00.0000000|2017-01-01 00:00:01.0000000|", "https://kusto.azurewebsites.net/docs/query/datetime-addfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "datetime_diff", "Calculates calendarian difference between two [datetime](./scalar-data-types/datetime.md) values.", "**Syntax**\r\n\r\n`datetime_diff(`*period*`,`*datetime_1*`,`*datetime_2*`)`\r\n\r\n**Arguments**\r\n\r\n* `period`: `string`. \r\n* `datetime_1`: [datetime](./scalar-data-types/datetime.md) value.\r\n* `datetime_2`: [datetime](./scalar-data-types/datetime.md) value.\r\n\r\nPossible values of *period*: \r\n- Year\r\n- Quarter\r\n- Month\r\n- Week\r\n- Day\r\n- Hour\r\n- Minute\r\n- Second\r\n- Millisecond\r\n- Microsecond\r\n- Nanosecond\r\n\r\n**Returns**\r\n\r\nAn integer, which represents amount of `periods` in the result of subtraction (`datetime_1` - `datetime_2`).", "```\r\nprint\r\nyear = datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31)),\r\nquarter = datetime_diff('quarter',datetime(2017-07-01),datetime(2017-03-30)),\r\nmonth = datetime_diff('month',datetime(2017-01-01),datetime(2015-12-30)),\r\nweek = datetime_diff('week',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)),\r\nday = datetime_diff('day',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)),\r\nhour = datetime_diff('hour',datetime(2017-10-31 01:00),datetime(2017-10-30 23:59)),\r\nminute = datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59)),\r\nsecond = datetime_diff('second',datetime(2017-10-30 23:00:10.100),datetime(2017-10-30 23:00:00.900)),\r\nmillisecond = datetime_diff('millisecond',datetime(2017-10-30 23:00:00.200100),datetime(2017-10-30 23:00:00.100900)),\r\nmicrosecond = datetime_diff('microsecond',datetime(2017-10-30 23:00:00.1009001),datetime(2017-10-30 23:00:00.1008009)),\r\nnanosecond = datetime_diff('nanosecond',datetime(2017-10-30 23:00:00.0000000),datetime(2017-10-30 23:00:00.0000007))\r\n```\r\n\r\n|year|quarter|month|week|day|hour|minute|second|millisecond|microsecond|nanosecond|\r\n|---|---|---|---|---|---|---|---|---|---|---|\r\n|17|2|13|5|29|2|5|10|100|100|-700|", "https://kusto.azurewebsites.net/docs/query/datetime-difffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "datetime_part", "Extracts the requested date part as an integer value.", "datetime_part(\"Day\",datetime(2015-12-14))\r\n\r\n**Syntax**\r\n\r\n`datetime_part(`*part*`,`*datetime*`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: `datetime`.\r\n* `part`: `string`. \r\n\r\nPossible values of *part*: \r\n- Year\r\n- Quarter\r\n- Month\r\n- WeekOfYear\r\n- Day\r\n- DayOfYear\r\n- Hour\r\n- Minute\r\n- Second\r\n- Millisecond\r\n- Microsecond\r\n- Nanosecond\r\n\r\n**Returns**\r\n\r\nAn integer representing the extracted part.", "```\r\nlet dt = datetime(2017-10-30 01:02:03.7654321); \r\nprint \r\nyear = datetime_part(\"year\", dt),\r\nquarter = datetime_part(\"quarter\", dt),\r\nmonth = datetime_part(\"month\", dt),\r\nweekOfYear = datetime_part(\"weekOfYear\", dt),\r\nday = datetime_part(\"day\", dt),\r\ndayOfYear = datetime_part(\"dayOfYear\", dt),\r\nhour = datetime_part(\"hour\", dt),\r\nminute = datetime_part(\"minute\", dt),\r\nsecond = datetime_part(\"second\", dt),\r\nmillisecond = datetime_part(\"millisecond\", dt),\r\nmicrosecond = datetime_part(\"microsecond\", dt),\r\nnanosecond = datetime_part(\"nanosecond\", dt)\r\n\r\n```\r\n\r\n|year|quarter|month|weekOfYear|day|dayOfYear|hour|minute|second|millisecond|microsecond|nanosecond|\r\n|---|---|---|---|---|---|---|---|---|---|---|---|\r\n|2017|4|10|44|30|303|1|2|3|765|765432|765432100|", "https://kusto.azurewebsites.net/docs/query/datetime-partfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dayofmonth", "Returns the integer number representing the day number of the given month", "dayofmonth(datetime(2015-12-14)) == 14\r\n\r\n**Syntax**\r\n\r\n`dayofmonth(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\n`day number` of the given month.", "", "https://kusto.azurewebsites.net/docs/query/dayofmonthfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dayofweek", "Returns the integer number of days since the preceding Sunday, as a `timespan`.", "dayofweek(datetime(2015-12-14)) == 1d  // Monday\r\n\r\n\r\n**Syntax**\r\n\r\n`dayofweek(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\nThe `timespan` since midnight at the beginning of the preceding Sunday, rounded down to an integer number of days.", "```\r\ndayofweek(1947-11-29 10:00:05)  // time(6.00:00:00), indicating Saturday\r\ndayofweek(1970-05-11)           // time(1.00:00:00), indicating Monday\r\n```", "https://kusto.azurewebsites.net/docs/query/dayofweekfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dayofyear", "Returns the integer number represents the day number of the given year.", "dayofyear(datetime(2015-12-14))\r\n\r\n**Syntax**\r\n\r\n`dayofweek(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\n`day number` of the given year.", "", "https://kusto.azurewebsites.net/docs/query/dayofyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dcount", "Returns an estimate of the number of distinct values of *Expr* in the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `dcount(`*Expr* [`,` *Accuracy*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation.\r\n* *Accuracy*, if specified, controls the balance between speed and accuracy (see Note).\r\n    * `0` = the least accurate and fastest calculation. 1.6% error\r\n    * `1` = the default, which balances accuracy and calculation time; about 0.8% error.\r\n    * `2` = accurate and slow calculation; about 0.4% error.\r\n    * `3` = extra accurate and slow calculation; about 0.28% error.\r\n    * `4` = super accurate and slowest calculation; about 0.2% error.\r\n\r\n**Returns**\r\n\r\nReturns an estimate of the number of distinct values of *Expr* in the group.", "```\r\nPageViewLog | summarize countries=dcount(country) by continent\r\n```\r\n\r\n![alt text](./images/aggregations/dcount.png \"dcount\")\r\n\r\n**Tip: Listing distinct values**\r\n\r\nTo list the distinct values, you can use:\r\n- `summarize by *Expr*`\r\n- [`makeset`](makeset-aggfunction.md) : `summarize makeset(`*Expr*`)` \r\n\r\n**Tip: Accurate distinct count**\r\n\r\nWhile `dcount()` provides a fast and reliable way to count distinct values,\r\nit relies on a statistical algorithm to do so. Therefore, invoking this\r\naggregation multiple times might result in different values being returned.\r\n\r\n* If the accuracy level is `1` and the number of distinct values is smaller than 1000 or so, `dcount()` returns a perfectly-accurate count.\r\n* If the accuracy level is `2` and the number of distinct values is smaller than 8000 or so, `dcount()` returns a perfectly-accurate count.\r\n* If the number of distinct values is larger than that, but not very\r\n  large, one may try to use double-`count()` to calculate a single `dcount()`.\r\n  This is shown in the following example; the two expressions are equivalent\r\n  (except that the second one might run out of memory): \r\n\r\n\r\n```\r\nT | summarize dcount(Key)\r\n\r\nT | summarize count() by Key | summarize count()\r\n```  \r\n\r\n## Estimation error of dcount\r\n\r\ndcount uses a variant of [HyperLogLog (HLL) algorithm](https://en.wikipedia.org/wiki/HyperLogLog) which does stochastic estimation of set cardinality. In practice it means that the estimation error is described in terms of probability distribution, not theoretical bounds.\r\nSo the stated error actually specifies the standard deviation of error distribution (sigma), 99.7% of estimation will have a relative error of under 3*sigma\r\nThe following depicts probability distribution function of relative estimation error (in percents) for all dcount's accuracy settings:\r\n\r\n![alt text](./images/aggregations/hll-error-distribution.png \"hll-error-distribution\")", "https://kusto.azurewebsites.net/docs/query/dcount-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dcount_hll", "Calculates the dcount from hll results (which was generated by [hll](hll-aggfunction.md) or [hll_merge](hll-merge-aggfunction.md)).", "Read more about the underlying algorithm (*H*yper*L*og*L*og) and the estimated error [here](dcount-aggfunction.md#estimation-error-of-dcount).\r\n\r\n**Syntax**\r\n\r\n`dcount_hll(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression which was generated by [hll](hll-aggfunction.md) or [hll-merge](hll-merge-aggfunction.md)\r\n\r\n**Returns**\r\n\r\nThe distinct count of each value in *Expr*", "```\r\nStormEvents\r\n| summarize hllRes = hll(DamageProperty) by bin(StartTime,10m)\r\n| summarize hllMerged = hll_merge(hllRes)\r\n| project dcount_hll(hllMerged)\r\n```\r\n\r\n|dcount_hll_hllMerged|\r\n|---|\r\n|315|", "https://kusto.azurewebsites.net/docs/query/dcount-hllfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "dcountif", "Returns an estimate of the number of distinct values of *Expr* of rows for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md).\r\n\r\nRead more about the estimated error [here](dcount-aggfunction.md#estimation-error-of-dcount).\r\n\r\n**Syntax**\r\n\r\nsummarize `dcountif(`*Expr*, *Predicate*, [`,` *Accuracy*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation.\r\n* *Predicate*: Expression that will be used to filter rows.\r\n* *Accuracy*, if specified, controls the balance between speed and accuracy.\r\n    * `0` = the least accurate and fastest calculation. 1.6% error\r\n    * `1` = the default, which balances accuracy and calculation time; about 0.8% error.\r\n    * `2` = accurate and slow calculation; about 0.4% error.\r\n    * `3` = extra accurate and slow calculation; about 0.28% error.\r\n    * `4` = super accurate and slowest calculation; about 0.2% error.\r\n\t\r\n**Returns**\r\n\r\nReturns an estimate of the number of distinct values of *Expr*  of rows for which *Predicate* evaluates to `true` in the group.", "```\r\nPageViewLog | summarize countries=dcountif(country, country startswith \"United\") by continent\r\n```\r\n\r\n**Tip: Offset error**\r\n\r\n`dcountif()` might result in a one-off error in the edge cases where all rows\r\npass, or none of the rows pass, the `Predicate` expression", "https://kusto.azurewebsites.net/docs/query/dcountif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "degrees", "Converts angle value in radians into value in degrees, using formula `degrees = (180 / PI ) * angle_in_radians`", "**Syntax**\r\n\r\n`degrees(`*a*`)`\r\n\r\n**Arguments**\r\n\r\n* *a*: Angle in radians (a real number).\r\n\r\n**Returns**\r\n\r\n* The corresponding angle in degrees for an angle specified in radians.", "```\r\nprint degrees0 = degrees(pi()/4), degrees1 = degrees(pi()*1.5), degrees2 = degrees(0)\r\n\r\n```\r\n\r\n|degrees0|degrees1|degrees2|\r\n|---|---|---|\r\n|45|270|0|", "https://kusto.azurewebsites.net/docs/query/degreesfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "distance", "Returns the distance between two points in meters.", "**Syntax**\r\n\r\n`distance(`*point1*`, `*point2*`)`\r\n\r\n**Arguments**\r\n\r\n* *point1*: starting point.\r\n* *point2*: ending point.\r\n\r\n**Returns**\r\n\r\nReturns the great-circle distance between two points in meters.\r\nThe function has an accuracy of 0.5%.", "The following example returns `9113818.71527951`:\r\n\r\n\r\n```\r\nprint distance(point(32.083770, 34.785037), point(40.730211, -74.000559))\r\n```", "https://kusto.azurewebsites.net/docs/query/distancefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "distinct", "Produces a table with the distinct combination of the provided columns of the input table.", "T | distinct Column1, Column2\r\n\r\nProduces a table with the distinct combination of all columns in the input table.\r\n\r\n    T | distinct *", "Shows the distinct combination of fruit and price.\r\n\r\n```\r\nTable | distinct fruit, price\r\n```\r\n\r\n![alt text](./Images/aggregations/distinct.PNG \"distinct\")\r\n\r\n**Remarks**\r\n\r\nThere are two main semantic differences between the `distinct` operator and\r\nusing `summarize by ...`:\r\n* Distinct supports providing an asterisk (`*`) as the group key, making it easier to use for wide tables.\r\n* Distinct doesn't have auto-binning of time columns (to `1h`).\r\n\r\n\r\n```\r\nlet T=(print t=datetime(2008-05-12 06:45));\r\nunion\r\n  (T | distinct * | extend Title=\"Distinct\"),\r\n  (T | summarize by t | extend Title=\"Summarize\"),\r\n  (T | summarize by bin(t, 1tick) | extend Title=\"Summarize-distinct\")\r\n\t\t\r\n\tt\tTitle\r\n\t2008-05-12 06:00:00.0000000\tSummarize\r\n\t2008-05-12 06:45:00.0000000\tDistinct\r\n\t2008-05-12 06:45:00.0000000\tSummarize-distinct\r\n```\r\n\r\nThis query produces the following table:\r\n\r\nt                            | Title\r\n-----------------------------|--------------------\r\n2008-05-12 06:45:00.0000000  | Distinct\r\n2008-05-12 06:00:00.0000000  | Summarize\r\n2008-05-12 06:45:00.0000000  | Summarize-distinct", "https://kusto.azurewebsites.net/docs/query/distinctoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "endofday", "Returns the end of the day containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`endofday(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset days from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the end of the day for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project dayEnd = endofday(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|dayEnd|\r\n|---|\r\n|2016-12-31 23:59:59.9999999|\r\n|2017-01-01 23:59:59.9999999|\r\n|2017-01-02 23:59:59.9999999|", "https://kusto.azurewebsites.net/docs/query/endofdayfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "endofmonth", "Returns the end of the month containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`endofmonth(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset months from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the end of the month for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project monthEnd = endofmonth(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|monthEnd|\r\n|---|\r\n|2016-12-31 23:59:59.9999999|\r\n|2017-01-31 23:59:59.9999999|\r\n|2017-02-28 23:59:59.9999999|", "https://kusto.azurewebsites.net/docs/query/endofmonthfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "endofweek", "Returns the end of the week containing the date, shifted by an offset, if provided.", "Last day of the week is considered to be a Saturday.\r\n\r\n**Syntax**\r\n\r\n`endofweek(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset weeks from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the end of the week for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project weekEnd = endofweek(datetime(2017-01-01 10:10:17), offset)  \r\n\r\n```\r\n\r\n|weekEnd|\r\n|---|\r\n|2016-12-31 23:59:59.9999999|\r\n|2017-01-07 23:59:59.9999999|\r\n|2017-01-14 23:59:59.9999999|", "https://kusto.azurewebsites.net/docs/query/endofweekfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "endofyear", "Returns the end of the year containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`endofyear(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset years from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the end of the year for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project yearEnd = endofyear(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|yearEnd|\r\n|---|\r\n|2016-12-31 23:59:59.9999999|\r\n|2017-12-31 23:59:59.9999999|\r\n|2018-12-31 23:59:59.9999999|", "https://kusto.azurewebsites.net/docs/query/endofyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "estimate_data_size", "Returns an estimated data size of the selected columns of the tabular expression.", "estimate_data_size(*)\r\n    estimate_data_size(Col1, Col2, Col3)\r\n\r\n**Syntax**\r\n\r\n`estimate_data_size(*)`\r\n\r\n`estimate_data_size(`*col1*`, `*col2*`, `...`)`\r\n\r\n**Arguments**\r\n\r\n* *col1*, *col2*: Selection of column refereces in the source tabular expression that are used for data size estimation. To include all columns, use `*` (asterisk) syntax.\r\n\r\n**Returns**\r\n\r\n* The estimated data size of the record size. Estimation is based on data types and values lengths.", "Calculating total data size using `estimated_data_size()`:\r\n\r\n\r\n```\r\nrange x from 1 to 10 step 1                    // x (long) is 8 \r\n| extend Text = '1234567890'                   // Text length is 10  \r\n| summarize Total=sum(estimate_data_size(*))   // (8+10)x10 = 180\r\n```\r\n\r\n|Total|\r\n|---|\r\n|180|", "https://kusto.azurewebsites.net/docs/query/estimate-data-sizefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "evaluate", "The evaluate operator is a tabular operator that provides a mechanism to invoke\r\nquery functionality which is non-relational by nature (for example, because it\r\ndoes not have a predefined output schema). This functionality is exposed to the\r\nuser under the name of **plugin**.", "**Syntax**\r\n\r\n[*T* `|`] `evaluate` *PluginName* `(` [*PluginArg1* [`,` *PluginArg2*]... `)`\r\n\r\nWhere:\r\n\r\n* *T* is an optional tabular input to the plugin. (Some plugins don't take\r\n  any input, and act as a tabular data source.)\r\n* *PluginName* is the mandatory name of the plugin being invoked.\r\n* *PluginArg1*, ... are the optional arguments to the plugin.\r\n\r\n**Remarks**\r\n\r\nSyntactically, `evaluate behaves similarly\r\nto the [invoke operator](./invokeoperator.md), which invokes tabular functions.\r\n\r\nPlugins provided through the evaluate operator are not bound by the regular\r\nrules of query execution or argument evaluation. Additionally, specific plugins\r\nmay have specific restrictions; for example, plugins whose output schema depends\r\non the data (e.g., the [bag_unpack plugin](./bag-unpackplugin.md)) cannot be used\r\nwhen performing cross-cluster queries.", "", "https://kusto.azurewebsites.net/docs/query/evaluateoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "exp", "The base-e exponential function of x, which is e raised to the power x: e^x.", "**Syntax**\r\n\r\n`exp(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number, value of the exponent.\r\n\r\n**Returns**\r\n\r\n* Exponential value of x.\r\n* For natural (base-e) logarithms, see [log()](log-function.md).\r\n* For exponential functions of base-2 and base-10 logarithms, see [exp2()](exp2-function.md), [exp10()](exp10-function.md)", "", "https://kusto.azurewebsites.net/docs/query/exp-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "exp10", "The base-10 exponential function of x, which is 10 raised to the power x: 10^x.", "**Syntax**\r\n\r\n`exp10(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number, value of the exponent.\r\n\r\n**Returns**\r\n\r\n* Exponential value of x.\r\n* For natural (base-10) logarithms, see [log10()](log10-function.md).\r\n* For exponential functions of base-e and base-2 logarithms, see [exp()](exp-function.md), [exp2()](exp2-function.md)", "", "https://kusto.azurewebsites.net/docs/query/exp10-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "exp2", "The base-2 exponential function of x, which is 2 raised to the power x: 2^x.", "**Syntax**\r\n\r\n`exp2(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number, value of the exponent.\r\n\r\n**Returns**\r\n\r\n* Exponential value of x.\r\n* For natural (base-2) logarithms, see [log2()](log2-function.md).\r\n* For exponential functions of base-e and base-10 logarithms, see [exp()](exp-function.md), [exp10()](exp10-function.md)", "", "https://kusto.azurewebsites.net/docs/query/exp2-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "extend", "Create calculated columns and append them to the result set.", " T | extend duration = endTime - startTime\r\n\r\n**Syntax**\r\n\r\n*T* `| extend` [*ColumnName* | `(`*ColumnName*[`,` ...]`)` `=`] *Expression* [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The input tabular result set.\r\n* *ColumnName:* Optional. The name of the column to add or update. If omitted then the name will be generated. If *Expression* returns more than one column, then a list of column names can be specified in parenthesis. In this case *Expression*'s output columns will be given the specified names, dropping all rest of the output columns if any. If list of the column names is not specified then all *Expression*'s output columns with generated names will be added to output.\r\n* *Expression:* A calculation over the columns of the input.\r\n\r\n**Returns**\r\n\r\nA copy of the input tabular result set, such that:\r\n1. Column names noted by `extend` that already exist in the input are removed\r\n   and appended as their new calculated values.\r\n2. Column names noted by `extend` that do not exist in the input are appended\r\n   as their new calculated values.\r\n\r\n**Tips**\r\n\r\n* The `extend` operator adds a new column to the input result set, which does\r\n  **not** have an index. In most cases, if the new column is set to be exactly\r\n  the same as an existing table column that has an index, Kusto can automatically\r\n  use the existing index. However, in some complex scenarios this propagation is\r\n  not currently done. In such cases, if the goal is to rename a column,\r\n  use the [`project-rename` operator](projectrenameoperator.md) instead.", "```\r\nLogs\r\n| extend\r\n    Duration = CreatedOn - CompletedOn\r\n    , Age = now() - CreatedOn\r\n    , IsSevere = Level == \"Critical\" or Level == \"Error\"\r\n```\r\n\r\nSee [series_stats](series-statsfunction.md) as an example of a function that returns multiple columns", "https://kusto.azurewebsites.net/docs/query/extendoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "extent_id", "Returns a unique identifier that identifies the data shard (\"extent\") that the current record resides in.", "Applying this function to calculated data which is not attached to a data shard returns an empty guid (all zeros).\r\n\r\n**Syntax**\r\n\r\n`extent_id()`\r\n\r\n**Returns**\r\n\r\nA value of type `guid` that identifies the current record's data shard,\r\nor an empty guid (all zeros).", "The following example shows how to get a list of all the data shards\r\nthat have records from an hour ago with a specific value for the\r\ncolumn `ActivityId`. It demonstrates that some query operators (here,\r\nthe `where` operator, but this is also true for `extend` and `project`)\r\npreserve the information about the data shard hosting the record.\r\n\r\n\r\n```\r\nT\r\n| where Timestamp > ago(1h)\r\n| where ActivityId == 'dd0595d4-183e-494e-b88e-54c52fe90e5a'\r\n| extend eid=extent_id()\r\n| summarize by eid\r\n```", "https://kusto.azurewebsites.net/docs/query/extentidfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "extent_tags", "Returns a dynamic array with the [tags](../concepts/extents.md#extent-tagging) of the data shard (\"extent\") that the current record resides in.", "Applying this function to calculated data which is not attached to a data shard returns an empty value.\r\n\r\n**Syntax**\r\n\r\n`extent_tags()`\r\n\r\n**Returns**\r\n\r\nA value of type `dynamic` that is an array holding the current record's extent tags,\r\nor an empty value.", "The following example shows how to get a list the tags of all the data shards\r\nthat have records from an hour ago with a specific value for the\r\ncolumn `ActivityId`. It demonstrates that some query operators (here,\r\nthe `where` operator, but this is also true for `extend` and `project`)\r\npreserve the information about the data shard hosting the record.\r\n\r\n\r\n```\r\nT\r\n| where Timestamp > ago(1h)\r\n| where ActivityId == 'dd0595d4-183e-494e-b88e-54c52fe90e5a'\r\n| extend tags = extent_tags()\r\n| summarize by tostring(tags)\r\n```\r\n\r\nThe following example shows how to obtain a count of all records from the \r\nlast hour, which are stored in extents which are tagged with the tag `MyTag`\r\n(and potentially other tags), but not tagged with the tag `drop-by:MyOtherTag`.\r\n\r\n\r\n```\r\nT\r\n| where Timestamp > ago(1h)\r\n| extend Tags = extent_tags()\r\n| where Tags has_cs 'MyTag' and Tags !has_cs 'drop-by:MyOtherTag'\r\n| count\r\n```", "https://kusto.azurewebsites.net/docs/query/extenttagsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "externaldata", "Returns a table whose schema is defined in the query itself, and whose data is read from an external raw file.", "Note that this operator does not have a pipeline input.\r\n\r\n**Syntax**\r\n\r\n`externaldata` `(` *ColumnName* `:` *ColumnType* [`,` ...] `)` `[` *DataFileUri* `]` [`with` `(` *Prop1* `=` *Value1* [`,` ...] `)`]\r\n\r\n**Arguments**\r\n\r\n* *ColumnName*, *ColumnType*: These define the schema of the table. The Syntax\r\n  used is precisely the same as the syntax used when defining a table\r\n  (see [.create table](../management/tables.md#create-table)).\r\n* *DataFileUri*: The URI (including authentication option, if any) for the file\r\n  holding the data.\r\n* *Prop1*, *Value1*, ...: Additional properties to describe how the data in the raw file\r\n  is to be interpreted. Similar to ingestion properties.\r\n\r\n**Returns**\r\n\r\nThis operator returns a data table of the given schema, whose data was parsed\r\nfrom the specified URI.", "The following example shows how to parse at query time a raw CSV data file \r\nin Azure Storage Blob. (Please note that in reality the `data.csv` file will\r\nbe appended by a SAS token to authorize the request.)\r\n\r\n\r\n```\r\nexternaldata (Date:datetime, Event:string)\r\n[h@\"https://storageaccount.blob.core.windows.net/storagecontainer/data.csv\"]\r\n| where strlen(Event) > 4\r\n```", "https://kusto.azurewebsites.net/docs/query/externaldata-operator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "extract", "Get a match for a [regular expression](./re2.md) from a text string.", "Optionally, it then converts the extracted substring to the indicated type.\r\n\r\n    extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\") == \"45.6\"\r\n\r\n**Syntax**\r\n\r\n`extract(`*regex*`,` *captureGroup*`,` *text* [`,` *typeLiteral*]`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: A [regular expression](./re2.md).\r\n* *captureGroup*: A positive `int` constant indicating the\r\ncapture group to extract. 0 stands for the entire match, 1 for the value matched by the first '('parenthesis')' in the regular expression, 2 or more for subsequent parentheses.\r\n* *text*: A `string` to search.\r\n* *typeLiteral*: An optional type literal (e.g., `typeof(long)`). If provided, the extracted substring is converted to this type. \r\n\r\n**Returns**\r\n\r\nIf *regex* finds a match in *text*: the substring matched against the indicated capture group *captureGroup*, optionally converted to *typeLiteral*.\r\n\r\nIf there's no match, or the type conversion fails: `null`.", "The example string `Trace` is searched for a definition for `Duration`. \r\nThe match is converted to `real`, then multiplied it by a time constant (`1s`) so that `Duration` is of type `timespan`. In this example, it is equal to 123.45 seconds:\r\n\r\n\r\n```\r\n...\r\n| extend Trace=\"A=1, B=2, Duration=123.45, ...\"\r\n| extend Duration = extract(\"Duration=([0-9.]+)\", 1, Trace, typeof(real)) * time(1s) \r\n```\r\n\r\nThis example is equivalent to `substring(Text, 2, 4)`:\r\n\r\n\r\n```\r\nextract(\"^.{2,2}(.{4,4})\", 1, Text)\r\n```", "https://kusto.azurewebsites.net/docs/query/extractfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "extractall", "Get all matches for a [regular expression](./re2.md) from a text string.", "Optionally, a subset of matching groups can be retrieved.\r\n\r\n    extractall(@\"(\\d+)\", \"a set of numbers: 123, 567 and 789\") == dynamic([\"123\", \"567\", \"789\"])\r\n\r\n**Syntax**\r\n\r\n`extractall(`*regex*`,` [*captureGroups*`,`] *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: A [regular expression](./re2.md). Regular \r\nexpression must have at least one capturing group, and less-or-equal than 16 capturing groups.\r\n* *captureGroups*: (optional). A dynamic array constant indicating the capture group to extract. Valid \r\nvalues are from 1 to number of capturing groups in the regular expression. Named capture groups are allowed as\r\nwell (see examples section).\r\n* *text*: A `string` to search.\r\n\r\n**Returns**\r\n\r\nIf *regex* finds a match in *text*: \r\nreturns dynamic array including all matches against the indicated capture groups *captureGroups* (or all of capturing groups in the *regex*).\r\nIf number of *captureGroups* is 1: the returned array has a single dimension of matched values.\r\nIf number of *captureGroups* is more than 1: the returned array is two-dimensionaly - collection of multi-value matches per *captureGroups* selection (or all capture groups present in the *regex* if *captureGroups* is omitted) \r\n\r\nIf there's no match: `null`.", "### Extracting single capture group\r\nThe example below returns hex-byte representation (two hex-digits) of the GUID.\r\n\r\n\r\n```\r\nprint Id=\"82b8be2d-dfa7-4bd1-8f63-24ad26d31449\"\r\n| extend guid_bytes = extractall(@\"([\\da-f]{2})\", Id) \r\n```\r\n\r\n|Id|guid_bytes|\r\n|---|---|\r\n|82b8be2d-dfa7-4bd1-8f63-24ad26d31449|[\"82\",\"b8\",\"be\",\"2d\",\"df\",\"a7\",\"4b\",\"d1\",\"8f\",\"63\",\"24\",\"ad\",\"26\",\"d3\",\"14\",\"49\"]|\r\n\r\n### Extracting several capture groups \r\nNext example uses a regular expression with 3 capturing groups to split each GUID part into first letter, last letter and whatever in the middle.\r\n\r\n\r\n```\r\nprint Id=\"82b8be2d-dfa7-4bd1-8f63-24ad26d31449\"\r\n| extend guid_bytes = extractall(@\"(\\w)(\\w+)(\\w)\", Id) \r\n```\r\n\r\n|Id|guid_bytes|\r\n|---|---|\r\n|82b8be2d-dfa7-4bd1-8f63-24ad26d31449|[[\"8\",\"2b8be2\",\"d\"],[\"d\",\"fa\",\"7\"],[\"4\",\"bd\",\"1\"],[\"8\",\"f6\",\"3\"],[\"2\",\"4ad26d3144\",\"9\"]]|\r\n\r\n### Extracting subset of capture groups\r\n\r\nNext example shows how to select a subset of capturing groups: in this case the regular expression \r\nmatches into first letter, last letter and all the rest - while the *captureGroups* parameter is used to select only first and the last part. \r\n\r\n\r\n```\r\nprint Id=\"82b8be2d-dfa7-4bd1-8f63-24ad26d31449\"\r\n| extend guid_bytes = extractall(@\"(\\w)(\\w+)(\\w)\", dynamic([1,3]), Id) \r\n```\r\n\r\n|Id|guid_bytes|\r\n|---|---|\r\n|82b8be2d-dfa7-4bd1-8f63-24ad26d31449|[[\"8\",\"d\"],[\"d\",\"7\"],[\"4\",\"1\"],[\"8\",\"3\"],[\"2\",\"9\"]]|\r\n\r\n\r\n### Using named capture groups\r\n\r\nYou can utilize named capture groups of RE2 in extractall(). \r\nIn the example below - the *captureGroups* uses both capture group indexes and named capture group reference to fetch matching values.\r\n\r\n\r\n```\r\nprint Id=\"82b8be2d-dfa7-4bd1-8f63-24ad26d31449\"\r\n| extend guid_bytes = extractall(@\"(?P<first>\\w)(?P<middle>\\w+)(?P<last>\\w)\", dynamic(['first',2,'last']), Id) \r\n```\r\n\r\n|Id|guid_bytes|\r\n|---|---|\r\n|82b8be2d-dfa7-4bd1-8f63-24ad26d31449|[[\"8\",\"2b8be2\",\"d\"],[\"d\",\"fa\",\"7\"],[\"4\",\"bd\",\"1\"],[\"8\",\"f6\",\"3\"],[\"2\",\"4ad26d3144\",\"9\"]]|", "https://kusto.azurewebsites.net/docs/query/extractallfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "extractjson", "Get a specified element out of a JSON text using a path expression.", "Optionally convert the extracted string to a specific type.\r\n\r\n    extractjson(\"$.hosts[1].AvailableMB\", EventText, typeof(int))\r\n\r\n\r\n**Syntax**\r\n\r\n`extractjson(`*jsonPath*`,` *dataSource*`)` \r\n\r\n**Arguments**\r\n\r\n* *jsonPath*: JsonPath string that defines an accessor into the JSON document.\r\n* *dataSource*:  A JSON document.\r\n\r\n**Returns**\r\n\r\nThis function performs a JsonPath query into dataSource which contains a valid JSON string, optionally converting that value to another type depending on the third argument.", "The `[`bracket`]` notatation and dot (`.`) notation are equivalent:\r\n\r\n\r\n```\r\nT \r\n| extend AvailableMB = extractjson(\"$.hosts[1].AvailableMB\", EventText, typeof(int)) \r\n\r\nT\r\n| extend AvailableMD = extractjson(\"$['hosts'][1]['AvailableMB']\", EventText, typeof(int)) \r\n```\r\n\r\n### JSON Path expressions\r\n\r\n|||\r\n|---|---|\r\n|`$`|Root object|\r\n|`@`|Current object|\r\n|`.` or `[ ]` | Child|\r\n|`[ ]`|Array subscript|\r\n\r\n*(We don't currently implement wildcards, recursion, union, or slices.)*\r\n\r\n\r\n**Performance tips**\r\n\r\n* Apply where-clauses before using `extractjson()`\r\n* Consider using a regular expression match with [extract](extractfunction.md) instead. This can run very much faster, and is effective if the JSON is produced from a template.\r\n* Use `parsejson()` if you need to extract more than one value from the JSON.\r\n* Consider having the JSON parsed at ingestion by declaring the type of the column to be dynamic.", "https://kusto.azurewebsites.net/docs/query/extractjsonfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "facet", "Returns a set of tables, one for each specified column.\r\nEach table specifies the list of values taken by its column.\r\nAn additional table can be created by using the `with` clause.", "**Syntax**\r\n\r\n*T* `| facet by` *ColumnName* [`, ` ...] [`with (` *filterPipe* `)`\r\n\r\n**Arguments**\r\n\r\n* *ColumnName:* The name of column in the input, to be summarized as an output table.\r\n* *filterPipe:* A query expression applied to the input table to produce one of the outputs.\r\n\r\n**Returns**\r\n\r\nMultiple tables: one for the `with` clause, and one for each column.", "```\r\nMyTable \r\n| facet by city, eventType \r\n    with (where timestamp > ago(7d) | take 1000)\r\n```", "https://kusto.azurewebsites.net/docs/query/facetoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "find", "Finds rows that match a predicate across a set of tables.", "The scope of the `find` can also be cross-database or cross-cluster.\r\n\r\n\r\n```\r\nfind in (Table1, Table2, Table3) where Fruit==\"apple\"\r\n\r\nfind in (database('*').*) where Fruit == \"apple\"\r\n\r\nfind in (cluster('cluster_name').database('MyDB*'.*)) where Fruit == \"apple\"\r\n\r\n```\r\n\r\n## Syntax\r\n\r\n* `find` [`withsource`=*ColumnName*] [`in` `(`*Table* [`,` *Table*, ...]`)`] `where` *Predicate* [`project-smart` | `project` *ColumnName* [`:`*ColumnType*] [`,` *ColumnName*[`:`*ColumnType*], ...][`,` `pack(*)`]] \r\n\r\n* `find` *Predicate* [`project-smart` | `project` *ColumnName*[`:`*ColumnType*] [`,` *ColumnName*[`:`*ColumnType*], ...] [`, pack(*)`]] \r\n\r\n## Arguments\r\n* `withsource=`*ColumnName*: Optional. By default the output will include a column called *source_* whose values indicates which source table has contributed each row. If specified, *ColumnName* will be used instead of *source_* .\r\nIf the query effectively (after wildcard matching) references tables from more than one database (default database always counts) the value of this column will have a table name qualified with the database. Similarly __cluster and database__ qualifications will be present in the value if more than one cluster is referenced.\r\n* *Predicate*: [see details](./findoperator.md#predicate-syntax). A `boolean` [expression](./scalar-data-types/bool.md) over the columns of the input tables *Table* [`,` *Table*, ...]. It is evaluated for each row in each input table. \r\n* `Table`: Optional. By default *find* will search in all tables in the current database\r\n *  The name of a table, such as `Events` or\r\n *  A query expression, such as `(Events | where id==42)`\r\n *  A set of tables specified with a wildcard. For example, `E*` would form the union of all the tables in the database whose names begin `E`.\r\n* `project-smart` | `project`: [see details](./findoperator.md#output-schema) if not specified `project-smart` will be used by default\r\n\r\n## Returns\r\n\r\nTransformation of rows in *Table* [`,` *Table*, ...] for which *Predicate* is `true`. The rows are transformed\r\naccording to the output schema as described below.\r\n\r\n## Output Schema\r\n\r\n**source_ column**\r\n\r\nThe find operator output will always include a *source_* column with the source table name. The column can be renamed using the `withsource` parameter.\r\n\r\n**results columns**\r\n\r\nSource tables that do not contain any column used by the predicate evaluation will be be filtered out.\r\n\r\nWhen using `project-smart`, the columns that will appear in the output will be:\r\n1. Columns that appear explicitly in the predicate\r\n2. Columns that are common to all the filtered tables\r\nThe rest of the columns will be packed into a property bag and will appear in an additional `pack_` column.\r\nA column that is referenced explicitly by the predicate and appears in multiple tables with multiple types, will have a different column in the result schema for each such type. Each of the column names will be constructed from the original column name and the type, separated by an underscore.\r\n\r\nWhen using `project` *ColumnName*[`:`*ColumnType*] [`,` *ColumnName*[`:`*ColumnType*], ...][`,` `pack(*)`]:\r\n1. The result table will include the columns specified in the list. If a source table doesn't contain a certain column, the values in the corresponding rows will be null.\r\n2. When specifying a *ColumnType* along with a *ColumnName*, this column in the **result** will have the given type, and the values will be casted to that type if needed. Note that this will not have an effect on the column type when evaluating the *Predicate*.\r\n3. When `pack(*)` is used, the rest of the columns will be packed into a property bag and will appear in an additional `pack_` column\r\n\r\n**pack_ column**\r\n\r\nThis column will contain a property bag with the data from all the columns that doesn't appear in the output schema. The source column name will serve as the property name and the column value will serve as the property value.\r\n\r\n## Predicate Syntax\r\n\r\nPlease refer to the [where operator](./whereoperator.md) for some filtering functions summary.\r\n\r\nfind operator supports an alternative syntax for `* has` *term* , and using just *term* will search a term across all input columns\r\n\r\n## Notes\r\n\r\n* If the project clause references a column that appears in multiple tables and has multiple types, a type must follow this column reference in the project clause\r\n* When using *project-smart*, changes in the predicate, in the source tables set or in the tables schema may result in a changes to the output schema. If a constant result schema is needed, use *project* instead\r\n* `find` scope can not include [functions](../management/functions.md). To include a function in the find scope - define a [let statement](./letstatement.md) with [view keyword](./letstatement.md)\r\n\r\n## Performance Tips\r\n\r\n* Use [tables](../management/tables.md) as opposed to [tabular expressions](./tabularexpressionstatements.md)- in case of tabular expression the find operator falls back to a `union` query which can result in degraded performance\r\n* If a column that appears in multiple tables and has multiple types is part of the project clause, prefer adding a *ColumnType* to the project clause over modifying the table before passing it to `find` (see previous tip)\r\n* Add time based filters to the predicate (using a datetime column value or [ingestion_time()](./ingestiontimefunction.md))\r\n* Prefer to search in specific columns over full text search \r\n* Prefer not to reference explicitly columns that appears in multiple tables and has multiple types. If the predicate is valid when resolving such columns type for more than one type, the query will fallback to union\r\n\r\n[see examples](./findoperator.md#examples-of-cases-where-find-will-perform-as-union)", "###  Term lookup across all tables (in current database)\r\n\r\nThe next query finds all rows from all tables in the current database in which any column includes the word `Kusto`. \r\nThe resulting records are transformed according to the [output schema](#output-schema). \r\n\r\n\r\n```\r\nfind \"Kusto\"\r\n```\r\n\r\n## Term lookup across all tables matching a name pattern (in the current database)\r\n\r\nThe next query finds all rows from all tables in the current database whose name starts with `K`, and in which any column includes the word `Kusto`.\r\nThe resulting records are transformed according to the [output schema](#output-schema). \r\n\r\n\r\n```\r\nfind in (K*) where * has \"Kusto\"\r\n```\r\n\r\n###  Term lookup across all tables in all databases (in the cluster)\r\n\r\nThe next query finds all rows from all tables in all databases in which any column includes the word `Kusto`. \r\nThis is a [cross database query](./cross-cluster-or-database-queries.md) query. \r\nThe resulting records are transformed according to the [output schema](#output-schema). \r\n\r\n\r\n```\r\nfind in (database('*').*) \"Kusto\"\r\n```\r\n\r\n### Term lookup across all tables and databases matching a name pattern (in the cluster)\r\n\r\nThe next query finds all rows from all tables whose name starts with `K` in all databases whose name start with `B` and \r\nin which any column includes the word `Kusto`. \r\nThe resulting records are transformed according to the [output schema](#output-schema). \r\n\r\n\r\n```\r\nfind in (database(\"B*\").K*) where * has \"Kusto\"\r\n```\r\n\r\n\r\n### Term lookup in several clusters\r\n\r\nThe next query finds all rows from all tables whose name starts with `K` in all databases whose name start with `B` and \r\nin which any column includes the word `Kusto`. \r\nThe resulting records are transformed according to the [output schema](#output-schema). \r\n\r\n\r\n```\r\nfind in (cluster(\"cluster1\").database(\"B*\").K*, cluster(\"cluster2\").database(\"C*\".*))\r\nwhere * has \"Kusto\"\r\n```\r\n\r\n## Examples of `find` output results  \r\n\r\nThe following examples show how `find` can be used over two tables: EventsTable1 and EventsTable2. \r\nAssume we have next content of these two tables: \r\n\r\n### EventsTable1\r\n\r\n|Session_Id|Level|EventText|Version\r\n|---|---|---|---|\r\n|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Information|Some Text1|v1.0.0\r\n|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Error|Some Text2|v1.0.0\r\n|28b8e46e-3c31-43cf-83cb-48921c3986fc|Error|Some Text3|v1.0.1\r\n|8f057b11-3281-45c3-a856-05ebb18a3c59|Information|Some Text4|v1.1.0\r\n\r\n### EventsTable2\r\n\r\n|Session_Id|Level|EventText|EventName\r\n|---|---|---|---|\r\n|f7d5f95f-f580-4ea6-830b-5776c8d64fdd|Information|Some Other Text1|Event1\r\n|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Information|Some Other Text2|Event2\r\n|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Error|Some Other Text3|Event3\r\n|15eaeab5-8576-4b58-8fc6-478f75d8fee4|Error|Some Other Text4|Event4\r\n\r\n\r\n### Search in common columns, project common and uncommon columns and pack the rest  \r\n\r\n\r\n```\r\nfind in (EventsTable1, EventsTable2) \r\n     where Session_Id == 'acbd207d-51aa-4df7-bfa7-be70eb68f04e' and Level == 'Error' \r\n     project EventText, Version, EventName, pack(*)\r\n```\r\n\r\n|source_|EventText|Version|EventName|pack_\r\n|---|---|---|---|---|\r\n|EventsTable1|Some Text2|v1.0.0||{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Error\"}\r\n|EventsTable2|Some Other Text3||Event3|{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Error\"}\r\n\r\n\r\n### Search in common and uncommon columns\r\n\r\n\r\n```\r\nfind Version == 'v1.0.0' or EventName == 'Event1' project Session_Id, EventText, Version, EventName\r\n```\r\n\r\n|source_|Session_Id|EventText|Version|EventName|\r\n|---|---|---|---|---|\r\n|EventsTable1|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Some Text1|v1.0.0\r\n|EventsTable1|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Some Text2|v1.0.0\r\n|EventsTable2|f7d5f95f-f580-4ea6-830b-5776c8d64fdd|Some Other Text1||Event1\r\n\r\nNote: in practice, *EventsTable1* rows will be filtered with ```Version == 'v1.0.0'``` predicate and *EventsTable2* rows will be filtered with ```EventName == 'Event1'``` predicate.\r\n\r\n### Use abbreviated notation to search across all tables in the current database\r\n\r\n\r\n```\r\nfind Session_Id == 'acbd207d-51aa-4df7-bfa7-be70eb68f04e'\r\n```\r\n\r\n|source_|Session_Id|Level|EventText|pack_|\r\n|---|---|---|---|---|\r\n|EventsTable1|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Information|Some Text1|{\"Version\":\"v1.0.0\"}\r\n|EventsTable1|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Error|Some Text2|{\"Version\":\"v1.0.0\"}\r\n|EventsTable2|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Information|Some Other Text2|{\"EventName\":\"Event2\"}\r\n|EventsTable2|acbd207d-51aa-4df7-bfa7-be70eb68f04e|Error|Some Other Text3|{\"EventName\":\"Event3\"}\r\n\r\n\r\n### Return the results from each row as a property bag\r\n\r\n\r\n```\r\nfind Session_Id == 'acbd207d-51aa-4df7-bfa7-be70eb68f04e' project pack(*)\r\n```\r\n\r\n|source_|pack_|\r\n|---|---|\r\n|EventsTable1|{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Information\", \"EventText\":\"Some Text1\", \"Version\":\"v1.0.0\"}\r\n|EventsTable1|{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Error\", \"EventText\":\"Some Text2\", \"Version\":\"v1.0.0\"}\r\n|EventsTable2|{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Information\", \"EventText\":\"Some Other Text2\", \"EventName\":\"Event2\"}\r\n|EventsTable2|{\"Session_Id\":\"acbd207d-51aa-4df7-bfa7-be70eb68f04e\", \"Level\":\"Error\", \"EventText\":\"Some Other Text3\", \"EventName\":\"Event3\"}\r\n\r\n\r\n## Examples of cases where `find` will perform as `union`\r\n\r\n### Using a non tabular expression as find operand\r\n\r\n\r\n```\r\nlet PartialEventsTable1 = view() { EventsTable1 | where Level == 'Error' };\r\nfind in (PartialEventsTable1, EventsTable2) \r\n     where Session_Id == 'acbd207d-51aa-4df7-bfa7-be70eb68f04e'\r\n```\r\n\r\n### Referencing a column that appears in multiple tables and has multiple types\r\n\r\nAssume we have created two tables by running: \r\n\r\n\r\n```\r\n.create tables \r\n  Table1 (Level:string, Timestamp:datetime, ProcessId:string),\r\n  Table2 (Level:string, Timestamp:datetime, ProcessId:int64)\r\n```\r\n\r\n* The following query will be executed as `union`:\r\n\r\n```\r\nfind in (Table1, Table2) where ProcessId == 1001\r\n```\r\n\r\nAnd the output result schema will be __(Level:string, Timestamp, ProcessId_string, ProcessId_int)__\r\n\r\n* The following query will, as well, be executed as `union` but will produce a different result schema:\r\n\r\n```\r\nfind in (Table1, Table2) where ProcessId == 1001 project Level, Timestamp, ProcessId:string \r\n```\r\n\r\nAnd the output result schema will be __(Level:string, Timestamp, ProcessId_string)__", "https://kusto.azurewebsites.net/docs/query/findoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "floor", "An alias for [`bin()`](binfunction.md).", "", "", "https://kusto.azurewebsites.net/docs/query/floorfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "fork", "Runs multiple consumer operators in parallel.", "**Syntax**\r\n\r\n*T* `|` `fork` [*name*`=`]`(`*subquery*`)` [*name*`=`]`(`*subquery*`)` ...\r\n\r\n**Arguments**\r\n\r\n* *subquery* is a downstream pipeline of query operators\r\n* *name* is a temporary name for the subquery result table\r\n\r\n**Returns**\r\n\r\nMultiple result tables, one for each of the subqueries.\r\n\r\n**Supported Operators**\r\n\r\n[`as`](asoperator.md), [`count`](countoperator.md), [`extend`](extendoperator.md), [`parse`](parseoperator.md), [`where`](whereoperator.md), [`take`](takeoperator.md), [`project`](projectoperator.md), [`project-away`](projectawayoperator.md), [`summarize`](summarizeoperator.md), [`top`](topoperator.md), [`top-nested`](topnestedoperator.md), [`sort`](sortoperator.md), [`mvexpand`](mvexpandoperator.md), [`reduce`](reduceoperator.md)\r\n\r\n**Notes**\r\n\r\n* [`materialize`](materializefunction.md) function can be used as a replacement for using [`join`](joinoperator.md) or [`union`](unionoperator.md) on fork legs.\r\nThe input stream will be cached by materialize and then the cached expression can be used in join/union legs.\r\n\r\n* A name, given by the `name` argument or by using [`as`](asoperator.md) operator will be used as the to name the result tab in [`Kusto.Explorer`](../tools/kusto-explorer.md) tool.\r\n\r\n* Avoid using `fork` with a single subquery.\r\n\r\n* Prefer using [batch](batches.md) of tabular expression statements over `fork` operator.", "```\r\nKustoLogs\r\n| where Timestamp > ago(1h)\r\n| fork\r\n    ( where Level == \"Error\" | project EventText | limit 100 )\r\n    ( project Timestamp, EventText | top 1000 by Timestamp desc)\r\n    ( summarize min(Timestamp), max(Timestamp) by ActivityID )\r\n \r\n// In the following examples the result tables will be named: Errors, EventsTexts and TimeRangePerActivityID\r\nKustoLogs\r\n| where Timestamp > ago(1h)\r\n| fork\r\n    ( where Level == \"Error\" | project EventText | limit 100 | as Errors )\r\n    ( project Timestamp, EventText | top 1000 by Timestamp desc | as EventsTexts )\r\n    ( summarize min(Timestamp), max(Timestamp) by ActivityID | as TimeRangePerActivityID )\r\n    \r\n KustoLogs\r\n| where Timestamp > ago(1h)\r\n| fork\r\n    Errors = ( where Level == \"Error\" | project EventText | limit 100 )\r\n    EventsTexts = ( project Timestamp, EventText | top 1000 by Timestamp desc )\r\n    TimeRangePerActivityID = ( summarize min(Timestamp), max(Timestamp) by ActivityID )\r\n```", "https://kusto.azurewebsites.net/docs/query/forkoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "format_datetime", "Formats a datetime parameter based on the format pattern parameter.", "format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s.fffffff') \r\n    \r\n    => \"15-12-14 2:3:4.1234500\"\r\n\r\n\r\n**Syntax**\r\n\r\n`format_datetime(`*a_date*,*a_format*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: a `datetime` to format.\r\n* `a_date`: a `format` to use.\r\n\r\n**Returns**\r\n\r\nThe string with the format result.\r\n\r\n**Supported formats**\r\n\r\n|Format specifier\t|Description\t|Examples\r\n|---|---|---\r\n|\"d\"\t|The day of the month, from 1 through 31. |\t2009-06-01T13:45:30 -> 1, 2009-06-15T13:45:30 -> 15\r\n|\"dd\"\t|The day of the month, from 01 through 31.|\t2009-06-01T13:45:30 -> 01, 2009-06-15T13:45:30 -> 15\r\n|\"f\"\t|The tenths of a second in a date and time value. |2009-06-15T13:45:30.6170000 -> 6, 2009-06-15T13:45:30.05 -> 0\r\n|\"ff\"\t|The hundredths of a second in a date and time value. |2009-06-15T13:45:30.6170000 -> 61, 2009-06-15T13:45:30.0050000 -> 00\r\n|\"fff\"\t|The milliseconds in a date and time value. |6/15/2009 13:45:30.617 -> 617, 6/15/2009 13:45:30.0005 -> 000\r\n|\"ffff\"\t|The ten thousandths of a second in a date and time value. |2009-06-15T13:45:30.6175000 -> 6175, 2009-06-15T13:45:30.0000500 -> 0000\r\n|\"fffff\"\t|The hundred thousandths of a second in a date and time value. |2009-06-15T13:45:30.6175400 -> 61754, 2009-06-15T13:45:30.000005 -> 00000\r\n|\"ffffff\"\t|The millionths of a second in a date and time value. |2009-06-15T13:45:30.6175420 -> 617542, 2009-06-15T13:45:30.0000005 -> 000000\r\n|\"fffffff\"\t|The ten millionths of a second in a date and time value. |2009-06-15T13:45:30.6175425 -> 6175425, 2009-06-15T13:45:30.0001150 -> 0001150\r\n|\"F\"\t|If non-zero, the tenths of a second in a date and time value. |2009-06-15T13:45:30.6170000 -> 6, 2009-06-15T13:45:30.0500000 -> (no output)\r\n|\"FF\"\t|If non-zero, the hundredths of a second in a date and time value. |2009-06-15T13:45:30.6170000 -> 61, 2009-06-15T13:45:30.0050000 -> (no output)\r\n|\"FFF\"\t|If non-zero, the milliseconds in a date and time value. |2009-06-15T13:45:30.6170000 -> 617, 2009-06-15T13:45:30.0005000 -> (no output)\r\n|\"FFFF\"\t|If non-zero, the ten thousandths of a second in a date and time value. |2009-06-15T13:45:30.5275000 -> 5275, 2009-06-15T13:45:30.0000500 -> (no output)\r\n|\"FFFFF\"\t|If non-zero, the hundred thousandths of a second in a date and time value. |2009-06-15T13:45:30.6175400 -> 61754, 2009-06-15T13:45:30.0000050 -> (no output)\r\n|\"FFFFFF\"\t|If non-zero, the millionths of a second in a date and time value. |2009-06-15T13:45:30.6175420 -> 617542, 2009-06-15T13:45:30.0000005 -> (no output)\r\n|\"FFFFFFF\"\t|If non-zero, the ten millionths of a second in a date and time value. |2009-06-15T13:45:30.6175425 -> 6175425, 2009-06-15T13:45:30.0001150 -> 000115\r\n|\"h\"\t|The hour, using a 12-hour clock from 1 to 12. |2009-06-15T01:45:30 -> 1, 2009-06-15T13:45:30 -> 1\r\n|\"hh\"\t|The hour, using a 12-hour clock from 01 to 12. |2009-06-15T01:45:30 -> 01, 2009-06-15T13:45:30 -> 01\r\n|\"H\"\t|The hour, using a 24-hour clock from 0 to 23. |2009-06-15T01:45:30 -> 1, 2009-06-15T13:45:30 -> 13\r\n|\"HH\"\t|The hour, using a 24-hour clock from 00 to 23. |2009-06-15T01:45:30 -> 01, 2009-06-15T13:45:30 -> 13\r\n|\"m\"\t|The minute, from 0 through 59. |2009-06-15T01:09:30 -> 9, 2009-06-15T13:29:30 -> 29\r\n|\"mm\"\t|The minute, from 00 through 59. |2009-06-15T01:09:30 -> 09, 2009-06-15T01:45:30 -> 45\r\n|\"M\"\t|The month, from 1 through 12. |2009-06-15T13:45:30 -> 6\r\n|\"MM\"\t|The month, from 01 through 12.|2009-06-15T13:45:30 -> 06\r\n|\"s\"\t|The second, from 0 through 59. |2009-06-15T13:45:09 -> 9\r\n|\"ss\"\t|The second, from 00 through 59. |2009-06-15T13:45:09 -> 09\r\n|\"y\"\t|The year, from 0 to 99. |0001-01-01T00:00:00 -> 1, 0900-01-01T00:00:00 -> 0, 1900-01-01T00:00:00 -> 0, 2009-06-15T13:45:30 -> 9, 2019-06-15T13:45:30 -> 19\r\n|\"yy\"\t|The year, from 00 to 99. |\t0001-01-01T00:00:00 -> 01, 0900-01-01T00:00:00 -> 00, 1900-01-01T00:00:00 -> 00, 2019-06-15T13:45:30 -> 19\r\n|\"yyyy\"\t|The year as a four-digit number. |\t0001-01-01T00:00:00 -> 0001, 0900-01-01T00:00:00 -> 0900, 1900-01-01T00:00:00 -> 1900, 2009-06-15T13:45:30 -> 2009\r\n|\"tt\"\t|AM / PM hours |2009-06-15T13:45:09 -> PM\r\n\r\n**Supported delimeters**\r\n\r\n' ',   '/',   '-',   ':',   ',',   '.',   '_',   '[',   ']'", "```\r\nformat_datetime(datetime(2017-01-29 09:00:05), 'yy-MM-dd [HH:mm:ss]') //'17-01-29 [09:00:05]'\r\nformat_datetime(datetime(2017-01-29 09:00:05), 'yyyy-M-dd [H:mm:ss]') //'2017-1-29 [9:00:05]'\r\nformat_datetime(datetime(2017-01-29 09:00:05), 'yy-MM-dd [hh:mm:ss tt]') //'17-01-29 [09:00:05 AM]'\r\n```", "https://kusto.azurewebsites.net/docs/query/format-datetimefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "format_timespan", "Formats a timespan parameter based on the format pattern parameter.", "format_timespan(time(14.02:03:04.12345), 'h:m:s.fffffff') \r\n    \r\n    => \"2:3:4.1234500\"\r\n\r\n\r\n**Syntax**\r\n\r\n`format_timespan(`*a_timespan*,*a_format*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_timespan`: a `timespan` to format.\r\n* `a_format`: a `format` to use.\r\n\r\n**Returns**\r\n\r\nThe string with the format result.\r\n\r\n**Supported formats**\r\n\r\n|Format specifier\t|Description\t|Examples\r\n|---|---|---\r\n|\"d\"-\"dddddddd\"\t|The number of whole days in the time interval. Padded with zeros if needed.|\t15.13:45:30: d -> 15, dd -> 15, ddd -> 015\r\n|\"f\"\t|The tenths of a second in the time interval. |15.13:45:30.6170000 -> 6, 15.13:45:30.05 -> 0\r\n|\"ff\"\t|The hundredths of a second in the time interval. |15.13:45:30.6170000 -> 61, 15.13:45:30.0050000 -> 00\r\n|\"fff\"\t|The milliseconds in the time interval. |6/15/2009 13:45:30.617 -> 617, 6/15/2009 13:45:30.0005 -> 000\r\n|\"ffff\"\t|The ten thousandths of a second in the time interval. |15.13:45:30.6175000 -> 6175, 15.13:45:30.0000500 -> 0000\r\n|\"fffff\"\t|The hundred thousandths of a second in the time interval. |15.13:45:30.6175400 -> 61754, 15.13:45:30.000005 -> 00000\r\n|\"ffffff\"\t|The millionths of a second in the time interval. |15.13:45:30.6175420 -> 617542, 15.13:45:30.0000005 -> 000000\r\n|\"fffffff\"\t|The ten millionths of a second in the time interval. |15.13:45:30.6175425 -> 6175425, 15.13:45:30.0001150 -> 0001150\r\n|\"F\"\t|If non-zero, the tenths of a second in the time interval. |15.13:45:30.6170000 -> 6, 15.13:45:30.0500000 -> (no output)\r\n|\"FF\"\t|If non-zero, the hundredths of a second in the time interval. |15.13:45:30.6170000 -> 61, 15.13:45:30.0050000 -> (no output)\r\n|\"FFF\"\t|If non-zero, the milliseconds in the time interval. |15.13:45:30.6170000 -> 617, 15.13:45:30.0005000 -> (no output)\r\n|\"FFFF\"\t|If non-zero, the ten thousandths of a second in the time interval. |15.13:45:30.5275000 -> 5275, 15.13:45:30.0000500 -> (no output)\r\n|\"FFFFF\"\t|If non-zero, the hundred thousandths of a second in the time interval. |15.13:45:30.6175400 -> 61754, 15.13:45:30.0000050 -> (no output)\r\n|\"FFFFFF\"\t|If non-zero, the millionths of a second in the time interval. |15.13:45:30.6175420 -> 617542, 15.13:45:30.0000005 -> (no output)\r\n|\"FFFFFFF\"\t|If non-zero, the ten millionths of a second in the time interval. |15.13:45:30.6175425 -> 6175425, 15.13:45:30.0001150 -> 000115\r\n|\"h\"\t|The number of whole hours in the time interval that are not counted as part of days. Single-digit hours do not have a leading zero. |15.01:45:30 -> 1, 15.13:45:30 -> 1\r\n|\"hh\"\t|The number of whole hours in the time interval that are not counted as part of days. Single-digit hours have a leading zero. |15.01:45:30 -> 01, 15.13:45:30 -> 01\r\n|\"H\"\t|The hour, using a 24-hour clock from 0 to 23. |15.01:45:30 -> 1, 15.13:45:30 -> 13\r\n|\"HH\"\t|The hour, using a 24-hour clock from 00 to 23. |15.01:45:30 -> 01, 15.13:45:30 -> 13\r\n|\"m\"\t|The number of whole minutes in the time interval that are not included as part of hours or days. Single-digit minutes do not have a leading zero. |15.01:09:30 -> 9, 15.13:29:30 -> 29\r\n|\"mm\"\t|The number of whole minutes in the time interval that are not included as part of hours or days. Single-digit minutes have a leading zero. |15.01:09:30 -> 09, 15.01:45:30 -> 45\r\n|\"s\"\t|The number of whole seconds in the time interval that are not included as part of hours, days, or minutes. Single-digit seconds do not have a leading zero. |15.13:45:09 -> 9\r\n|\"ss\"\t|The number of whole seconds in the time interval that are not included as part of hours, days, or minutes. Single-digit seconds have a leading zero. |15.13:45:09 -> 09\r\n\r\n\r\n**Supported delimeters**\r\n\r\n' ', '/', '-', ':', ',', '.', '_', '[', ']''", "```\r\nformat_timespan(time(29.09:00:05.12345), 'dd.hh:mm:ss [FF]')  //'29.09:00:05 [12]'\r\nformat_timespan(time(29.09:00:05.12345), 'ddd.h:mm:ss [fff]') //'029.9:00:05 [123]'\r\n```", "https://kusto.azurewebsites.net/docs/query/format-timespanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "gamma", "Computes [gamma function](https://en.wikipedia.org/wiki/Gamma_function)", "**Syntax**\r\n\r\n`gamma(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Parameter for the gamma function\r\n\r\n**Returns**\r\n\r\n* Gamma function of x.\r\n* For computing log-gamma function, see [loggamma()](loggammafunction.md).", "", "https://kusto.azurewebsites.net/docs/query/gammafunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "getmonth", "Get the month number (1-12) from a datetime.", "", "```\r\nT \r\n| extend month = getmonth(datetime(2015-10-12))\r\n// month == 10\r\n```", "https://kusto.azurewebsites.net/docs/query/getmonthfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "getschema", "Produce a table that represents a tabular schema of the input.", "T | summarize MyCount=count() by Country | getschema \r\n\r\n**Syntax**\r\n\r\n*T* `| ` `getschema`", "```\r\nStormEvents\r\n| top 10 by Timestamp\r\n| getschema\r\n```\r\n\r\n|ColumnName|ColumnOrdinal|DataType|ColumnType|\r\n|---|---|---|---|\r\n|Timestamp|0|System.DateTime|datetime|\r\n|Language|1|System.String|string|\r\n|Page|2|System.String|string|\r\n|Views|3|System.Int64|long\r\n|BytesDelivered|4|System.Int64|long", "https://kusto.azurewebsites.net/docs/query/getschemaoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "gettype", "Returns the runtime type of its single argument.", "The runtime type may be different than the nominal (static) type for expressions\r\nwhose nominal type is `dynamic`; in such cases `gettype()` can be useful to reveal\r\nthet type of the actual value (how the value is encoded in memory).\r\n\r\n**Syntax**\r\n\r\n* `gettype(`*Expr*`)`\r\n\r\n**Returns**\r\n\r\nA string representing the runtime type of its single argument.", "|Expression                          |Returns      |\r\n|------------------------------------|-------------|\r\n|`gettype(\"a\")`                      |`string`     |\r\n|`gettype(111)`                      |`long`       |\r\n|`gettype(1==1)`                     |`bool`       |\r\n|`gettype(now())`                    |`datetime`   |\r\n|`gettype(1s)`                       |`timespan`   |\r\n|`gettype(parsejson('1'))`           |`int`        |\r\n|`gettype(parsejson(' \"abc\" '))`     |`string`     |\r\n|`gettype(parsejson(' {\"abc\":1} '))` |`dictionary` | \r\n|`gettype(parsejson(' [1, 2, 3] '))` |`array`      |\r\n|`gettype(123.45)`                   |`real`       |\r\n|`gettype(guid(12e8b78d-55b4-46ae-b068-26d7a0080254))`|`guid`| \r\n|`gettype(parsejson(''))`            |`null`|", "https://kusto.azurewebsites.net/docs/query/gettypefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "getyear", "Returns the year part of the `datetime` argument.", "", "```\r\nT\r\n| extend year = getyear(datetime(2015-10-12))\r\n// year == 2015\r\n```", "https://kusto.azurewebsites.net/docs/query/getyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "hash", "Returns a hash value for the input value.", "**Syntax**\r\n\r\n`hash(`*source* [`,` *mod*]`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The value to be hashed.\r\n* *mod*: An optional module value to be applied to the hash result, so that\r\n  the output value is between `0` and *mod* - 1\r\n\r\n**Returns**\r\n\r\nThe hash value of the given scalar, modulo the given mod value (if specified).\r\n\r\n> [!WARNING]\r\n> The algorithm used to calculate the hash is xxhash.\r\n> This algorithm might change in the future, and the only guarantee is that\r\n> within a single query all invocations of this method use the same algorithm.\r\n> Consequently, users are advised to not store the results of `hash()` in a\r\n> table. If persisting hash values is required, consider using\r\n> [hash_sha256()](./sha256hashfunction.md) instead (but note that\r\n> it is far more complex to calculate than `hash()`).", "```\r\nhash(\"World\")                   // 1846988464401551951\r\nhash(\"World\", 100)              // 51 (1846988464401551951 % 100)\r\nhash(datetime(\"2015-01-01\"))    // 1380966698541616202\r\n```\r\n\r\nThe following example uses the hash function to run a query on 10% of the data,\r\nIt is helpful to use the hash function for sampling the data when assuming the value is uniformly distributed (In this example StartTime value)\r\n\r\n\r\n```\r\nStormEvents \r\n| where hash(StartTime, 10) == 0\r\n| summarize StormCount = count(), TypeOfStorms = dcount(EventType) by State \r\n| top 5 by StormCount desc\r\n```", "https://kusto.azurewebsites.net/docs/query/hashfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "hash_sha256", "Returns a sha256 hash value for the input value.", "**Syntax**\r\n\r\n`hash_sha256(`*source*`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The value to be hashed.\r\n\r\n**Returns**\r\n\r\nThe sha256 hash value of the given scalar, encoded as a hex string (a string\r\nof characters, each two of which represent a single Hex number between 0\r\nand 255).\r\n\r\n> [!WARNING]\r\n> The algorithm used by this function (SHA256) is guaranteed\r\n> to not be modified in the future, but is very complex to calculate. Users that\r\n> need a \"lightweight\" hash function for the duration of a single query are advised\r\n> to use the function [hash()](./hashfunction.md) instead.", "```\r\nhash_sha256(\"World\")                   // 78ae647dc5544d227130a0682a51e30bc7777fbb6d8a8f17007463a3ecd1d524\r\nhash_sha256(datetime(\"2015-01-01\"))    // e7ef5635e188f5a36fafd3557d382bbd00f699bd22c671c3dea6d071eb59fbf8\r\n\r\n```\r\n\r\nThe following example uses the hash_sha256 function to run a query on SatrtTime column of the data\r\n\r\n\r\n```\r\nStormEvents \r\n| where hash_sha256(StartTime) == 0\r\n| summarize StormCount = count(), TypeOfStorms = dcount(EventType) by State \r\n| top 5 by StormCount desc\r\n```", "https://kusto.azurewebsites.net/docs/query/sha256hashfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "hll", "Calculates the Intermediate results of [dcount](dcount-aggfunction.md) across the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md).\r\n\r\nRead more about the underlying algorithm (*H*yper*L*og*L*og) and the estimated error [here](dcount-aggfunction.md#estimation-error-of-dcount).\r\n\r\n**Syntax**\r\n\r\n`summarize` `hll(`*Expr* [`,` *Accuracy*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Accuracy*, if specified, controls the balance between speed and accuracy.\r\n    * `0` = the least accurate and fastest calculation. 1.6% error\r\n    * `1` = the default, which balances accuracy and calculation time; about 0.8% error.\r\n    * `2` = accurate and slow calculation; about 0.4% error.\r\n    * `3` = extra accurate and slow calculation; about 0.28% error.\r\n    * `4` = super accurate and slowest calculation; about 0.2% error.\r\n\t\r\n**Returns**\r\n\r\nThe Intermediate results of distinct count of *Expr* across the group.\r\n \r\n**Tips**\r\n\r\n1) You may use the aggregation function [hll_merge](hll-merge-aggfunction.md) to merge more than one hll intermediate results (it works on hll output only).\r\n\r\n2) You may use the function [dcount_hll] (dcount-hllfunction.md) which will calculate the dcount from hll / hll_merge aggregation functions.", "```\r\nStormEvents\r\n| summarize hll(DamageProperty) by bin(StartTime,10m)\r\n\r\n```\r\n\r\n|StartTime|hll_DamageProperty|\r\n|---|---|\r\n|2007-09-18 20:00:00.0000000|[[1024,14],[-5473486921211236216,-6230876016761372746,3953448761157777955,4246796580750024372],[]]|\r\n|2007-09-20 21:50:00.0000000|[[1024,14],[4835649640695509390],[]]|\r\n|2007-09-29 08:10:00.0000000|[[1024,14],[4246796580750024372],[]]|\r\n|2007-12-30 16:00:00.0000000|[[1024,14],[4246796580750024372,-8936707700542868125],[]]|", "https://kusto.azurewebsites.net/docs/query/hll-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "hll_merge", "Merges hll results (scalar version of the aggregate version [`hll_merge()`](hll-merge-aggfunction.md)).", "Read more about the underlying algorithm (*H*yper*L*og*L*og) and the estimated error [here](dcount-aggfunction.md#estimation-error-of-dcount).\r\n\r\n**Syntax**\r\n\r\n`hll_merge(` *Expr1*`,` *Expr2*`, ...)`\r\n\r\n**Arguments**\r\n\r\n* Columns which has the hll values to be merged.\r\n\r\n**Returns**\r\n\r\nThe result for merging the columns `*Exrp1*`, `*Expr2*`, ... `*ExprN*` to one hll value.", "```\r\nrange x from 1 to 10 step 1 \r\n| extend y = x + 10\r\n| summarize hll_x = hll(x), hll_y = hll(y)\r\n| project merged = hll_merge(hll_x, hll_y)\r\n| project dcount_hll(merged)\r\n```\r\n\r\n|dcount_hll_merged|\r\n|---|\r\n|20|", "https://kusto.azurewebsites.net/docs/query/hllmergefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "hourofday", "Returns the integer number representing the hour number of the given date", "hourofday(datetime(2015-12-14 18:54)) == 18\r\n\r\n**Syntax**\r\n\r\n`hourofday(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\n`hour number` of the day (0-23).", "", "https://kusto.azurewebsites.net/docs/query/hourofdayfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "iff", "Evaluates the first argument (the predicate), and returns the value of either the second or third arguments, depending on whether the predicate evaluated to `true` (second) or `false` (third).", "The second and third arguments must be of the same type.\r\n\r\n**Syntax**\r\n\r\n`iff(`*predicate*`,` *ifTrue*`,` *ifFalse*`)`\r\n\r\n**Arguments**\r\n\r\n* *predicate*: An expression that evaluates to a `boolean` value.\r\n* *ifTrue*: An expression that gets evaluated and its value returned from the function if *predicate* evaluates to `true`.\r\n* *ifFalse*: An expression that gets evaluated and its value returned from the function if *predicate* evaluates to `false`.\r\n\r\n**Returns**\r\n\r\nThis function returns the value of *ifTrue* if *predicate* evaluates to `true`,\r\nor the value of *ifFalse* otherwise.", "```\r\nT \r\n| extend day = iff(floor(Timestamp, 1d)==floor(now(), 1d), \"today\", \"anotherday\")\r\n```", "https://kusto.azurewebsites.net/docs/query/ifffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "iif", "Evaluates the first argument (the predicate), and returns the value of either the second or third arguments, depending on whether the predicate evaluated to `true` (second) or `false` (third).", "The second and third arguments must be of the same type.\r\n\r\n**Syntax**\r\n\r\n`iif(`*predicate*`,` *ifTrue*`,` *ifFalse*`)`\r\n\r\n**Arguments**\r\n\r\n* *predicate*: An expression that evaluates to a `boolean` value.\r\n* *ifTrue*: An expression that gets evaluated and its value returned from the function if *predicate* evaluates to `true`.\r\n* *ifFalse*: An expression that gets evaluated and its value returned from the function if *predicate* evaluates to `false`.\r\n\r\n**Returns**\r\n\r\nThis function returns the value of *ifTrue* if *predicate* evaluates to `true`,\r\nor the value of *ifFalse* otherwise.", "```\r\nT \r\n| extend day = iif(floor(Timestamp, 1d)==floor(now(), 1d), \"today\", \"anotherday\")\r\n```\r\n\r\nAn alias for [`iff()`](ifffunction.md).", "https://kusto.azurewebsites.net/docs/query/iiffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "in", "Filters a recordset based on the provided set of values.", "Table1 | where col in ('value1', 'value2')\r\n\r\n\r\n**Syntax**\r\n\r\n*Case sensitive syntax:*\r\n\r\n*T* `|` `where` *col* `in` `(`*list of scalar expressions*`)`   \r\n*T* `|` `where` *col* `in` `(`*tabular expression*`)`   \r\n \r\n*T* `|` `where` *col* `!in` `(`*list of scalar expressions*`)`  \r\n*T* `|` `where` *col* `!in` `(`*tabular expression*`)`   \r\n\r\n*Case insensitive syntax:*\r\n\r\n*T* `|` `where` *col* `in~` `(`*list of scalar expressions*`)`   \r\n*T* `|` `where` *col* `in~` `(`*tabular expression*`)`   \r\n \r\n*T* `|` `where` *col* `!in~` `(`*list of scalar expressions*`)`  \r\n*T* `|` `where` *col* `!in~` `(`*tabular expression*`)`   \r\n\r\n**Arguments**\r\n\r\n* *T* - The tabular input whose records are to be filtered.\r\n* *col* - the column to filter.\r\n* *list of expressions* - a comma separated list of tabular, scalar or literal expressions  \r\n* *tabular expression* - a tabular expression that has a set of values (in a case expression has multiple columns, the first column is used)\r\n\r\n**Returns**\r\n\r\nRows in *T* for which the predicate is `true`\r\n\r\n**Notes**\r\n\r\n* The expression list can produce up to `1,000,000` values    \r\n* Nested arrays are flattened into a single list of values, for example `x in (dynamic([1,[2,3]]))` turns into `x in (1,2,3)` \r\n* In case of tabular expressions, the first column of the result set is selected   \r\n* Adding '~' to operator makes values' search case insensitive: `x in~ (expresion)` or `x !in~ (expression)`.\r\n\r\n**Examples:**  \r\n\r\n**A simple usage of 'in' operator:**  \r\n\r\n\r\n```\r\nStormEvents \r\n| where State in (\"FLORIDA\", \"GEORGIA\", \"NEW YORK\") \r\n| count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|4775|  \r\n\r\n\r\n**A simple usage of 'in~' operator:**  \r\n\r\n\r\n```\r\nStormEvents \r\n| where State in~ (\"Florida\", \"Georgia\", \"New York\") \r\n| count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|4775|  \r\n\r\n**A simple usage of '!in' operator:**  \r\n\r\n\r\n```\r\nStormEvents \r\n| where State !in (\"FLORIDA\", \"GEORGIA\", \"NEW YORK\") \r\n| count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|54291|  \r\n\r\n\r\n**Using dynamic array:**\r\n\r\n```\r\nlet states = dynamic(['FLORIDA', 'ATLANTIC SOUTH', 'GEORGIA']);\r\nStormEvents \r\n| where State in (states)\r\n| count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|3218|\r\n\r\n\r\n**A subquery example:**  \r\n\r\n\r\n```\r\n// Using subquery\r\nlet Top_5_States = \r\nStormEvents\r\n| summarize count() by State\r\n| top 5 by count_; \r\nStormEvents \r\n| where State in (Top_5_States) \r\n| count\r\n```\r\n\r\nThe same query can be written as:\r\n\r\n\r\n```\r\n// Inline subquery \r\nStormEvents \r\n| where State in (\r\n    ( StormEvents\r\n    | summarize count() by State\r\n    | top 5 by count_ )\r\n) \r\n| count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|14242|  \r\n\r\n**Top with other example:**  \r\n\r\n\r\n```\r\nlet Death_By_State = materialize(StormEvents | summarize deaths = sum(DeathsDirect) by State);\r\nlet Top_5_States = Death_By_State | top 5 by deaths | project State; \r\nDeath_By_State\r\n| extend State = iif(State in (Top_5_States), State, \"Other\")\r\n| summarize sum(deaths) by State \r\n\r\n\r\n```\r\n\r\n|State|sum_deaths|\r\n|---|---|\r\n|ALABAMA|29|\r\n|ILLINOIS|29|\r\n|CALIFORNIA|48|\r\n|FLORIDA|57|\r\n|TEXAS|71|\r\n|Other|286|\r\n\r\n\r\n**Using a static list returned by a function:**  \r\n\r\n\r\n```\r\nStormEvents | where State in (InterestingStates()) | count\r\n\r\n```\r\n\r\n|Count|\r\n|---|\r\n|4775|  \r\n\r\n\r\nHere is the function definition:  \r\n\r\n\r\n```\r\n.show function InterestingStates\r\n\r\n```\r\n\r\n|Name|Parameters|Body|Folder|DocString|\r\n|---|---|---|---|---|\r\n|InterestingStates|()|{ dynamic([\"WASHINGTON\", \"FLORIDA\", \"GEORGIA\", \"NEW YORK\"]) }", "", "https://kusto.azurewebsites.net/docs/query/inoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "indexof", "Function reports the zero-based index of the first occurrence of a specified string within input string.", "If lookup or input string is not of string type - forcibly casts the value to string.\r\n\r\n**Syntax**\r\n\r\n`indexof(`*source*`,`*lookup*`[,`*start_index*`[,`*length*`]])`\r\n\r\n**Arguments**\r\n\r\n* *source*: input string.  \r\n* *lookup*: string to seek.\r\n* *start_index*: search start position (optional).\r\n* *length*: number of character positions to examine (optional).\r\n\r\n**Returns**\r\n\r\nZero-based index position of *lookup*.\r\n\r\nReturns -1 if the string is not found in the input.\r\n\r\nIn case of irrelevant (less than 0) *start_index* or *length* parameter - returns *null*.", "```\r\nprint\r\n idx1 = indexof(\"abcdefg\",\"cde\")    // lookup found in input string\r\n , idx2 = indexof(\"abcdefg\",\"cde\",1,4) // lookup found in researched range \r\n , idx3 = indexof(\"abcdefg\",\"cde\",1,2) // search starts from index 1, but stops after 2 chars, so full lookup can't be found\r\n , idx4 = indexof(\"abcdefg\",\"cde\",3,4) // search starts after occurrence of lookup\r\n , idx5 = indexof(\"abcdefg\",\"cde\",-1)  // invalid input\r\n , idx6 = indexof(1234567,5,1,4)       // two first parameters were forcibly casted to strings \"12345\" and \"5\"\r\n```\r\n\r\n|idx1|idx2|idx3|idx4|idx5|idx6|\r\n|----|----|----|----|----|----|\r\n|2   |2   |-1  |-1  |    |4   |", "https://kusto.azurewebsites.net/docs/query/indexoffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "ingestion_time", "Retrieves the record's `$IngestionTime` hidden `datetime` column, or null.", "The `$IngestionTime` column is automatically defined when the table's\r\n[IngestionTime policy](../concepts/ingestiontimepolicy.md) is set (enabled).\r\nIf the table does not have this policy defined, a null value is returned.\r\n\r\nThis function must be used in the context of an actual table in order\r\nto return the relevant data. (For example, it will return null for all records\r\nif it is invoked following a `summarize` operator).\r\n\r\n**Syntax**\r\n\r\n `ingestion_time()`\r\n\r\n**Returns**\r\n\r\nA `datetime` value specifying the approximate time of ingestion into a table.", "```\r\nT \r\n| extend ingestionTime = ingestion_time() | top 10 by ingestionTime\r\n```", "https://kusto.azurewebsites.net/docs/query/ingestiontimefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "invoke", "Invokes lambda that receives the source of `invoke` as tablular parameter argument.", "T | invoke foo(param1, param2)\r\n\r\n**Syntax**\r\n\r\n`T | invoke` *function*`(`[*param1*`,` *param2*]`)`\r\n\r\n**Arguments**\r\n\r\n* *T*: The tabular source.\r\n* *function*: The name of the lambda expression or function name to be evaluated.\r\n* *param1*, *param2* ... : additional lambda arguments.\r\n\r\n**Returns**\r\n\r\nReturns the result of the evaluated expression.\r\n\r\n**Notes**\r\n\r\nSee [let statements](./letstatement.md) for more details how to declare lambda expressions that can accept tabular arguments.", "The following example shows how to use `invoke` operator to call lambda expression:\r\n\r\n\r\n```\r\n// clipped_average(): calculates percentiles limits, and then makes another \r\n//                    pass over the data to calcualte average with values inisde the percentiles\r\nlet clipped_average = (T:(x: long), lowPercentile:double, upPercentile:double)\r\n{\r\n   let high = toscalar(T | summarize percentiles(x, upPercentile));\r\n   let low = toscalar(T | summarize percentiles(x, lowPercentile));\r\n   T \r\n   | where x > low and x < high\r\n   | summarize avg(x) \r\n};\r\nrange x from 1 to 100 step 1\r\n| invoke clipped_average(5, 99)\r\n```\r\n\r\n|avg_x|\r\n|---|\r\n|52|", "https://kusto.azurewebsites.net/docs/query/invokeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "iscolumnexists", "Returns a boolean value indicating if the given string argument exists in the schema produced by the preceding tabular operator.", "**Syntax**\r\n\r\n`iscolumnexists(`*value*`)\r\n\r\n**Arguments**\r\n\r\n* *value*: A string\r\n\r\n**Returns**\r\n\r\nA boolean indicating if the given string argument exists in the schema produced by the preceding tabular operator.\r\n**Examples**\r\n\r\n\r\n```\r\n.create function with (docstring = \"Returns a boolean indicating whether a column exists in a table\", folder=\"My Functions\")\r\nDoesColumnExistInTable(tableName:string, columnName:string)\r\n{\r\n\ttable(tableName) | limit 1 | project ColumnExists = iscolumnexists(columnName) \r\n}\r\n\r\nDoesColumnExistInTable(\"StormEvents\", \"StartTime\")\r\n```", "", "https://kusto.azurewebsites.net/docs/query/iscolumnexistsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isempty", "Returns `true` if the argument is an empty string or is null.", "isempty(\"\") == true\r\n\r\n**Syntax**\r\n\r\n`isempty(`[*value*]`)`\r\n\r\n**Returns**\r\n\r\nIndicates whether the argument is an empty string or isnull.\r\n\r\n|x|isempty(x)\r\n|---|---\r\n| \"\" | true\r\n|\"x\" | false\r\n|parsejson(\"\")|true\r\n|parsejson(\"[]\")|false\r\n|parsejson(\"{}\")|false", "```\r\nT\r\n| where isempty(fieldName)\r\n| count\r\n```", "https://kusto.azurewebsites.net/docs/query/isemptyfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isfinite", "Returns whether input is a finite value (is neither infinite nor NaN).", "**Syntax**\r\n\r\n`isfinite(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\nA non-zero value (true) if x is finite; and zero (false) otherwise.\r\n\r\n**See also**\r\n\r\n* For checking if value is null, see [isnull()](isnullfunction.md).\r\n* For checking if value is infinite, see [isinf()](isinffunction.md).\r\n* For checking if value is NaN (Not-a-Number), see [isnan()](isnanfunction.md).", "```\r\nrange x from -1 to 1 step 1\r\n| extend y = 0.0\r\n| extend div = 1.0*x/y\r\n| extend isfinite=isfinite(div)\r\n```\r\n\r\n|x|y|div|isfinite|\r\n|---|---|---|---|\r\n|-1|0|-â|0|\r\n|0|0|NaN|0|\r\n|1|0|â|0|", "https://kusto.azurewebsites.net/docs/query/isfinitefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isinf", "Returns whether input is an infinite (positive or negative) value.", "**Syntax**\r\n\r\n`isinf(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\nA non-zero value (true) if x is a positive or negative infinite; and zero (false) otherwise.\r\n\r\n**See also**\r\n\r\n* For checking if value is null, see [isnull()](isnullfunction.md).\r\n* For checking if value is finite, see [isfinite()](isfinitefunction.md).\r\n* For checking if value is NaN (Not-a-Number), see [isnan()](isnanfunction.md).", "```\r\nrange x from -1 to 1 step 1\r\n| extend y = 0.0\r\n| extend div = 1.0*x/y\r\n| extend isinf=isinf(div)\r\n```\r\n\r\n|x|y|div|isinf|\r\n|---|---|---|---|\r\n|-1|0|-â|1|\r\n|0|0|NaN|0|\r\n|1|0|â|1|", "https://kusto.azurewebsites.net/docs/query/isinffunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isnan", "Returns whether input is Not-a-Number (NaN) value.", "**Syntax**\r\n\r\n`isnan(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\nA non-zero value (true) if x is NaN; and zero (false) otherwise.\r\n\r\n**See also**\r\n\r\n* For checking if value is null, see [isnull()](isnullfunction.md).\r\n* For checking if value is finite, see [isfinite()](isfinitefunction.md).\r\n* For checking if value is infinite, see [isinf()](isinffunction.md).", "```\r\nrange x from -1 to 1 step 1\r\n| extend y = (-1*x) \r\n| extend div = 1.0*x/y\r\n| extend isnan=isnan(div)\r\n```\r\n\r\n|x|y|div|isnan|\r\n|---|---|---|---|\r\n|-1|1|-1|0|\r\n|0|0|NaN|1|\r\n|1|-1|-1|0|", "https://kusto.azurewebsites.net/docs/query/isnanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isnotempty", "Returns `true` if the argument is not an empty string nor it is a null.", "isnotempty(\"\") == false\r\n\r\n**Syntax**\r\n\r\n`isnotempty(`[*value*]`)`\r\n\r\n`notempty(`[*value*]`)` -- alias of `isnotempty`", "", "https://kusto.azurewebsites.net/docs/query/isnotemptyfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isnotnull", "Returns `true` if the argument is not null.", "**Syntax**\r\n\r\n`isnotnull(`[*value*]`)`\r\n\r\n`notnull(`[*value*]`)` - alias for `isnotnull`", "```\r\nT | where isnotnull(PossiblyNull) | count\r\n```\r\n\r\nNotice that there are other ways of achieving this effect:\r\n\r\n\r\n```\r\nT | summarize count(PossiblyNull)\r\n```", "https://kusto.azurewebsites.net/docs/query/isnotnullfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "isnull", "Evaluates its sole argument and returns a `bool` value indicating if the argument evaluates to a null value.", "isnull(parsejson(\"\")) == true\r\n\r\n**Syntax**\r\n\r\n`isnull(`*Expr*`)`\r\n\r\n**Returns**\r\n\r\nTrue or false depending on the whether the value is null or not null.\r\n\r\n**Comments**\r\n\r\n* `string` values cannot be null. Use [isempty](./isemptyfunction.md)\r\n  to determine if a value of type `string` is empty or not.\r\n\r\n|x                |`isnull(x)`|\r\n|-----------------|-----------|\r\n|`\"\"`             |`false`    |\r\n|`\"x\"`            |`false`    |\r\n|`parsejson(\"\")`  |`true`     |\r\n|`parsejson(\"[]\")`|`false`    |\r\n|`parsejson(\"{}\")`|`false`    |", "```\r\nT | where isnull(PossiblyNull) | count\r\n```", "https://kusto.azurewebsites.net/docs/query/isnullfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "join", "Merge the rows of two tables to form a new table by matching values of the specified column(s) from each table.", "Table1 | join (Table2) on CommonColumn, $left.Col1 == $right.Col2\r\n\r\n**Syntax**\r\n\r\n*LeftTable* `|` `join` [*JoinParameters*] `(` *RightTable* `)` `on` *Attributes*\r\n\r\n**Arguments**\r\n\r\n* *LeftTable*: The **left** table or tabular expression (sometimes called **outer** table) whose rows are to be merged. Denoted as `$left`.\r\n\r\n* *RightTable*: The **right** table or tabular expression (sometimes called **inner* table) whose rows are to be merged. Denoted as `$right`.\r\n\r\n* *Attributes*: One or more (comma-separated) rules that describe how rows from\r\n  *LeftTable* are matched to rows from *RightTable*. A rule can be one of:\r\n\r\n  |Rule kind        |Syntax                                          |Predicate                                                      |\r\n  |-----------------|------------------------------------------------|---------------------------------------------------------------|\r\n  |Equality by name |*ColumnName*                                    |`where` *LeftTable*.*ColumnName* `==` *RightTable*.*ColumnName*|\r\n  |Equality by value|`$left.`*LeftColumn* `==` `$right.`*RightColumn*|`where` `$left.`*LeftColumn* `==` `$right.`*RightColumn        |\r\n\r\n\r\n**Note:** In case of 'equality by value', the column names *must* be qualified with the applicable owner table denoted by `$left` and `$right` notations.\r\n\r\n* *JoinParameters*: Zero or more (space-separated) parameters in the form of\r\n  *Name* `=` *Value* that control the behavior\r\n  of the row-match operation and execution plan. The following parameters are supported: \r\n\r\n  |Name           |Values                                        |Description                                  |\r\n  |---------------|----------------------------------------------|---------------------------------------------|\r\n  |`kind`         |Join flavors|See [Join Flavors](#join-flavors)|                                             |\r\n  |`hint.remote`  |`auto`, `left`, `local`, `right`              |See [Cross-Cluster Join](joincrosscluster.md)|\r\n  |`hint.strategy`|Execution hints|See [Join hints](#join-hints) |                                             |\r\n\r\n**Returns**\r\n\r\nA table with:\r\n\r\n* A column for every column in each of the two tables, including the matching keys. The columns of the right side will be automatically renamed if there are name clashes.\r\n* A row for every match between the input tables. A match is a row selected from one table that has the same value for all the `on` fields as a row in the other table. \r\n\r\n * `kind` unspecified, `kind=innerunique`\r\n\r\n    Only one row from the left side is matched for each value of the `on` key. The output contains a row for each match of this row with rows from the right.\r\n\r\n * `Kind=inner`\r\n \r\n     There's a row in the output for every combination of matching rows from left and right.\r\n\r\n * `kind=leftouter` (or `kind=rightouter` or `kind=fullouter`)\r\n\r\n     In addition to the inner matches, there's a row for every row on the left (and/or right), even if it has no match. In that case, the unmatched output cells contain nulls.\r\n\r\n * `kind=leftanti` (or `kind=rightanti`)\r\n\r\n     Returns all the records from the left side that do not have matches from the right. The result table just has the columns from the left side. \r\n     Equivalent to `kind=leftantisemi`.\r\n\r\n * `kind=leftsemi` (or `kind=rightsemi`)\r\n\r\n     Returns all the records from the left side that have matches from the right. The result table contains columns from the left side only. \r\n \r\nIf there are several rows with the same values for those fields, you'll get rows for all the combinations.\r\n\r\n**Tips**\r\n\r\nFor best performance:\r\n\r\n* Use `where` and `project` to reduce the numbers of rows and columns in the input tables, before the `join`. \r\n* If one table is always smaller than the other, use it as the left (piped) side of the join.\r\n* The columns for the join match must have the same name. Use the project operator if necessary to rename a column in one of the tables.", "Get extended activities from a log in which some entries mark the start and end of an activity. \r\n\r\n\r\n```\r\nlet Events = MyLogTable | where type==\"Event\" ;\r\nEvents\r\n| where Name == \"Start\"\r\n| project Name, City, ActivityId, StartTime=timestamp\r\n| join (Events\r\n        | where Name == \"Stop\"\r\n        | project StopTime=timestamp, ActivityId)\r\n    on ActivityId\r\n| project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime\r\n```\r\n\r\n\r\n```\r\nlet Events = MyLogTable | where type==\"Event\" ;\r\nEvents\r\n| where Name == \"Start\"\r\n| project Name, City, ActivityIdLeft = ActivityId, StartTime=timestamp\r\n| join (Events\r\n        | where Name == \"Stop\"\r\n        | project StopTime=timestamp, ActivityIdRight = ActivityId)\r\n    on $left.ActivityIdLeft == $right.ActivityIdRight\r\n| project City, ActivityId, StartTime, StopTime, Duration, StopTime, StartTime\r\n```\r\n\r\n[More about this example](./samples.md#activities).\r\n\r\n## Join flavors\r\n\r\nThe exact flavor of the join operator is specified with the kind keyword. As of today, Kusto\r\nsupports the following flavors of the join operator: \r\n\r\n|Join kind|Description|\r\n|--|--|\r\n|[`innerunique`](#default-join-flavor) (or empty as default)|Inner join with left side deduplication|\r\n|[`inner`](#inner-join)|Standard inner join|\r\n|[`leftouter`](#left-outer-join)|Left outer join|\r\n|[`rightouter`](#right-outer-join)|Right outer join|\r\n|[`fullouter`](#full-outer-join)|Full outer join|\r\n|[`leftanti`](#left-anti-join), [`anti`](#left-anti-join) or [`leftantisemi`](#left-anti-join)|Left anti join|\r\n|[`rightanti`](#right-anti-join) or [`rightantisemi`](#right-anti-join)|Right anti join|\r\n|[`leftsemi`](#left-semi-join)|Left semi join|\r\n|[`rightsemi`](#right-semi-join)|Right semi join|\r\n\r\n \r\n### Default join flavor\r\n    \r\n    X | join Y on Key\r\n    X | join kind=innerunique Y on Key\r\n     \r\nLet's use two sample tables to explain the operation of the join: \r\n \r\nTable X \r\n\r\n|Key |Value1 \r\n|---|---\r\n|a |1 \r\n|b |2 \r\n|b |3 \r\n|c |4 \r\n\r\nTable Y \r\n\r\n|Key |Value2 \r\n|---|---\r\n|b |10 \r\n|c |20 \r\n|c |30 \r\n|d |40 \r\n \r\nThe default join performs an inner join after de-duplicating the left side on the join key (deduplication retains the first record). \r\nGiven this statement: \r\n\r\n    X | join Y on Key \r\n\r\nthe effective left side of the join (table X after de-duplication) would be: \r\n\r\n|Key |Value1 \r\n|---|---\r\n|a |1 \r\n|b |2 \r\n|c |4 \r\n\r\nand the result of the join would be: \r\n\r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join Y on Key\r\n```\r\n\r\n|Key|Value1|Key1|Value2|\r\n|---|---|---|---|\r\n|b|2|b|10|\r\n|c|4|c|20|\r\n|c|4|c|30|\r\n\r\n\r\n(Note that the keys 'a' and 'd' do not appear in the output, since there were no matching keys on both left and right sides). \r\n \r\n(Historically, this was the first implementation of the join supported by the initial version of Kusto; it is useful in the typical log/trace analysis scenarios where we want to correlate two events (each matching some filtering criterion) under the same correlation ID, and get back all appearances of the phenomenon we're looking for, ignoring multiple appearances of the contributing trace records.)\r\n \r\n### Inner join\r\n\r\nThis is the standard inner join as known from the SQL world. Output record is produced whenever a record on the left side has the same join key as the record on the right side. \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=inner Y on Key\r\n```\r\n\r\n|Key|Value1|Key1|Value2|\r\n|---|---|---|---|\r\n|b|3|b|10|\r\n|b|2|b|10|\r\n|c|4|c|20|\r\n|c|4|c|30|\r\n\r\nNote that (b,10) coming from the right side was joined twice: with both (b,2) and (b,3) on the left; also (c,4) on the left was joined twice: with both (c,20) and (c,30) on the right. \r\n\r\n### Left outer join \r\n\r\nThe result of a left outer join for tables X and Y always contains all records of the left table (X), even if the join condition does not find any matching record in the right table (Y). \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=leftouter Y on Key\r\n```\r\n\r\n|Key|Value1|Key1|Value2|\r\n|---|---|---|---|\r\n|b|3|b|10|\r\n|b|2|b|10|\r\n|c|4|c|20|\r\n|c|4|c|30|\r\n|a|1|||\r\n\r\n \r\n### Right outer join \r\n\r\nResembles the left outer join, but the treatment of the tables is reversed. \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=rightouter Y on Key\r\n```\r\n\r\n|Key|Value1|Key1|Value2|\r\n|---|---|---|---|\r\n|b|3|b|10|\r\n|b|2|b|10|\r\n|c|4|c|20|\r\n|c|4|c|30|\r\n|||d|40|\r\n\r\n \r\n### Full outer join \r\n\r\nConceptually, a full outer join combines the effect of applying both left and right outer joins. Where records in the joined tables do not match, the result set will have NULL values for every column of the table that lacks a matching row. For those records that do match, a single row will be produced in the result set (containing fields populated from both tables). \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=fullouter Y on Key\r\n```\r\n\r\n|Key|Value1|Key1|Value2|\r\n|---|---|---|---|\r\n|b|3|b|10|\r\n|b|2|b|10|\r\n|c|4|c|20|\r\n|c|4|c|30|\r\n|||d|40|\r\n|a|1|||\r\n\r\n \r\n### Left anti join\r\n\r\nLeft anti join returns all records from the left side that do not match any record from the right side. \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=leftanti Y on Key\r\n```\r\n\r\n|Key|Value1|\r\n|---|---|\r\n|a|1|\r\n\r\nAnti-join models the \"NOT IN\" query. \r\n\r\n### Right anti join\r\n\r\nRight anti join returns all records from the right side that do not match any record from the left side. \r\n \r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=rightanti Y on Key\r\n```\r\n\r\n|Key|Value2|\r\n|---|---|\r\n|d|40|\r\n\r\nAnti-join models the \"NOT IN\" query. \r\n\r\n### Left semi join\r\n\r\nLeft semi join returns all records from the left side that match a record from the right side. Only columns from the left side are returned. \r\n\r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=leftsemi Y on Key\r\n```\r\n\r\n|Key|Value1|\r\n|---|---|\r\n|b|3|\r\n|b|2|\r\n|c|4|\r\n\r\n### Right semi join\r\n\r\nRight semi join returns all records from the right side that match a record from the left side. Only columns from the right side are returned. \r\n\r\n\r\n```\r\nlet X = datatable(Key:string, Value1:long)\r\n[\r\n    'a',1,\r\n    'b',2,\r\n    'b',3,\r\n    'c',4\r\n];\r\nlet Y = datatable(Key:string, Value2:long)\r\n[\r\n    'b',10,\r\n    'c',20,\r\n    'c',30,\r\n    'd',40\r\n];\r\nX | join kind=rightsemi Y on Key\r\n```\r\n\r\n|Key|Value2|\r\n|---|---|\r\n|b|10|\r\n|c|20|\r\n|c|30|\r\n\r\n\r\n### Cross join\r\n\r\nKusto doesn't natively provide a cross-join flavor (i.e., you can't mark the operator with `kind=cross`).\r\nIt isn't difficult to simulate this, however, by coming up with a dummy key:\r\n\r\n    X | extend dummy=1 | join kind=inner (Y | extend dummy=1) on dummy\r\n\r\n## Join hints\r\n\r\nThe `join` operator supports a number of hints that control the way a query executes.\r\nThese do not change the semantic of `join`, but may affect its performance.", "https://kusto.azurewebsites.net/docs/query/joinoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "limit", "Return up to the specified number of rows.", " T | limit 5\r\n\r\n**Alias**\r\n\r\n[take operator](takeoperator.md)", "", "https://kusto.azurewebsites.net/docs/query/limitoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "log", "Returns the natural logarithm function.", "**Syntax**\r\n\r\n`log(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number > 0.\r\n\r\n**Returns**\r\n\r\n* The natural logarithm is the base-e logarithm: the inverse of the natural exponential function (exp).\r\n* For common (base-10) logarithms, see [log10()](log10-function.md).\r\n* For base-2 logarithms, see [log2()](log2-function.md)\r\n* `null` if the argument is negative or null or cannot be converted to a `real` value.", "", "https://kusto.azurewebsites.net/docs/query/log-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "log10", "Retuns the comon (base-10) logarithm function.", "**Syntax**\r\n\r\n`log10(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number > 0.\r\n\r\n**Returns**\r\n\r\n* The common logarithm is the base-10 logarithm: the inverse of the exponential function (exp) with base 10.\r\n* For natural (base-e) logarithms, see [log()](log-function.md).\r\n* For base-2 logarithms, see [log2()](log2-function.md)\r\n* `null` if the argument is negative or null or cannot be converted to a `real` value.", "", "https://kusto.azurewebsites.net/docs/query/log10-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "log2", "Returns the base-2 logarithm function.", "**Syntax**\r\n\r\n`log2(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number > 0.\r\n\r\n**Returns**\r\n\r\n* The logarithm is the base-2 logarithm: the inverse of the exponential function (exp) with base 2.\r\n* For natural (base-e) logarithms, see [log()](log-function.md).\r\n* For common (base-10) logarithms, see [log10()](log10-function.md)\r\n* `null` if the argument is negative or null or cannot be converted to a `real` value.", "", "https://kusto.azurewebsites.net/docs/query/log2-function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "loggamma", "Computes log of absolute value of the [gamma function](https://en.wikipedia.org/wiki/Gamma_function)", "**Syntax**\r\n\r\n`loggamma(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Parameter for the gamma function\r\n\r\n**Returns**\r\n\r\n* Returns the natural logarithm of the absolute value of the gamma function of x.\r\n* For computing gamma function, see [gamma()](gammafunction.md).", "", "https://kusto.azurewebsites.net/docs/query/loggammafunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "make_datetime", "Creates a [datetime](./scalar-data-types/datetime.md) scalar value from the specified date and time.", "make_datetime(2017,10,01,12,10) == datetime(2017-10-01 12:10)\r\n\r\n**Syntax**\r\n\r\n`make_datetime(`*year*,*month*,*day*`)`\r\n\r\n`make_datetime(`*year*,*month*,*day*,*hour*,*minute*`)`\r\n\r\n`make_datetime(`*year*,*month*,*day*,*hour*,*minute*,*second*`)`\r\n\r\n**Arguments**\r\n\r\n* *year*: year (an integer value, from 0 to 9999)\r\n* *month*: month (an integer value, from 1 to 12)\r\n* *day*: day (an integer value, from 1 to 28-31)\r\n* *hour*: hour (an integer value, from 0 to 23)\r\n* *minute*: minute (an integer value, from 0 to 59)\r\n* *second*: second (a real value, from 0 to 59.9999999)\r\n\r\n**Returns**\r\n\r\nIf creation is successful, result will be a [datetime](./scalar-data-types/datetime.md) value, otherwise, result will be null.", "```\r\nprint year_month_day = make_datetime(2017,10,01)\r\n```\r\n\r\n|year_month_day|\r\n|---|\r\n|2017-10-01 00:00:00.0000000|\r\n\r\n\r\n\r\n\r\n\r\n```\r\nprint year_month_day_hour_minute = make_datetime(2017,10,01,12,10)\r\n```\r\n\r\n|year_month_day_hour_minute|\r\n|---|\r\n|2017-10-01 12:10:00.0000000|\r\n\r\n\r\n\r\n\r\n\r\n```\r\nprint year_month_day_hour_minute_second = make_datetime(2017,10,01,12,11,0.1234567)\r\n```\r\n\r\n|year_month_day_hour_minute_second|\r\n|---|\r\n|2017-10-01 12:11:00.1234567|", "https://kusto.azurewebsites.net/docs/query/make-datetimefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "make_dictionary", "Returns a `dynamic` (JSON) property-bag (dictionary) of all the values of *Expr* in the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `make_dictionary(`*Expr* [`,` *MaxListSize*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression of type `dynamic` that will be used for aggregation calculation.\r\n* *MaxListSize* is an optional integer limit on the maximum number of elements returned (default is *128*).\r\n\r\n**Returns**\r\n\r\nReturns a `dynamic` (JSON) property-bag (dictionary) of all the values of *Expr* in the group which are property-bags (dictionaries).\r\nNon-dictionary values will be skipped.\r\nIf a key appears in more than one row- an arbitrary value (out of the possible values for this key) will be chosen.\r\n\r\n**See also**\r\n\r\nSee [bag_unpack()](bag-unpackplugin.md) plugin for expanding dynamic JSON objects into columns using property bag keys.", "```\r\nlet T = datatable(prop:string, value:string)\r\n[\r\n    \"prop01\", \"val_a\",\r\n    \"prop02\", \"val_b\",\r\n    \"prop03\", \"val_c\",\r\n];\r\nT\r\n| extend p = pack(prop, value)\r\n| summarize dict=make_dictionary(p)\r\n\r\n```\r\n\r\n|dict|\r\n|----|\r\n|{ \"prop01\": \"val_a\", \"prop02\": \"val_b\", \"prop03\": \"val_c\" } |", "https://kusto.azurewebsites.net/docs/query/make-dictionary-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "make_string", "Returns the string generated by the Unicode characters.", "**Syntax**\r\n\r\n`make_string (`*Arg1* [, *ArgN*]... `)`\r\n\r\n**Arguments**\r\n\r\n* *Arg1* ... *ArgN* : expressions which are integers (int or long) or a dynamic value holding an array of integral numbers.\r\n\r\n* This function receives up to 64 arguments. \r\n\r\n**Returns**\r\n\r\nReturns the string made of the Unicode characters whose codepoint value is provided by the arguments to this function. The input must consist of valid Unicode codepoints.\r\nIf any argument is not mapped to a Unicode char, the function returns null.", "```\r\nprint str = make_string(75, 117, 115, 116, 111)\r\n```\r\n\r\n|str|\r\n|---|\r\n|Kusto|\r\n    \r\n\r\n```\r\nprint str = make_string(dynamic([75, 117, 115, 116, 111]))\r\n```\r\n\r\n|str|\r\n|---|\r\n|Kusto|\r\n\r\n\r\n```\r\nprint str = make_string(dynamic([75, 117, 115]), 116, 111)\r\n```\r\n\r\n|str|\r\n|---|\r\n|Kusto|\r\n\r\n\r\n```\r\nprint str = make_string(75, 10, 117, 10, 115, 10, 116, 10, 111)\r\n```\r\n\r\n|str|\r\n|---|\r\n|K<br>u<br>s<br>t<br>o|", "https://kusto.azurewebsites.net/docs/query/makestringfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "make_timespan", "Creates a [timespan](./scalar-data-types/timespan.md) scalar value from the specified time period.", "make_timespan(1,12,30,55.123) == time(1.12:30:55.123)\r\n\r\n**Syntax**\r\n\r\n`make_timespan(`*hour*,*minute*`)`\r\n\r\n`make_timespan(`*hour*,*minute*,*second*`)`\r\n\r\n`make_timespan(`*day*,*hour*,*minute*,*second*`)`\r\n\r\n**Arguments**\r\n\r\n* *day*: day (a positive integer value)\r\n* *hour*: hour (an integer value, from 0 to 23)\r\n* *minute*: minute (an integer value, from 0 to 59)\r\n* *second*: second (a real value, from 0 to 59.9999999)\r\n\r\n**Returns**\r\n\r\nIf creation is successful, result will be a [timespan](./scalar-data-types/timespan.md) value, otherwise, result will be null.", "```\r\nprint ['timespan'] = make_timespan(1,12,30,55.123)\r\n\r\n```\r\n\r\n|timespan|\r\n|---|\r\n|1.12:30:55.1230000|", "https://kusto.azurewebsites.net/docs/query/make-timespanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "makelist", "Returns a `dynamic` (JSON) array of all the values of *Expr* in the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `makelist(`*Expr*` [`,` *MaxListSize*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation.\r\n* *MaxListSize* is an optional integer limit on the maximum number of elements returned (default is *128*).\r\n\r\n**Returns**\r\n\r\nReturns a `dynamic` (JSON) array of all the values of *Expr* in the group.\r\nIf the input to the `summarize` operator is not sorted, the order of elements in the resulting array is undefined.\r\nIf the input to the `summarize` operator is sorted, the order of elements in the resulting array tracks that of the input.", "", "https://kusto.azurewebsites.net/docs/query/makelist-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "make-series", "Create series of specified aggregated values along specified axis.", "T | make-series sum(amount) default=0, avg(price) default=0 on timestamp in range(datetime(2016-01-01), datetime(2016-01-10), 1d) by fruit, supplier\r\n\r\nA table that shows arrays of the numbers and average prices of each fruit from each supplier ordered by the timestamp with specified range. There's a row in the output for each distinct combination of fruit and supplier. The output columns show the fruit, supplier and arrays of: count, average and the whole time line (from 2016-01-01 until 2016-01-10). All arrays are sorted by the respective timestamp and all gaps are filled with default values (0 in this example). All other input columns are ignored.\r\n\r\n**Syntax**\r\n\r\n*T* `| make-series`\r\n      [*Column* `=`] *Aggregation* [`default` `=` *DefaultValue*] [`,` ...]\r\n    `on` *AxisColumn* `in` `range(`*start*`,` *stop*`,` *step*`)`\r\n    [`by`\r\n      [*Column* `=`] *GroupExpression* [`,` ...]]\r\n\r\n**Arguments**\r\n\r\n* *Column:* Optional name for a result column. Defaults to a name derived from the expression.\r\n* *DefaultValue:* Default value which will be used instead of absent values. If there is no row with specific values of *AxisColumn* and *GroupExpression* then in the results the corresponding element of the array will be assigned with a *DefaultValue*. If `default =` *DefaultValue* is omitted then 0 is assumed. \r\n* *Aggregation:* A call to an [aggregation function](make-seriesoperator.md#list-of-aggregation-functions) such as `count()` or `avg()`, with column names as arguments. See the [list of aggregation functions](make-seriesoperator.md#list-of-aggregation-functions). Note that only aggregation functions that return numeric result can be used with `make-series` operator.\r\n* *AxisColumn:* A column on which the series will be ordered. It could be considered as timeline, but besides `datetime` any numeric types are accepted.\r\n* *start*: The low bound value of the *AxisColumn* for each the series will be built. Similar to the `range` function *start*, *stop* and *step* are used to build array of *AxisColumn* values within a given range and using specified *step*. All *Aggregation* values are ordered respectively to this array. This *AxisColumn* array is also the last output column in the output with the same name as *AxisColumn*.\r\n* *stop*: The high bound value of the *AxisColumn* for each the series will be built or the least value that is greater than the last element in the resulting array and within an integer multiple of *step* from *start*.\r\n* *step*: The difference between two consecutive elements of the *AxisColumn* array (i.e. the bin size).\r\n* *GroupExpression:* An expression over the columns, that provides a set of distinct values. Typically it's a column name that already provides a restricted set of values. \r\n\r\n**Returns**\r\n\r\nThe input rows are arranged into groups having the same values of the `by` expressions and `bin(`*AxisColumn*`, `*step*`)` expression. Then the specified aggregation functions are computed over each group, producing a row for each group. The result contains the `by` columns, *AxisColumn* column and also at least one column for each computed aggregate. (Aggregation that multiple columns or non-numeric results are not supported.)\r\n\r\nThis intermediate result has as many rows as there are distinct combinations of `by` and `bin(`*AxisColumn*`,` *step*`)` values.\r\n\r\nFinally the rows from the intermediate result arranged into groups having the same values of the `by` expressions and all aggregated values are arranged into arrays (values of `dynamic` type). For each aggregation there is one column containing its array with the same name. The last column in the output of the range function with all *AxisColumn* values. Its value is repeated for all rows. \r\n\r\nNote that due to the fill missing bins by default value, the resulting pivot table has the same number of bins (i.e. aggregated values) for all series  \r\n\r\n**Note**\r\n\r\nAlthough you can provide arbitrary expressions for both the aggregation and grouping expressions, it's more efficient to use simple column names.\r\n \r\n\r\n## List of aggregation functions\r\n\r\n|Function|Description|\r\n|--------|-----------|\r\n|[any()](any-aggfunction.md)|Returns random non-empty value for the group|\r\n|[avg()](avg-aggfunction.md)|Retuns average value across the group|\r\n|[count()](count-aggfunction.md)|Returns count of the group|\r\n|[countif()](countif-aggfunction.md)|Returns count with the predicate of the group|\r\n|[dcount()](dcount-aggfunction.md)|Returns approximate distinct count of the group elements|\r\n|[max()](max-aggfunction.md)|Returns the maximum value across the group|\r\n|[min()](min-aggfunction.md)|Returns the minimum value across the group|\r\n|[stdev()](stdev-aggfunction.md)|Returns the standard deviation across the group|\r\n|[sum()](sum-aggfunction.md)|Returns the sum of the elements withing the group|\r\n|[variance()](variance-aggfunction.md)|Returns the variance across the group|\r\n\r\n## List of series analysis functions\r\n\r\n|Function|Description|\r\n|--------|-----------|\r\n|[series_fir()](series-firfunction.md)|Applies [Finite Impulse Response](https://en.wikipedia.org/wiki/Finite_impulse_response) filter|\r\n|[series_iir()](series-iirfunction.md)|Applies [Infinite Impulse Response](https://en.wikipedia.org/wiki/Infinite_impulse_response) filter|\r\n|[series_fit_line()](series-fit-linefunction.md)|Finds a straight line that is the best approximation of the input|\r\n|[series_fit_line_dynamic()](series-fit-line-dynamicfunction.md)|Finds a line that is the best approximation of the input, returning dynamic object|\r\n|[series_fit_2lines()](series-fit-2linesfunction.md)|Finds two lines that is the best approximation of the input|\r\n|[series_fit_2lines_dynamic()](series-fit-2lines-dynamicfunction.md)|Finds two lines that is the best approximation of the input, returning dynamic object|\r\n|[series_outliers()](series-outliersfunction.md)|Scores anomaly points in a series|\r\n|[series_periods_detect()](series-periods-detectfunction.md)|Finds the most significant periods that exist in a time series|\r\n|[series_periods_validate()](series-periods-validatefunction.md)|Checks whether a time series contains periodic patterns of given lengths|\r\n|[series_stats_dynamic()](series-stats-dynamicfunction.md)|Return multiple columns with the common statistics (min/max/variance/stdev/average)|\r\n|[series_stats()](series-statsfunction.md)|Generates a dynamic value with the common statistics (min/max/variance/stdev/average)|\r\n  \r\n## List of series interpolation functions\r\n|Function|Description|\r\n|--------|-----------|\r\n|[series_fill_backward()](series-fill-backwardfunction.md)|Performs backward fill interpolation of missing values in a series|\r\n|[series_fill_const()](series-fill-constfunction.md)|Replaces missing values in a series with a specified constant value|\r\n|[series_fill_forward()](series-fill-forwardfunction.md)|Performs forward fill interpolation of missing values in a series|\r\n|[series_fill_linear()](series-fill-linearfunction.md)|Performs linear interpolation of missing values in a series|\r\n\r\n* Note: Interpolation functions by default assume `null` as a missing value. Therefore it is recommended to specify `default=`*double*(`null`) in `make-series` if you intend to use interpolation functions for the series.", "```\r\nT | make-series PriceAvg=avg(Price) default=0\r\non Purchase in range(datetime(2016-09-10), datetime(2016-09-12), 1d) by Supplier, Fruit\r\n```\r\n  \r\n![alt text](./Images/aggregations/makeseries.png \"makeseries\")\r\n  \r\n\r\n```\r\nlet data=datatable(timestamp:datetime, metric: real)\r\n[\r\n  datetime(2016-12-31T06:00), 50,\r\n  datetime(2017-01-01), 4,\r\n  datetime(2017-01-02), 3,\r\n  datetime(2017-01-03), 4,\r\n  datetime(2017-01-03T03:00), 6,\r\n  datetime(2017-01-05), 8,\r\n  datetime(2017-01-05T13:40), 13,\r\n  datetime(2017-01-06), 4,\r\n  datetime(2017-01-07), 3,\r\n  datetime(2017-01-08), 8,\r\n  datetime(2017-01-08T21:00), 8,\r\n  datetime(2017-01-09), 2,\r\n  datetime(2017-01-09T12:00), 11,\r\n  datetime(2017-01-10T05:00), 5,\r\n];\r\nlet interval = 1d;\r\nlet stime = datetime(2017-01-01);\r\nlet etime = datetime(2017-01-09);\r\ndata\r\n| make-series avg(metric) on timestamp in range(stime, etime, interval)  \r\n```\r\n  \r\n|avg_metric|timestamp|\r\n|---|---|\r\n|[ 4.0, 3.0, 5.0, 0.0, 10.5, 4.0, 3.0, 8.0, 6.5 ]|[ \"2017-01-01T00:00:00.0000000Z\", \"2017-01-02T00:00:00.0000000Z\", \"2017-01-03T00:00:00.0000000Z\", \"2017-01-04T00:00:00.0000000Z\", \"2017-01-05T00:00:00.0000000Z\", \"2017-01-06T00:00:00.0000000Z\", \"2017-01-07T00:00:00.0000000Z\", \"2017-01-08T00:00:00.0000000Z\", \"2017-01-09T00:00:00.0000000Z\" ]|", "https://kusto.azurewebsites.net/docs/query/make-seriesoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "makeset", "Returns a `dynamic` (JSON) array of the set of distinct values that *Expr* takes in the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `makeset(`*Expr*` [`,` *MaxListSize*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation.\r\n* *MaxListSize* is an optional integer limit on the maximum number of elements returned (default is *128*).\r\n\r\n**Returns**\r\n\r\nReturns a `dynamic` (JSON) array of the set of distinct values that *Expr* takes in the group.\r\nThe array's sort order is undefined.\r\n\r\n**Tip**\r\n\r\nTo just count the distinct values, use [dcount()](dcount-aggfunction.md)", "```\r\nPageViewLog \r\n| summarize countries=makeset(country) by continent\r\n```\r\n\r\n![alt text](./images/aggregations/makeset.png \"makeset\")\r\n\r\nSee also the [`mvexpand` operator](./mvexpandoperator.md) for the opposite function.", "https://kusto.azurewebsites.net/docs/query/makeset-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "materialize", "Allows caching a sub-query result during the time of query execution in a way that other subqueries can reference the partial result.", "**Syntax**\r\n\r\n`materialize(`*expression*`)`\r\n\r\n**Arguments**\r\n\r\n* *expression*: Tabular expression to be evaluated and cached during query execution.\r\n\r\n**Tips**\r\n\r\n* Use materialize when you have join/union where their operands has mutual sub-queries that can be executed once (see the examples below).\r\n\r\n* Useful also in scenarios when we need to join/union fork legs.\r\n\r\n* Materialize is allowed to be used only in let statements by giving the cached result a name.\r\n\r\n* Materialize has a cache size limit which is **5 GB**. \r\n  This limit is per cluster node and is mutual for all queries running concurrently.\r\n  If a query uses `materialize()` and the cache cannot hold any additional data,\r\n  the query aborts with an error.", "Assuming that we are interested in finding the Retention of Pages views.\r\n\r\nUsing `materialize()` operator to improve runtime performance:\r\n\r\n\r\n```\r\nlet totalPagesPerDay = PageViews\r\n| summarize by Page, Day = startofday(Timestamp)\r\n| summarize count() by Day;\r\nlet materializedScope = PageViews\r\n| summarize by Page, Day = startofday(Timestamp);\r\nlet cachedResult = materialize(materializedScope);\r\ncachedResult\r\n| project Page, Day1 = Day\r\n| join kind = inner\r\n(\r\n    cachedResult\r\n    | project Page, Day2 = Day\r\n)\r\non Page\r\n| where Day2 > Day1\r\n| summarize count() by Day1, Day2\r\n| join kind = inner\r\n    totalPagesPerDay\r\non $left.Day1 == $right.Day\r\n| project Day1, Day2, Percentage = count_*100.0/count_1\r\n\r\n\r\n```\r\n\r\n|Day1|Day2|Percentage|\r\n|---|---|---|\r\n|2016-05-01 00:00:00.0000000|2016-05-02 00:00:00.0000000|34.0645725975255|\r\n|2016-05-01 00:00:00.0000000|2016-05-03 00:00:00.0000000|16.618368960101|\r\n|2016-05-02 00:00:00.0000000|2016-05-03 00:00:00.0000000|14.6291376489636|\r\n\r\nUsing self-join without caching the mutual sub-query :\r\n\r\n\r\n```\r\nlet totalPagesPerDay = PageViews\t\r\n| summarize by Page, Day = startofday(Timestamp)\r\n| summarize count() by Day;\r\nlet subQuery = (PageViews\t\r\n| summarize by Page, Day = startofday(Timestamp));\r\nsubQuery\r\n| project Page, Day1 = Day\r\n| join kind = inner\r\n(\r\n    subQuery\r\n    | project Page, Day2 = Day\r\n)\r\non Page\r\n| where Day2 > Day1\r\n| summarize count() by Day1, Day2\r\n| join kind = inner\r\n    totalPagesPerDay\r\non $left.Day1 == $right.Day\r\n| project Day1, Day2, Percentage = count_*100.0/count_1\r\n```\r\n\r\n|Day1|Day2|Percentage|\r\n|---|---|---|\r\n|2016-05-01 00:00:00.0000000|2016-05-02 00:00:00.0000000|34.0645725975255|\r\n|2016-05-01 00:00:00.0000000|2016-05-03 00:00:00.0000000|16.618368960101|\r\n|2016-05-02 00:00:00.0000000|2016-05-03 00:00:00.0000000|14.6291376489636|\r\n\r\n\r\nThe same works for union, for example, getting the Pages which are one of the top 2 viewed, or top 2 with bytes delivered (not in both groups): \r\n\r\nUsing `materialize()` :\r\n\r\n\r\n```\r\nlet JunkPagesSuffix = \".jpg\";\r\nlet JunkPagesSuffix = \"\";\r\nlet materializedScope = PageViews\r\n| where Timestamp > datetime(2016-05-01 00:00:00.0000000)\r\n| summarize sum(BytesDelivered), count() by Page\r\n| where Page !endswith JunkPagesSuffix\r\n| where isempty(Page) == false;\r\nlet cachedResult = materialize(materializedScope);\r\nunion (cachedResult | top 2 by count_ | project Page ), (cachedResult | top 2 by sum_BytesDelivered | project Page)\r\n| summarize count() by Page | where count_ < 2 | project Page\r\n```\r\n\r\n|Page|\r\n|---|\r\n|de|\r\n|ar|\r\n|Special:Log/block|\r\n|Special:Search|\r\n\r\n\r\nUsing regular union without caching the result:\r\n\r\n\r\n```\r\nlet JunkPagesSuffix = \".jpg\";\r\nlet JunkPagesSuffix = \"\";\r\nlet subQuery = PageViews\r\n| where Timestamp > datetime(2016-05-01 00:00:00.0000000)\r\n| summarize sum(BytesDelivered), count() by Page\r\n| where Page !endswith JunkPagesSuffix\r\n| where isempty(Page) == false;\r\nunion (subQuery | top 2 by count_| project Page ), (subQuery | top 2 by sum_BytesDelivered| project Page)\r\n| summarize count() by Page\r\n| where count_ < 2\r\n| project Page\r\n```\r\n\r\n|Page|\r\n|---|\r\n|Special:Log/block|\r\n|Special:Search|\r\n|de|\r\n|ar|", "https://kusto.azurewebsites.net/docs/query/materializefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "max", "Returns the maximum value across the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `max(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe maximum value of *Expr* across the group.\r\n \r\n**Tip**\r\n\r\nThis gives you the min or max on its own - for example, the highest or lowest price. \r\nBut if you want other columns in the row - for example, the name of the supplier with the lowest \r\nprice - use [arg_max](arg-max-aggfunction.md) or [arg_min](arg-min-aggfunction.md).", "", "https://kusto.azurewebsites.net/docs/query/max-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "max_of", "Returns the maximum value of several evaluated numeric expressions.", "max_of(10, 1, -3, 17) == 17\r\n\r\n**Syntax**\r\n\r\n`max_of` `(`*expr_1*`,` *expr_2* ...`)`\r\n\r\n**Arguments**\r\n\r\n* *expr_i*: A scalar expression, to be evaluated.\r\n\r\n- All arguments must be of the same type.\r\n- Maximum of 64 arguments is supported.\r\n\r\n**Returns**\r\n\r\nThe maximum value of all argument expressions.", "```\r\nprint result = max_of(10, 1, -3, 17) \r\n```\r\n\r\n|result|\r\n|---|\r\n|17|", "https://kusto.azurewebsites.net/docs/query/max-offunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "merge_tdigests", "Merges tdigest results (scalar version of the aggregate version [`merge_tdigests()`](merge-tdigests-aggfunction.md)).", "Read more about the underlying algorithm (T-Digest) and the estimated error [here](percentiles-aggfunction.md#estimation-error-in-percentiles).\r\n\r\n**Syntax**\r\n\r\n`merge_tdigests(` *Expr1*`,` *Expr2*`, ...)`\r\n\r\n`tdigest_merge(` *Expr1*`,` *Expr2*`, ...)` - An alias.\r\n\r\n**Arguments**\r\n\r\n* Columns which has the tdigests to be merged.\r\n\r\n**Returns**\r\n\r\nThe result for merging the columns `*Exrp1*`, `*Expr2*`, ... `*ExprN*` to one tdigest.", "```\r\nrange x from 1 to 10 step 1 \r\n| extend y = x + 10\r\n| summarize tdigestX = tdigest(x), tdigestY = tdigest(y)\r\n| project merged = merge_tdigests(tdigestX, tdigestY)\r\n| project percentile_tdigest(merged, 100, typeof(long))\r\n```\r\n\r\n|percentile_tdigest_merged|\r\n|---|\r\n|20|", "https://kusto.azurewebsites.net/docs/query/tdigestmergefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "min", "Returns the minimum value agross the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\n`summarize` `min(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe minimum value of *Expr* across the group.\r\n \r\n**Tip**\r\n\r\nThis gives you the min or max on its own - for example, the highest or lowest price. \r\nBut if you want other columns in the row - for example, the name of the supplier with the lowest \r\nprice - use [argmax](argmax-aggfunction.md) or [argmin](argmin-aggfunction.md).", "", "https://kusto.azurewebsites.net/docs/query/min-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "min_of", "Returns the minimum value of several evaluated numeric expressions.", "min_of(10, 1, -3, 17) == -3\r\n\r\n**Syntax**\r\n\r\n`min_of` `(`*expr_1*`,` *expr_2* ...`)`\r\n\r\n**Arguments**\r\n\r\n* *expr_i*: A scalar expression, to be evaluated.\r\n\r\n- All arguments must be of the same type.\r\n- Maximum of 64 arguments is supported.\r\n\r\n**Returns**\r\n\r\nThe minimum value of all argument expressions.", "```\r\nprint result=min_of(10, 1, -3, 17) \r\n```\r\n\r\n|result|\r\n|---|\r\n|-3|", "https://kusto.azurewebsites.net/docs/query/min-offunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "monthofyear", "Returns the integer number represents the month number of the given year.", "monthofyear(datetime(\"2015-12-14\"))\r\n\r\n**Syntax**\r\n\r\n`monthofyear(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\n`month number` of the given year.", "", "https://kusto.azurewebsites.net/docs/query/monthofyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "mvexpand", "Expands multi-value collection(s) from a [dynamic](./scalar-data-types/dynamic.md)-typed column so that each value in the collection gets a separate row.\r\nAll the other column in an expanded row are duplicated.", "T | mvexpand listColumn [, listColumn2 ...] \r\n\r\n(See also [`summarize makelist`](makelist-aggfunction.md) which performs the opposite function.)", "Assume the input table is:\r\n\r\n|A:int|B:string|D:dynamic|D2:dynamic|\r\n|---|---|---|---|\r\n|1|\"hello\"|{\"key\":\"value\"}|{\"key1\":\"value1\", \"key2\":\"value2\"}|\r\n|2|\"world\"|[0,1,\"k\",\"v\"]|[2,3,\"q\"]|\r\n\r\n\r\n```\r\nmvexpand D, D2\r\n```\r\n\r\nResult is:\r\n\r\n|A:int|B:string|D:dynamic|D2:dynamic|\r\n|---|---|---|---|\r\n|1|\"hello\"|{\"key\":\"value\"}|{\"key1\":\"value1\"}|\r\n|1|\"hello\"||{\"key2\":\"value2\"}|\r\n|2|\"world\"|0|2|\r\n|2|\"world\"|1|3|\r\n|2|\"world\"|\"k\"|\"q\"|\r\n|2|\"world\"|\"v\"||\r\n\r\n\r\n**Syntax**\r\n\r\n*T* `| mvexpand ` [`bagexpansion=`(`bag` | `array`)] *ColumnName* [`,` *ColumnName* ...] [`limit` *Rowlimit*]\r\n\r\n*T* `| mvexpand ` [`bagexpansion=`(`bag` | `array`)] [*Name* `=`] *ArrayExpression* [`to typeof(`*Typename*`)`] [, [*Name* `=`] *ArrayExpression* [`to typeof(`*Typename*`)`] ...] [`limit` *Rowlimit*]\r\n\r\n**Arguments**\r\n\r\n* *ColumnName:* In the result, arrays in the named column are expanded to multiple rows. \r\n* *ArrayExpression:* An expression yielding an array. If this form is used, a new column is added and the existing one is preserved.\r\n* *Name:* A name for the new column.\r\n* *Typename:* Indicates the underlying type of the array's elements,\r\n    which becomes the type of the column produced by the operator.\r\n    Note that values in the array that do not conform to this type will\r\n    not be converted; rather, they will take on a `null` value.\r\n* *RowLimit:* The maximum number of rows generated from each original row. The default is 128.\r\n\r\n**Returns**\r\n\r\nMultiple rows for each of the values in any array in the named column or in the array expression.\r\nIf several columns or expressions are specified they are expanded in parallel so for each input row there will be as many output rows as there are elements in the longest expanded expression (shorter lists are padded with null's). If the value in a row is an empty array, the row expands to nothing (will not show in the result set). If the value in a row is not an array, the row is kept as is in the result set. \r\n\r\nThe expanded column always has dynamic type. Use a cast such as `todatetime()` or `toint()` if you want to compute or aggregate values.\r\n\r\nTwo modes of property-bag expansions are supported:\r\n* `bagexpansion=bag`: Property bags are expanded into single-entry property bags. This is the default expansion.\r\n* `bagexpansion=array`: Property bags are expanded into two-element `[`*key*`,`*value*`]` array structures,\r\n  allowing uniform access to keys and values (as well as, for example, running a distinct-count aggregation\r\n  over property names). \r\n\r\n**See also**\r\n\r\nSee [bag_unpack()](bag-unpackplugin.md) plugin for expanding dynamic JSON objects into columns using property bag keys.\r\n\r\n**Examples**\r\n\r\nSee [Chart count of live activites over time](./samples.md#concurrent-activities).", "https://kusto.azurewebsites.net/docs/query/mvexpandoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "next", "Returns the value of a column in a row that it at some offset following the\r\ncurrent row in a [serialized row set](./windowsfunctions.md#serialized-row-set).", "**Syntax**\r\n\r\n`next(column)`\r\n\r\n`next(column, offset)`\r\n\r\n`next(column, offset, default_value)`\r\n\r\n**Arguments**\r\n\r\n* `column`: the column to get the values from.\r\n\r\n* `offset`: the offset to go ahead in rows. When no offset is specified a default offset 1 is used.\r\n\r\n* `default_value`: the default value to be used when there is no next rows to take the value from. When no default value is specified, null is used.", "```\r\nTable | serialize | extend nextA = next(A,1)\r\n| extend diff = A - nextA\r\n| where diff > 1\r\n\r\nTable | serialize nextA = next(A,1,10)\r\n| extend diff = A - nextA\r\n| where diff <= 10\r\n```", "https://kusto.azurewebsites.net/docs/query/nextfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "not", "Reverses the value of its `bool` argument.", "not(false) == true\r\n\r\n**Syntax**\r\n\r\n`not(`*expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *expr*: A `bool` expression to be reversed.\r\n\r\n**Returns**\r\n\r\nReturns the reversed logical value of its `bool` argument.", "", "https://kusto.azurewebsites.net/docs/query/notfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "now", "Returns the current UTC clock time, optionally offset by a given timespan.\r\nThis function can be used multiple times in a statement and the clock time being referenced will be the same for all instances.", "now()\r\n    now(-2d)\r\n\r\n\r\n**Syntax**\r\n\r\n`now(`[*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* *offset*: A `timespan`, added to the current UTC clock time. Default: 0.\r\n\r\n**Returns**\r\n\r\nThe current UTC clock time as a `datetime`.\r\n\r\n`now()` + *offset*", "Determines the interval since the event identified by the predicate:\r\n\r\n\r\n```\r\nT | where ... | extend Elapsed=now() - Timestamp\r\n```", "https://kusto.azurewebsites.net/docs/query/nowfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "order", "Sort the rows of the input table into order by one or more columns.", "T | order by country asc, price desc\r\n\r\n**Alias**\r\n\r\n[sort operator](sortoperator.md)\r\n\r\n**Syntax**\r\n\r\n*T* `| sort by` *column* [`asc` | `desc`] [`nulls first` | `nulls last`] [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The table input to sort.\r\n* *column*: Column of *T* by which to sort. The type of the values must be numeric, date, time or string.\r\n* `asc` Sort by into ascending order, low to high. The default is `desc`, descending high to low.\r\n* `nulls first` (the default for `asc` order) will place the null values at the beginning and `nulls last` (the default for `desc` order) will place the null values at the end.", "```\r\nTraces\r\n| where ActivityId == \"479671d99b7b\"\r\n| sort by Timestamp asc nulls first\r\n```\r\n\r\nAll rows in table Traces that have a specific `ActivityId`, sorted by their timestamp. If `Timestamp` column contains null values, those will appear at the first lines of the result.\r\n\r\nIn order to exclude null values from the result add a filter before the call to sort:\r\n\r\n\r\n```\r\nTraces\r\n| where ActivityId == \"479671d99b7b\" and isnotnull(Timestamp)\r\n| sort by Timestamp asc\r\n```", "https://kusto.azurewebsites.net/docs/query/orderoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "pack", "Creates a `dynamic` object (property bag) from a list of names and values.", "**Syntax**\r\n\r\n`pack(`*key1*`,` *value1*`,` *key2*`,` *value2*`,... )`\r\n\r\n**Arguments**\r\n\r\n* An alternating list of keys and values (the total length of the list must be even)\r\n* All keys must be non-empty constant strings", "The following example returns `{\"Level\":\"Information\",\"ProcessID\":1234,\"Data\":{\"url\":\"www.bing.com\"}}`:\r\n\r\n\r\n```\r\npack(\"Level\", \"Information\", \"ProcessID\", 1234, \"Data\", pack(\"url\", \"www.bing.com\"))\r\n```\r\n\r\nLets take 2 tables, SmsMessages and MmsMessages:\r\n\r\nTable SmsMessages \r\n\r\n|SourceNumber |TargetNumber| CharsCount\r\n|---|---|---\r\n|555-555-1234 |555-555-1212 | 46 \r\n|555-555-1234 |555-555-1213 | 50 \r\n|555-555-1212 |555-555-1234 | 32 \r\n\r\nTable MmsMessages \r\n\r\n|SourceNumber |TargetNumber| AttachmnetSize | AttachmnetType | AttachmnetName\r\n|---|---|---|---|---\r\n|555-555-1212 |555-555-1213 | 200 | jpeg | Pic1\r\n|555-555-1234 |555-555-1212 | 250 | jpeg | Pic2\r\n|555-555-1234 |555-555-1213 | 300 | png | Pic3\r\n\r\nThe following query:\r\n\r\n```\r\nSmsMessages \r\n| extend Packed=pack(\"CharsCount\", CharsCount) \r\n| union withsource=TableName kind=inner \r\n( MmsMessages \r\n  | extend Packed=pack(\"AttachmnetSize\", AttachmnetSize, \"AttachmnetType\", AttachmnetType, \"AttachmnetName\", AttachmnetName))\r\n| where SourceNumber == \"555-555-1234\"\r\n``` \r\n\r\nReturns:\r\n\r\n|TableName |SourceNumber |TargetNumber | Packed\r\n|---|---|---|---\r\n|SmsMessages|555-555-1234 |555-555-1212 | {\"CharsCount\": 46}\r\n|SmsMessages|555-555-1234 |555-555-1213 | {\"CharsCount\": 50}\r\n|MmsMessages|555-555-1234 |555-555-1212 | {\"AttachmnetSize\": 250, \"AttachmnetType\": \"jpeg\", \"AttachmnetName\": \"Pic2\"}\r\n|MmsMessages|555-555-1234 |555-555-1213 | {\"AttachmnetSize\": 300, \"AttachmnetType\": \"png\", \"AttachmnetName\": \"Pic3\"}", "https://kusto.azurewebsites.net/docs/query/packfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "pack_all", "Creates a `dynamic` object (property bag) from all the columns of the tabular expression.", "**Syntax**\r\n\r\n`pack_all()`", "Given a table SmsMessages \r\n\r\n|SourceNumber |TargetNumber| CharsCount\r\n|---|---|---\r\n|555-555-1234 |555-555-1212 | 46 \r\n|555-555-1234 |555-555-1213 | 50 \r\n|555-555-1212 |555-555-1234 | 32 \r\n\r\nThe following query:\r\n\r\n```\r\nSmsMessages | extend Packed=pack_all()\r\n``` \r\n\r\nReturns:\r\n\r\n|TableName |SourceNumber |TargetNumber | Packed\r\n|---|---|---|---\r\n|SmsMessages|555-555-1234 |555-555-1212 | {\"SourceNumber\":\"555-555-1234\", \"TargetNumber\":\"555-555-1212\", \"CharsCount\": 46}\r\n|SmsMessages|555-555-1234 |555-555-1213 | {\"SourceNumber\":\"555-555-1234\", \"TargetNumber\":\"555-555-1213\", \"CharsCount\": 50}\r\n|SmsMessages|555-555-1212 |555-555-1234 | {\"SourceNumber\":\"555-555-1212\", \"TargetNumber\":\"555-555-1234\", \"CharsCount\": 32}", "https://kusto.azurewebsites.net/docs/query/packallfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "pack_array", "Packs all input values into a dynamic array.", "**Syntax**\r\n\r\n`pack_array(`*Expr1*`[`,` *Expr2*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr1...N*: Input expressions to be packed into a dynamic array.\r\n\r\n**Returns**\r\n\r\nDynamic array which includes the values of Expr1, Expr2, ... , ExprN.", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| project pack_array(x,y,z)\r\n```\r\n\r\n|Column1|\r\n|---|\r\n|[1,2,4]|\r\n|[2,4,8]|\r\n|[3,6,12]|\r\n\r\n\r\n```\r\nrange x from 1 to 3 step 1\r\n| extend y = tostring(x * 2)\r\n| extend z = (x * 2) * 1s\r\n| project pack_array(x,y,z)\r\n```\r\n\r\n|Column1|\r\n|---|\r\n|[1,\"2\",\"00:00:02\"]|\r\n|[2,\"4\",\"00:00:04\"]|\r\n|[3,\"6\",\"00:00:06\"]|", "https://kusto.azurewebsites.net/docs/query/packarrayfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "parse", "Evaluates a string expression and parses its value into one or more calculated columns.", "T | parse Text with \"ActivityName=\" name \", ActivityType=\" type\r\n\r\n**Syntax**\r\n\r\n*T* `| parse` [`kind=regex`|`simple`|`relaxed`] *Expression* `with` `*` (*StringConstant* *ColumnName* [`:` *ColumnType*]) `*`...\r\n\r\n**Arguments**\r\n\r\n* *T*: The input table.\r\n* kind: \r\n\r\n\t* simple (the default) : StringConstant is a regular string value and the match is strict, extended columns must match the required types.\r\n\t\t\r\n\t* regex : StringConstant may be a regular expression.\r\n\t\t\r\n\t* relaxed : StringConstant is a regular string value and the match is relaxed, extended columns may match the required types partially.\r\n* *Expression*: An expression that evaluates to a string.\r\n* *ColumnName:* The name of a column to assign a value (taken out\r\n  of the string expression) to. \r\n* *ColumnType:* should be Optional scalar type that indicates the type to convert the value to (by default it is string type).\r\n\r\n**Returns**\r\n\r\nThe input table, extended according to the list of columns that are\r\nprovided to the operator.\r\n\r\n**Tips**\r\n\r\n* Use [`project`](projectoperator.md) instead, if you also want to drop or rename some columns.\r\n\r\n* Use * in the pattern in order to skip junk values (can't be used after string column)\r\n\r\n* The parse pattern may start with *ColumnName* and not only with *StringConstant*. \r\n\r\n* If the parsed *Expression* is not of type string , it will be converted to type string.\r\n\r\n* If regex mode is used, there is an option to add regex flags in order to control the whole regex used in parse.\r\n\r\n* In regex mode, parse will translate the pattern to a regex and use [RE2 syntax](re2.md) in order to do the matching using numbered captured groups which \r\n  are handeled internally.\r\n  So for example, this parse statement :\r\n  \r\n\t\r\n\t```\r\n\tparse kind=regex Col with * <regex1> var1:string <regex2> var2:long\r\n\t```\r\n\r\n\tThe regex that will be generated by the parse internally is `.*?<regex1>(.*?)<regex2>(\\-\\d+)`.\r\n\t\t\r\n\t- `*` was translated to `.*?`.\r\n\t\t\r\n\t- `string` was translated to `.*?`.\r\n\t\t\r\n\t- `long` was translated to `\\-\\d+`.", "The `parse` operator provides a streamlined way to `extend` a table\r\nby using multiple `extract` applications on the same `string` expression.\r\nThis is most useful when the table has a `string` column that contains\r\nseveral values that you want to break into individual columns, such as a\r\ncolumn that was produced by a developer trace (\"`printf`\"/\"`Console.WriteLine`\")\r\nstatement.\r\n\r\nIn the example below, assume that the column `EventText` of table `Traces` contains\r\nstrings of the form `Event: NotifySliceRelease (resourceName={0}, totalSlices= {1}, sliceNumber={2}, lockTime={3}, releaseTime={4}, previousLockTime={5})`.\r\nThe operation below will extend the table with 6 columns: `resourceName` , `totalSlices`, `sliceNumber`, `lockTime `, `releaseTime`, `previouLockTime`, \r\n `Month` and `Day`. \r\n\r\n\r\n|eventText|\r\n|---|\r\n|Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=23, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01, previousLockTime=02/17/2016 08:39:01)|\r\n|Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=15, lockTime=02/17/2016 08:40:00, releaseTime=02/17/2016 08:40:00, previousLockTime=02/17/2016 08:39:00)|\r\n|Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=20, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01, previousLockTime=02/17/2016 08:39:01)|\r\n|Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=22, lockTime=02/17/2016 08:41:01, releaseTime=02/17/2016 08:41:00, previousLockTime=02/17/2016 08:40:01)|\r\n|Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=27, sliceNumber=16, lockTime=02/17/2016 08:41:00, releaseTime=02/17/2016 08:41:00, previousLockTime=02/17/2016 08:40:00)|\r\n\r\n\r\n```\r\nTraces  \r\n| parse eventText with * \"resourceName=\" resourceName \", totalSlices=\" totalSlices:long * \"sliceNumber=\" sliceNumber:long * \"lockTime=\" lockTime \", releaseTime=\" releaseTime:date \",\" * \"previousLockTime=\" previouLockTime:date \")\" *  \r\n| project resourceName ,totalSlices , sliceNumber , lockTime , releaseTime , previouLockTime\r\n```\r\n\r\n|resourceName|totalSlices|sliceNumber|lockTime|releaseTime|previouLockTime|\r\n|---|---|---|---|---|---|\r\n|PipelineScheduler|27|15|02/17/2016 08:40:00|2016-02-17 08:40:00.0000000|2016-02-17 08:39:00.0000000|\r\n|PipelineScheduler|27|23|02/17/2016 08:40:01|2016-02-17 08:40:01.0000000|2016-02-17 08:39:01.0000000|\r\n|PipelineScheduler|27|20|02/17/2016 08:40:01|2016-02-17 08:40:01.0000000|2016-02-17 08:39:01.0000000|\r\n|PipelineScheduler|27|16|02/17/2016 08:41:00|2016-02-17 08:41:00.0000000|2016-02-17 08:40:00.0000000|\r\n|PipelineScheduler|27|22|02/17/2016 08:41:01|2016-02-17 08:41:00.0000000|2016-02-17 08:40:01.0000000|\r\n\r\nfor regex mode :\r\n\r\n\r\n```\r\nTraces  \r\n| parse kind = regex eventText with \"(.*?)[a-zA-Z]*=\" resourceName @\", totalSlices=\\s*\\d+\\s*.*?sliceNumber=\" sliceNumber:long  \".*?(previous)?lockTime=\" lockTime \".*?releaseTime=\" releaseTime \".*?previousLockTime=\" previouLockTime:date \"\\\\)\"  \r\n| project resourceName , sliceNumber , lockTime , releaseTime , previouLockTime\r\n```\r\n\r\n|resourceName|sliceNumber|lockTime|releaseTime|previouLockTime|\r\n|---|---|---|---|---|\r\n|PipelineScheduler|15|02/17/2016 08:40:00, |02/17/2016 08:40:00, |2016-02-17 08:39:00.0000000|\r\n|PipelineScheduler|23|02/17/2016 08:40:01, |02/17/2016 08:40:01, |2016-02-17 08:39:01.0000000|\r\n|PipelineScheduler|20|02/17/2016 08:40:01, |02/17/2016 08:40:01, |2016-02-17 08:39:01.0000000|\r\n|PipelineScheduler|16|02/17/2016 08:41:00, |02/17/2016 08:41:00, |2016-02-17 08:40:00.0000000|\r\n|PipelineScheduler|22|02/17/2016 08:41:01, |02/17/2016 08:41:00, |2016-02-17 08:40:01.0000000|\r\n\r\nfor regex mode using regex flags:\r\n\r\nif we are interested in getting the resourceName only and we use this query:\r\n\r\n\r\n```\r\nTraces\r\n| parse kind = regex  EventText with * \"resourceName=\" resourceName ',' *\r\n| project resourceName\r\n```\r\n\r\n|resourceName|\r\n|---|\r\n|PipelineScheduler, totalSlices=27, sliceNumber=23, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01|\r\n|PipelineScheduler, totalSlices=27, sliceNumber=15, lockTime=02/17/2016 08:40:00, releaseTime=02/17/2016 08:40:00|\r\n|PipelineScheduler, totalSlices=27, sliceNumber=22, lockTime=02/17/2016 08:41:01, releaseTime=02/17/2016 08:41:00|\r\n|PipelineScheduler, totalSlices=27, sliceNumber=20, lockTime=02/17/2016 08:40:01, releaseTime=02/17/2016 08:40:01|\r\n|PipelineScheduler, totalSlices=27, sliceNumber=16, lockTime=02/17/2016 08:41:00, releaseTime=02/17/2016 08:41:00|\r\n\r\n\r\nwe don't get the expected results since the default mode is greedy.\r\nor even if we had few records where the resourceName appears sometimes lower-case sometimes upper-case so we may\r\nget nulls for some values.\r\nin order to get the wanted result, we may run this one with regex flags ungreedy and disable case-sensitive mode :\r\n\r\n\r\n```\r\nTraces\r\n| parse kind = regex flags = Ui EventText with * \"RESOURCENAME=\" resourceName ',' *\r\n| project resourceName\r\n```\r\n\r\n|resourceName|\r\n|---|\r\n|PipelineScheduler|\r\n|PipelineScheduler|\r\n|PipelineScheduler|\r\n|PipelineScheduler|\r\n|PipelineScheduler|\r\n\r\n\r\n\r\n\r\nfor relaxed mode :\r\n\r\n\r\n```\r\nprint x=1\r\n parse kind=relaxed \"Event: NotifySliceRelease (resourceName=PipelineScheduler, totalSlices=NULL, sliceNumber=23, lockTime=02/17/2016 08:40:01, releaseTime=NULL, previousLockTime=02/17/2016 08:39:01)\"\r\n     with * \"resourceName=\" resourceName \", totalSlices=\" totalSlices:long * \"sliceNumber=\" sliceNumber:long * \"lockTime=\" lockTime \", releaseTime=\" releaseTime:date \",\" * \"previousLockTime=\" previouLockTime:date \")\" *  \r\n| project resourceName ,totalSlices , sliceNumber , lockTime , releaseTime , previouLockTime\r\n```\r\n\r\n|resourceName|totalSlices|sliceNumber|lockTime|releaseTime|previouLockTime|\r\n|---|---|---|---|---|---|\r\n|PipelineScheduler||23|02/17/2016 08:40:01||2016-02-17 08:39:01.0000000|", "https://kusto.azurewebsites.net/docs/query/parseoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_ipv4", "Converts input to integener (signed 64-bit) number representation.", "parse_ipv4(\"127.0.0.1\") == 2130706433\r\n    parse_ipv4('192.1.168.1') < parse_ipv4('192.1.168.2') == true\r\n\r\n**Syntax**\r\n\r\n`parse_ipv4(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to long. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a long number.\r\nIf conversion is not successful, result will be `null`.", "", "https://kusto.azurewebsites.net/docs/query/parse-ipv4function.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_json", "Interprets a `string` as a [JSON value](https://json.org/)) and returns the value as [`dynamic`](./scalar-data-types/dynamic.md). \r\nIt is superior to using [extractjson() function](./extractjsonfunction.md)\r\nwhen you need to extract more than one element of a JSON compound object.", "**Syntax**\r\n\r\n`parse_json(`*json*`)`\r\n\r\nAliases:\r\n- [todynamic()](./todynamicfunction.md)\r\n- [toobject()](./todynamicfunction.md)\r\n\r\n**Arguments**\r\n\r\n* *json*: An expression of type `string`, representing a JSON-formatted value,\r\n  or an expression of type `dynamic`, representing the actual `dynamic` value.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that is determined by the value of *json*:\r\n* If *json* is of type `dynamic`, its value is used as-is.\r\n* If *json* is of type `string`, and is a [properly-formatted JSON string](https://json.org/),\r\n  the string is parsed and the value produced is returned.\r\n* If *json* is of type `string`, but it is **not** a [properly-formatted JSON string](https://json.org/),\r\n  then the returned value is an object of type `dynamic` that holds the original\r\n  `string` value.", "In the following example, when `context_custom_metrics` is a `string`\r\nthat looks like this: \r\n\r\n```\r\n{\"duration\":{\"value\":118.0,\"count\":5.0,\"min\":100.0,\"max\":150.0,\"stdDev\":0.0,\"sampledValue\":118.0,\"sum\":118.0}}\r\n```\r\n\r\nthen the following CSL Fragment retrieves the value of the `duration` slot\r\nin the object, and from that it retrieves two slots, `duration.value` and\r\n `duration.min` (`118.0` and `110.0`, respectively).\r\n\r\n\r\n```\r\nT\r\n| extend d=parse_json(context_custom_metrics) \r\n| extend duration_value=d.duration.value, duration_min=d[\"duration\"][\"min\"]\r\n```\r\n\r\n**Notes**\r\n\r\nIt is somewhat common to have a JSON string describing a property bag in which\r\none of the \"slots\" is another JSON string. For example:\r\n\r\n\r\n\r\n```\r\nlet d='{\"a\":123, \"b\":\"{\\\\\"c\\\\\":456}\"}';\r\nprint d\r\n```\r\n\r\nIn such cases, it is not only necessary to invoke `parse_json` twice, but also\r\nto make sure that in the second call, `tostring` will be used. Otherwise, the\r\nsecond call to `parse_json` will simply pass-on the input to the output as-is,\r\nbecause its declared type is `dynamic`:\r\n\r\n\r\n\r\n```\r\nlet d='{\"a\":123, \"b\":\"{\\\\\"c\\\\\":456}\"}';\r\nprint d_b_c=parse_json(tostring(parse_json(d).b)).c\r\n```", "https://kusto.azurewebsites.net/docs/query/parsejsonfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_path", "Parses a file path `string` and returns a [`dynamic`](./scalar-data-types/dynamic.md) object that contains the following parts of the path: \r\nScheme, RootPath, DirectoryPath, DirectoryName, FileName, Extension, AlternateDataStreamName.\r\nIn addition to the simple paths with both types of slashes, supports paths with schemas (e.g. \"file://...\"), shared paths (e.g. \"\\\\shareddrive\\users...\"), long paths (e.g \"\\\\?\\C:...\"\"), alternate data streams (e.g. \"file1.exe:file2.exe\")", "**Syntax**\r\n\r\n`parse_path(`*path*`)`\r\n\r\n**Arguments**\r\n\r\n* *path*: A string that represents a file path.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that inculded the path components as listed above.", "```\r\ndatatable(p:string) \r\n[\r\n    @\"C:\\temp\\file.txt\",\r\n    @\"temp\\file.txt\",\r\n    \"file://C:/temp/file.txt:some.exe\",\r\n    @\"\\\\shared\\users\\temp\\file.txt.gz\",\r\n    \"/usr/lib/temp/file.txt\"\r\n]\r\n| extend path_parts = parse_path(p)\r\n\r\n```\r\n\r\n|p|path_parts\r\n|---|---\r\n|C:\\temp\\file.txt|{\"Scheme\":\"\",\"RootPath\":\"C:\",\"DirectoryPath\":\"C:\\\\temp\",\"DirectoryName\":\"temp\",\"Filename\":\"file.txt\",\"Extension\":\"txt\",\"AlternateDataStreamName\":\"\"}\r\n|temp\\file.txt|{\"Scheme\":\"\",\"RootPath\":\"\",\"DirectoryPath\":\"temp\",\"DirectoryName\":\"temp\",\"Filename\":\"file.txt\",\"Extension\":\"txt\",\"AlternateDataStreamName\":\"\"}\r\n|file://C:/temp/file.txt:some.exe|{\"Scheme\":\"file\",\"RootPath\":\"C:\",\"DirectoryPath\":\"C:/temp\",\"DirectoryName\":\"temp\",\"Filename\":\"file.txt\",\"Extension\":\"txt\",\"AlternateDataStreamName\":\"some.exe\"}\r\n|\\\\shared\\users\\temp\\file.txt.gz|{\"Scheme\":\"\",\"RootPath\":\"\",\"DirectoryPath\":\"\\\\\\\\shared\\\\users\\\\temp\",\"DirectoryName\":\"temp\",\"Filename\":\"file.txt.gz\",\"Extension\":\"gz\",\"AlternateDataStreamName\":\"\"}\r\n|/usr/lib/temp/file.txt|{\"Scheme\":\"\",\"RootPath\":\"\",\"DirectoryPath\":\"/usr/lib/temp\",\"DirectoryName\":\"temp\",\"Filename\":\"file.txt\",\"Extension\":\"txt\",\"AlternateDataStreamName\":\"\"}", "https://kusto.azurewebsites.net/docs/query/parsepathfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_url", "Parses an absolute URL `string` and returns a [`dynamic`](./scalar-data-types/dynamic.md) object contains all parts of the URL (Scheme, Host, Port, Path, Username, Password, Query Parameters, Fragment).", "**Syntax**\r\n\r\n`parse_url(`*url*`)`\r\n\r\n**Arguments**\r\n\r\n* *url*: A string represents a URL or the query part of the URL.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that inculded the URL components as listed above.", "```\r\nT | extend Result = parse_url(\"scheme://username:password@host:1234/this/is/a/path?k1=v1&k2=v2#fragment\")\r\n```\r\n\r\nwill result\r\n\r\n```\r\n {\r\n \t\"Scheme\":\"scheme\",\r\n \t\"Host\":\"host\",\r\n \t\"Port\":\"1234\",\r\n \t\"Path\":\"this/is/a/path\",\r\n \t\"Username\":\"username\",\r\n \t\"Password\":\"password\",\r\n \t\"Query Parameters\":\"{\"k1\":\"v1\", \"k2\":\"v2\"}\",\r\n \t\"Fragment\":\"fragment\"\r\n }\r\n```", "https://kusto.azurewebsites.net/docs/query/parseurlfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_urlquery", "Parses a url query `string` and returns a [`dynamic`](./scalar-data-types/dynamic.md) object contains the Query parameters.", "**Syntax**\r\n\r\n`parse_urlquery(`*query*`)`\r\n\r\n**Arguments**\r\n\r\n* *query*: A string represents a url query.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that includes the query parameters.", "```\r\nparse_urlquery(\"k1=v1&k2=v2&k3=v3\")\r\n```\r\n\r\nwill result:\r\n\r\n```\r\n {\r\n \t\"Query Parameters\":\"{\"k1\":\"v1\", \"k2\":\"v2\", \"k3\":\"v3\"}\",\r\n }\r\n```\r\n\r\n**Notes**\r\n\r\n* Input format should follow URL query standards (key=value& ...)", "https://kusto.azurewebsites.net/docs/query/parseurlqueryfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_user_agent", "Interprets a user-agent string, which identifies the user's browser and provides certain system details to servers hosting the websites the user visits. The result is returned as [`dynamic`](./scalar-data-types/dynamic.md).", "**Syntax**\r\n\r\n`parse_user_agent(`*user-agent-string*, *look-for*`)`\r\n\r\n**Arguments**\r\n\r\n* *user-agent-string*: An expression of type `string`, representing a user-agent string.\r\n\r\n* *look-for*: An expression of type `string` or `dynamic`, representing what the function should be looking for in the user-agent string (parsing target). \r\nThe possible options: \"browser\", \"os\", \"device\". If only a single parsing target is required it can be passed a `string` parameter.\r\nIf two or three are required they can be passed as a `dynamic array`.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that contains the information about the requested parsing targets.\r\n\r\nBrowser: Family, MajorVersion, MinorVersion, Patch                 \r\n\r\nOperatingSystem: Family, MajorVersion, MinorVersion, Patch, PatchMinor             \r\n\r\nDevice: Family, Brand, Model", "```\r\nprint useragent = \"Mozilla/5.0 (Windows; U; en-US) AppleWebKit/531.9 (KHTML, like Gecko) AdobeAIR/2.5.1\"\r\n| extend x = parse_user_agent(useragent, \"browser\") \r\n```\r\n\r\nExpected result is a dynamic object:\r\n\r\n{\r\n  \"Browser\": {\r\n    \"Family\": \"AdobeAIR\",\r\n    \"MajorVersion\": \"2\",\r\n    \"MinorVersion\": \"5\",\r\n    \"Patch\": \"1\"\r\n  }\r\n}\r\n\r\n\r\n```\r\nprint useragent = \"Mozilla/5.0 (SymbianOS/9.2; U; Series60/3.1 NokiaN81-3/10.0.032 Profile/MIDP-2.0 Configuration/CLDC-1.1 ) AppleWebKit/413 (KHTML, like Gecko) Safari/4\"\r\n| extend x = parse_user_agent(useragent, dynamic([\"browser\",\"os\",\"device\"])) \r\n```\r\n\r\nExpected result is a dynamic object:\r\n\r\n{\r\n  \"Browser\": {\r\n    \"Family\": \"Nokia OSS Browser\",\r\n    \"MajorVersion\": \"3\",\r\n    \"MinorVersion\": \"1\",\r\n    \"Patch\": \"\"\r\n  },\r\n  \"OperatingSystem\": {\r\n    \"Family\": \"Symbian OS\",\r\n    \"MajorVersion\": \"9\",\r\n    \"MinorVersion\": \"2\",\r\n    \"Patch\": \"\",\r\n    \"PatchMinor\": \"\"\r\n  },\r\n  \"Device\": {\r\n    \"Family\": \"Nokia N81\",\r\n    \"Brand\": \"Nokia\",\r\n    \"Model\": \"N81-3\"\r\n  }\r\n}", "https://kusto.azurewebsites.net/docs/query/parse-useragentfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_version", "Converts input string representation of version to a comparable decimal number.", "parse_version(\"0.0.0.1\")\r\n\r\n**Syntax**\r\n\r\n`parse_version` `(` *Expr* `)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: A scalar expression of type `string` that specifies the version to be parsed.\r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a decimal.\r\nIf conversion is not successful, result will be `null`.\r\n\r\n**Notes**\r\n\r\nInput string must contain from 1 to 4 version parts, represented as numbers and separated with dots ('.').\r\n\r\nEach part of version may contain up to 8 digits (max value - 99999999).\r\n\r\nIn case, if amount of parts is less than 4, all the missing parts are considered as trailing (`1.0` == `1.0.0.0`).", "```\r\nlet dt = datatable(v:string)\r\n[\"0.0.0.5\",\"0.0.7.0\",\"0.0.3\",\"0.2\",\"0.1.2.0\",\"1.2.3.4\",\"1\",\"99999999.0.0.0\"];\r\ndt | project v1=v, _key=1 \r\n| join kind=inner (dt | project v2=v, _key = 1) on _key | where v1 != v2\r\n| summarize v1 = max(v1),v2 = min(v2) by (hash(v1) + hash(v2)) // removing duplications\r\n| project v1, v2, higher_version = iif(parse_version(v1) > parse_version(v2), v1, v2)\r\n\r\n```\r\n\r\n|v1|v2|higher_version|\r\n|---|---|---|\r\n|99999999.0.0.0|0.0.0.5|99999999.0.0.0|\r\n|1|0.0.0.5|1|\r\n|1.2.3.4|0.0.0.5|1.2.3.4|\r\n|0.1.2.0|0.0.0.5|0.1.2.0|\r\n|0.2|0.0.0.5|0.2|\r\n|0.0.3|0.0.0.5|0.0.3|\r\n|0.0.7.0|0.0.0.5|0.0.7.0|\r\n|99999999.0.0.0|0.0.7.0|99999999.0.0.0|\r\n|1|0.0.7.0|1|\r\n|1.2.3.4|0.0.7.0|1.2.3.4|\r\n|0.1.2.0|0.0.7.0|0.1.2.0|\r\n|0.2|0.0.7.0|0.2|\r\n|0.0.7.0|0.0.3|0.0.7.0|\r\n|99999999.0.0.0|0.0.3|99999999.0.0.0|\r\n|1|0.0.3|1|\r\n|1.2.3.4|0.0.3|1.2.3.4|\r\n|0.1.2.0|0.0.3|0.1.2.0|\r\n|0.2|0.0.3|0.2|\r\n|99999999.0.0.0|0.2|99999999.0.0.0|\r\n|1|0.2|1|\r\n|1.2.3.4|0.2|1.2.3.4|\r\n|0.2|0.1.2.0|0.2|\r\n|99999999.0.0.0|0.1.2.0|99999999.0.0.0|\r\n|1|0.1.2.0|1|\r\n|1.2.3.4|0.1.2.0|1.2.3.4|\r\n|99999999.0.0.0|1.2.3.4|99999999.0.0.0|\r\n|1.2.3.4|1|1.2.3.4|\r\n|99999999.0.0.0|1|99999999.0.0.0|", "https://kusto.azurewebsites.net/docs/query/parse-versionfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "parse_xml", "Interprets a `string` as a XML value, converts the value to a [JSON value](https://json.org/) and returns the value as  [`dynamic`](./scalar-data-types/dynamic.md).", "**Syntax**\r\n\r\n`parse_xml(`*xml*`)`\r\n\r\n**Arguments**\r\n\r\n* *xml*: An expression of type `string`, representing a XML-formatted value.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` that is determined by the value of *xml*, or null, if the XML format is invalid.\r\n\r\nConverting the XML to JSON is done using [xml2json](https://github.com/Cheedoong/xml2json) library.\r\n\r\nThe conversion is done as following:\r\n\r\nXML                                |JSON                                            |Access\r\n-----------------------------------|------------------------------------------------|--------------         \r\n`<e/>`                             | { \"e\": null }                                  | o.e\r\n`<e>text</e>`\t                   | { \"e\": \"text\" }\t                            | o.e\r\n`<e name=\"value\" />`               | { \"e\":{\"@name\": \"value\"} }\t                    | o.e[\"@name\"]\r\n`<e name=\"value\">text</e>`         | { \"e\": { \"@name\": \"value\", \"#text\": \"text\" } } | o.e[\"@name\"] o.e[\"#text\"]\r\n`<e> <a>text</a> <b>text</b> </e>` | { \"e\": { \"a\": \"text\", \"b\": \"text\" } }\t        | o.e.a o.e.b\r\n`<e> <a>text</a> <a>text</a> </e>` | { \"e\": { \"a\": [\"text\", \"text\"] } }\t            | o.e.a[0] o.e.a[1]\r\n`<e> text <a>text</a> </e>`        | { \"e\": { \"#text\": \"text\", \"a\": \"text\" } }\t    | 1`o.e[\"#text\"] o.e.a\r\n\r\n**Notes**\r\n\r\n* Maximal input `string` length for `parse_xml` is 128 KB. Longer strings interpretation will result in a null object \r\n* Only element nodes, attributes and text nodes will be translated. Everything else will be skipped\r\n* Translation of XMLs with namespaces is currently not supported", "In the following example, when `context_custom_metrics` is a `string`\r\nthat looks like this: \r\n\r\n```\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<duration>\r\n    <value>118.0</value>\r\n    <count>5.0</count>\r\n    <min>100.0</min>\r\n    <max>150.0</max>\r\n    <stdDev>0.0</stdDev>\r\n    <sampledValue>118.0</sampledValue>\r\n    <sum>118.0</sum>\r\n</duration>\r\n```\r\n\r\nthen the following CSL Fragment translates the XML to the following JSON:\r\n```\r\n{\r\n    \"duration\": {\r\n        \"value\": 118.0,\r\n        \"count\": 5.0,\r\n        \"min\": 100.0,\r\n        \"max\": 150.0,\r\n        \"stdDev\": 0.0,\r\n        \"sampledValue\": 118.0,\r\n        \"sum\": 118.0\r\n    }\r\n}\r\n```\r\n\r\nand retrieves the value of the `duration` slot\r\nin the object, and from that it retrieves two slots, `duration.value` and\r\n `duration.min` (`118.0` and `110.0`, respectively).\r\n\r\n\r\n```\r\nT\r\n| extend d=parse_xml(context_custom_metrics) \r\n| extend duration_value=d.duration.value, duration_min=d[\"duration\"][\"min\"]\r\n```", "https://kusto.azurewebsites.net/docs/query/parse-xmlfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "percentile", "Returns an estimate for the specified [nearest-rank percentile](#nearest-rank-percentile) of the population defined by *Expr*. \r\nThe accuracy depends on the density of population in the region of the percentile.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n`percentiles()` is like `percentile()`, but calculates a number of \r\npercentile values (which is faster than calculating each percentile individually).\r\n\r\n`percentilesw()` is like `percentilew()`, but calculates a number of \r\npercentile values (which is faster than calculating each percentile individually).\r\n\r\n`percentilew()` and `percentilesw()` allows calculating weighted percentiles. Weighted\r\npercentiles calculate the given percentiles in a \"weighted\" way - threating each value\r\nas if it was repeated `Weight` times in the input.\r\n\r\n**Syntax**\r\n\r\nsummarize `percentile(`*Expr*`,` *Percentile*`)`\r\n\r\nsummarize `percentiles(`*Expr*`,` *Percentile1* [`,` *Percentile2*]`)`\r\n\r\nsummarize `percentiles_array(`*Expr*`,` *Percentile1* [`,` *Percentile2*]`)`\r\n\r\nsummarize `percentiles_array(`*Expr*`,` *Dynamic array*`)`\r\n\r\nsummarize `percentilew(`*Expr*`,` *WeightExpr*`,` *Percentile*`)`\r\n\r\nsummarize `percentilesw(`*Expr*`,` *WeightExpr*`,` *Percentile1* [`,` *Percentile2*]`)`\r\n\r\nsummarize `percentilesw_array(`*Expr*`,` *WeightExpr*`,` *Percentile1* [`,` *Percentile2*]`)`\r\n\r\nsummarize `percentilesw_array(`*Expr*`,` *WeightExpr*`,` *Dynamic array*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation.\r\n* *WeightExpr*: Expression that will be used as the weight of values for aggregation calculation.\r\n* *Percentile* is a double constant that specifies the percentile.\r\n* *Dynamic array*: list of percentiles in a dynamic array of integer or floating point numbers\r\n\r\n**Returns**\r\n\r\nReturns an estimate for *Expr* of the specified percentiles in the group.", "The value of `Duration` that is larger than 95% of the sample set and smaller than 5% of the sample set:\r\n\r\n\r\n```\r\nCallDetailRecords | summarize percentile(Duration, 95) by continent\r\n```\r\n\r\nSimultaneously calculate 5, 50 (median) and 95:\r\n\r\n\r\n```\r\nCallDetailRecords \r\n| summarize percentiles(Duration, 5, 50, 95) by continent\r\n```\r\n\r\n![alt text](./images/aggregations/percentiles.png \"percentiles\")\r\n\r\nThe results show that in Europe, 5% of calls are shorter than 11.55s, 50% of calls are shorter than 3 minutes 18.46 seconds, and 95% of calls are shorter than 40 minutes 48 seconds.\r\n\r\nCalculate multiple statistics:\r\n\r\n\r\n```\r\nCallDetailRecords \r\n| summarize percentiles(Duration, 5, 50, 95), avg(Duration)\r\n```\r\n\r\n## Weighted percentiles\r\n\r\nAssume you measure the time (Duration) it takes an action to complete again and again, and\r\nthen instead of recording each and every value of the measurement, you \"condense\" them by\r\nrecording each value of Duration rounded to 100 msec and how many times that rounded value\r\nappeared (BucketSize).\r\n\r\nYou can use `summarize percentilesw(Duration, BucketSize, ...)` to calculates the given\r\npercentiles in a \"weighted\" way - treating each value of Duration as if it was repeated\r\nBucketSize times in the input, without actually needing to materialize those records.\r\n\r\nConsider the following following example (taken from [StackOverflow](https://stackoverflow/questions/8106/kusto-percentiles-on-aggregated-data)).\r\nA customer has a set of latency values in milliseconds:\r\n`{ 1, 1, 2, 2, 2, 5, 7, 7, 12, 12, 15, 15, 15, 18, 21, 22, 26, 35 }`.\r\n\r\nIn order to reduce bandwidth and storage, the customer performs pre-aggregation to the\r\nfollowing buckets: `{ 10, 20, 30, 40, 50, 100 }`, and counts the number of events in each bucket,\r\nwhich gives the following Kusto table:\r\n\r\n![alt text](./images/aggregations/percentilesw-table.png \"percentilesw-table\")\r\n\r\nWhich can be read as:\r\n - 8 events in the 10ms bucket (corresponding to subset `{ 1, 1, 2, 2, 2, 5, 7, 7 }`)\r\n - 6 events in the 20ms bucket (corresponding to subset `{ 12, 12, 15, 15, 15, 18 }`)\r\n - 3 events in the 30ms bucket (corresponding to subset `{ 21, 22, 26 }`)\r\n - 1 event in the 40ms bucket (corresponding to subset `{ 35 }`)\r\n\r\nAt this point, the original data is no longer available to us, and all we have is the\r\nnumber of events in each bucket. In order to compute percentiles from this data,\r\nwe can use the `percentilesw()` function. For example, for the 50,\r\n75 and 99.9 percentiles, we'll use the following query: \r\n\r\n\r\n```\r\nTable\r\n| summarize percentilesw(LatencyBucket, ReqCount, 50, 75, 99.9) \r\n```\r\n\r\nThe result for the above query is:\r\n\r\n![alt text](./images/aggregations/percentilesw-result.png \"percentilesw-result\")\r\n\r\nNotice, that the above query corresponds to the function\r\n`percentiles(LatencyBucket, 50, 75, 99.9)` if the data was expended to the following form:\r\n\r\n![alt text](./images/aggregations/percentilesw-rawtable.png \"percentilesw-rawtable\")\r\n\r\n## Getting multiple percentiles in an array\r\nMultiple percentiles percentiles can be obtained as an array in a single dynamic column instead of multiple columns: \r\n\r\n\r\n```\r\nCallDetailRecords \r\n| summarize percentiles_array(Duration, 5, 25, 50, 75, 95), avg(Duration)\r\n```\r\n\r\n![alt text](./images/aggregations/percentiles-array-result.png \"percentiles-array-result\")\r\n\r\nSimilarily weighted percentiles can be returned as a dynamic array using `percentilesw_array`\r\n\r\nPercentiles for `percentiles_array` and `percentilesw_array` can be specified in a dynamic array of integer or floating-point numbers. The array must be constant but does not have to be literal.\r\n\r\n\r\n```\r\nCallDetailRecords \r\n| summarize percentiles_array(Duration, dynamic([5, 25, 50, 75, 95])), avg(Duration)\r\n```\r\n\r\n\r\n```\r\nCallDetailRecords \r\n| summarize percentiles_array(Duration, range(0, 100, 5)), avg(Duration)\r\n```\r\n## Nearest-rank percentile\r\n*P*-th percentile (0 < *P* <= 100) of a list of ordered values (sorted from least to greatest) is the smallest value in the list such that *P* percent of the data is less or equal to that value ([from Wikipedia article on percentiles](https://en.wikipedia.org/wiki/Percentile#The_Nearest_Rank_method))\r\n\r\nWe also define *0*-th percentiles to be the smallest member of the population.\r\n\r\n**Note**\r\n* Given the approximating nature of the calculation the actual returned value may not be a member of the population\r\n* Nearest-rank definition means that *P*=50 does not conform to the [interpolative definition of the median](https://en.wikipedia.org/wiki/Median). When evaluating the significance of this discrepancy for the specific application the size of the population and an [estimation error](#estimation-error-in-percentiles) should be taken into account. \r\n\r\n## Estimation error in percentiles\r\n\r\nThe percentiles aggregate provides an approximate value using [T-Digest](https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf). \r\n\r\nA few important points: \r\n\r\n* The bounds on the estimation error vary with the value of the requested percentile. The best accuracy is at the ends of [0..100] scale, percentiles 0 and 100 are the exact minimum and maximum values of the distribution. The accuracy gradually decreases towards the middle of the scale. It is worst at the median and is capped at 1%. \r\n* Error bounds are observed on the rank, not on the value. Suppose percentile(X, 50) returned value of Xm. The estimation guarantees that at least 49% and at most 51% of the values of X are less or equal to Xm. There is no theoretical limit on the difference  between Xm and actual median value of X.\r\n* The estimation may sometimes result in a precise value but there are no reliable conditions to define when it will be the case", "https://kusto.azurewebsites.net/docs/query/percentiles-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "percentile_tdigest", "Calculates the percentile result from tdigest results (which was generated by [tdigest](tdigest-aggfunction.md) or [merge-tdigests](merge-tdigests-aggfunction.md))", "**Syntax**\r\n\r\n`percentile_tdigest(`*Expr*`,` *Percentile1* [`,` *typeLiteral*]`)`\r\n\r\n`percentiles_array_tdigest(`*Expr*`,` *Percentile1* [`,` *Percentile2*] ...[`,` *PercentileN*]`)`\r\n\r\n`percentiles_array_tdigest(`*Expr*`,` *Dynamic array*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression which was generated by [tdigest](tdigest-aggfunction.md) or [merge_tdigests](merge-tdigests-aggfunction.md)\r\n* *Percentile* is a double constant that specifies the percentile.\r\n* *typeLiteral*: An optional type literal (e.g., `typeof(long)`). If provided, the result set will be of this type. \r\n* *Dynamic array*: list of percentiles in a dynamic array of integer or floating point numbers\r\n\r\n**Returns**\r\n\r\nThe percentiles/percentilesw value of each value in *Expr*.\r\n\r\n**Tips**\r\n\r\n1) The function must recieve at least one percent (and maybe more, see the syntax above: *Percentile1* [`,` *Percentile2*] ...[`,` *PercentileN*]) and the result will be\r\n  a dynamic array which includes the results. (such like [`percentiles()`](percentiles-aggfunction.md))\r\n  \r\n2) if only one percent was provided and the type was provided also then the result will be a column of the same type provided with the results of that percent (all tdigests must be of that type in this case).\r\n\r\n3) if *Expr* includes tdigests of different types, then don't provide the type and the result will be of type dynamic. (see examples below).", "```\r\nStormEvents\r\n| summarize tdigestRes = tdigest(DamageProperty) by State\r\n| project percentile_tdigest(tdigestRes, 100, typeof(int))\r\n```\r\n\r\n|percentile_tdigest_tdigestRes|\r\n|---|\r\n|0|\r\n|62000000|\r\n|110000000|\r\n|1200000|\r\n|250000|\r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| summarize tdigestRes = tdigest(DamageProperty) by State\r\n| project percentiles_array_tdigest(tdigestRes, range(0, 100, 50), typeof(int))\r\n```\r\n\r\n|percentile_tdigest_tdigestRes|\r\n|---|\r\n|[0,0,0]|\r\n|[0,0,62000000]|\r\n|[0,0,110000000]|\r\n|[0,0,1200000]|\r\n|[0,0,250000]|\r\n\r\n\r\n\r\n```\r\nStormEvents\r\n| summarize tdigestRes = tdigest(DamageProperty) by State\r\n| union (StormEvents | summarize tdigestRes = tdigest(EndTime) by State)\r\n| project percentile_tdigest(tdigestRes, 100)\r\n```\r\n\r\n|percentile_tdigest_tdigestRes|\r\n|---|\r\n|[0]|\r\n|[62000000]|\r\n|[\"2007-12-20T11:30:00.0000000Z\"]|\r\n|[\"2007-12-31T23:59:00.0000000Z\"]|", "https://kusto.azurewebsites.net/docs/query/percentile-tdigestfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "percentrank_tdigest", "Calculates the approximate rank of the value in a set where rank is expressed as percentage of set's size. \r\nThis function can be viewed as the inverse of the percentile.", "**Syntax**\r\n\r\n`percentrank_tdigest(`*TDigest*`,` *Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *TDigest*: Expression which was generated by [tdigest](tdigest-aggfunction.md) or [merge_tdigests](merge-tdigests-aggfunction.md)\r\n* *Expr*: Expression representing a value to be used for percentage ranking calculation.\r\n\r\n**Returns**\r\n\r\nThe percentage rank of value in a dataset.\r\n\r\n**Tips**\r\n\r\n1) The type of second parameter and the type of the elements in the tdigest should be the same.\r\n\r\n2) First parameter should be TDigest which was generated by [tdigest()](tdigest-aggfunction.md) or [merge_tdigests()](merge-tdigests-aggfunction.md)", "Getting the percentrank_tdigest() of the damage property that valued 4490$ is ~85%:\r\n\r\n\r\n```\r\nStormEvents\r\n| summarize tdigestRes = tdigest(DamageProperty)\r\n| project percentrank_tdigest(tdigestRes, 4490)\r\n\r\n```\r\n\r\n|Column1|\r\n|---|\r\n|85.0015237192293|\r\n\r\n\r\nUsing percentile 85 over the damage property should give 4490$:\r\n\r\n\r\n```\r\nStormEvents\r\n| summarize tdigestRes = tdigest(DamageProperty)\r\n| project percentile_tdigest(tdigestRes, 85, typeof(long))\r\n\r\n```\r\n\r\n|percentile_tdigest_tdigestRes|\r\n|---|\r\n|4490|", "https://kusto.azurewebsites.net/docs/query/percentrank-tdigestfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "pi", "Returns the constant value of Pi (Ï).", "**Syntax**\r\n\r\n`pi()`\r\n\r\n**Returns**\r\n\r\n* The value of Pi.", "", "https://kusto.azurewebsites.net/docs/query/pifunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "point", "Returns a dynamic array representation of a point.", "**Syntax**\r\n\r\n`point(`*latitude*`,`*longitude*`)`\r\n\r\n**Arguments**\r\n\r\n* *latitude*: Latitude value between -90 and 90.\r\n* *longitude*: Longitude value between -180 and 180.\r\n\r\n**Returns**\r\n\r\nReturns a dynamic array containing the latitude and longitude values.\r\nIf the latitude value is outside [-90, 90] the function returns `null`.\r\nIf the longitude value is outside (-180, 180] the value will wrap around.", "The following example returns `[1.0, 2.0]`:\r\n\r\n\r\n```\r\nprint point(1, 2)\r\n```\r\n\r\nThe following example returns `[0.0, -90.0]`:\r\n\r\n\r\n```\r\nprint point(0, 270)\r\n```\r\n\r\nThe following example returns `null`:\r\n\r\n\r\n```\r\nprint point(91, 0)\r\n```", "https://kusto.azurewebsites.net/docs/query/pointfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "pow", "Returns a result of raising to power", "**Syntax**\r\n\r\n`pow(`*base*`,` *exponent* `)`\r\n\r\n**Arguments**\r\n\r\n* *base*: Base value.\r\n* *exponent*: Exponent value.\r\n\r\n**Returns**\r\n\r\nReturns base raised to the power exponent: base ^ exponent.", "", "https://kusto.azurewebsites.net/docs/query/powfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "prev", "Returns the value of a column in a row that it at some offset prior to the\r\ncurrent row in a [serialized row set](./windowsfunctions.md#serialized-row-set).", "**Syntax**\r\n\r\n`prev(column)`\r\n\r\n`prev(column, offset)`\r\n\r\n`prev(column, offset, default_value)`\r\n\r\n**Arguments**\r\n\r\n* `column`: the column to get the values from.\r\n\r\n* `offset`: the offset to go back in rows. When no offset is specified a default offset 1 is used.\r\n\r\n* `default_value`: the default value to be used when there is no previous rows to take the value from. When no default value is specified, null is used.", "```\r\nTable | serialize | extend prevA = prev(A,1)\r\n| extend diff = A - prevA\r\n| where diff > 1\r\n\r\nTable | serialize prevA = prev(A,1,10)\r\n| extend diff = A - prevA\r\n| where diff <= 10\r\n```", "https://kusto.azurewebsites.net/docs/query/prevfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "print", "Evaluates one or more scalar expressions and inserts the results (as a single-row table with as many columns as there are expressions) into the output.", "print banner=strcat(\"Hello\", \", \", \"World!\")\r\n\r\n**Syntax**\r\n\r\n`print` [*ColumnName* `=`] *ScalarExpression* [',' ...]\r\n\r\n**Arguments**\r\n\r\n* *ColumnName*: An option name to assign to the output's singular column.\r\n* *ScalarExpression*: A scalar expression to evaluate.\r\n\r\n**Returns**\r\n\r\nA single-column, single-row, table whose single cell has the value of the evaluated *ScalarExpression*.", "The `print` operator is useful as a quick way to evaluate one or more\r\nscalar expressions and make a single-row table out of the resulting values.\r\nFor example:\r\n\r\n\r\n```\r\nprint 0 + 1 + 2 + 3 + 4 + 5, x = \"Wow!\"\r\n\r\nprint banner=strcat(\"Hello\", \", \", \"World!\")\r\n```", "https://kusto.azurewebsites.net/docs/query/printoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "project", "Select the columns to include, rename or drop, and insert new computed columns.", "The order of the columns in the result is specified by the order of the arguments. Only the columns specified in the arguments are included in the result: any others in the input are dropped.  (See also `extend`.)\r\n\r\n    T | project cost=price*quantity, price\r\n\r\n**Syntax**\r\n\r\n*T* `| project` *ColumnName* [`=` *Expression*] [`,` ...]\r\n  \r\nor\r\n  \r\n*T* `| project` [*ColumnName* | `(`*ColumnName*[`,`]`)` `=`] *Expression* [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The input table.\r\n* *ColumnName:* Optional name of a column to appear in the output. If there is no *Expression*, then *ColumnName* is mandatory and a column of that name must appear in the input. If omitted then the name will be generated. If *Expression* returns more than one column, then a list of column names can be specified in parenthesis. In this case *Expression*'s output columns will be given the specified names, dropping all rest of the output columns if any. If list of the column names is not specified then all *Expression*'s output columns with generated names will be added to output.\r\n* *Expression:* Optional scalar expression referencing the input columns. If *ColumnName* is not omitted then Expression* is mandatory.\r\n\r\n    It is legal to return a new calculated column with the same name as an existing column in the input.\r\n\r\n**Returns**\r\n\r\nA table that has the columns named as arguments, and as many rows as the input table.", "The following example shows several kinds of manipulations that can be done\r\nusing the `project` operator. The input table `T` has three columns of type `int`: `A`, `B`, and `C`. \r\n\r\n\r\n```\r\nT\r\n| project\r\n    X=C,                       // Rename column C to X\r\n    A=2*B,                     // Calculate a new column A from the old B\r\n    C=strcat(\"-\",tostring(C)), // Calculate a new column C from the old C\r\n    B=2*B                      // Calculate a new column B from the old B\r\n```\r\n\r\nSee [series_stats](series-statsfunction.md) as an example of a function that returns multiple columns", "https://kusto.azurewebsites.net/docs/query/projectoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "project-away", "Select what  columns to exclude from the input.", "T | project-away price, quantity\r\n\r\nThe order of the columns in the result is specified by their original order in the table. Only the columns that were specified as arguments are dropped: any others are included in the result.  (See also `project`.)\r\n\r\n**Syntax**\r\n\r\n*T* `| project-away` *ColumnName* [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The input table.\r\n* *ColumnName:* The name of a column to remove from the output. \r\n\r\n**Returns**\r\n\r\nA table that has the columns that were not named as arguments, and as many rows as the input table.\r\n\r\n**Tips**\r\n\r\n* Use [`project-rename`](projectrenameoperator.md) instead if you also want to rename some of the columns.\r\n\r\n* You can project-away any columns that are present in the original table or that were computed as part of the query.", "The input table `T` has three columns of type `int`: `A`, `B`, and `C`. \r\n\r\n\r\n```\r\nT | project-away C    // Removes column C from the output\r\n```\r\n\r\nReturns the table only with columns `A`, `B`. \r\n\r\nConsider the example for [`parse`](parseoperator.md). \r\nThe column `eventText` of table `Traces` contains\r\nstrings of the form `Event: NotifySliceRelease (resourceName={0}, totalSlices= {1}, sliceNumber={2}, lockTime={3}, releaseTime={4}, previousLockTime={5})`.\r\nThe operation below will extend the table with 6 columns: `resourceName` , `totalSlices`, `sliceNumber`, `lockTime `, `releaseTime`, `previouLockTime`, \r\n `Month` and `Day`, excluding the original 'evenText' column.\r\n\r\n\r\n```\r\nTraces  \r\n| parse eventText with * \"resourceName=\" resourceName \", totalSlices=\" totalSlices:long * \"sliceNumber=\" sliceNumber:long * \"lockTime=\" lockTime \", releaseTime=\" releaseTime:date \",\" * \"previousLockTime=\" previouLockTime:date \")\" *  \r\n| project-away eventText\r\n```", "https://kusto.azurewebsites.net/docs/query/projectawayoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "project-rename", "Renames columns in the result output.", "T | project-rename new_column_name = column_name\r\n\r\n**Syntax**\r\n\r\n*T* `| project-rename` *NewColumnName* = *ExistingColumnName* [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The input table.\r\n* *NewColumnName:* The new name of a column. \r\n* *ExistingColumnName:* The existing name of a column. \r\n\r\n**Returns**\r\n\r\nA table that has the columns in the same order as in an existing table, with columns renamed.", "```\r\nprint a='a', b='b', c='c'\r\n|  project-rename new_b=b, new_a=a\r\n```\r\n\r\n|new_a|new_b|c|\r\n|---|---|---|\r\n|a|b|c|", "https://kusto.azurewebsites.net/docs/query/projectrenameoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "radians", "Converts angle value in degrees into value in radians, using formula `radians = (PI / 180 ) * angle_in_degrees`", "**Syntax**\r\n\r\n`radians(`*a*`)`\r\n\r\n**Arguments**\r\n\r\n* *a*: Angle in degrees (a real number).\r\n\r\n**Returns**\r\n\r\n* The corresponding angle in radians for an angle specified in degrees.", "```\r\nprint radians0 = radians(90), radians1 = radians(180), radians2 = radians(360) \r\n\r\n```\r\n\r\n|radians0|radians1|radians2|\r\n|---|---|---|\r\n|1.5707963267949|3.14159265358979|6.28318530717959|", "https://kusto.azurewebsites.net/docs/query/radiansfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "rand", "Returns a random number.", "rand()\r\n    rand(1000)\r\n\r\n**Syntax**\r\n\r\n* `rand()` - returns a value of type `real`\r\n  with a uniform distribution in the range [0.0, 1.0).\r\n* `rand(` *N* `)` - returns a value of type `real`\r\n  chosen with a uniform distribution from the set {0.0, 1.0, ..., *N* - 1}.", "", "https://kusto.azurewebsites.net/docs/query/randfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "range", "Generates a dynamic array holding a series of equally-spaced values.", "**Syntax**\r\n\r\n`range(`*start*`,` *stop*[`,` *step*]`)` \r\n\r\n**Arguments**\r\n\r\n* *start*: The value of the first element in the resulting array. \r\n* *stop*: The value of the last element in the resulting array,\r\nor the least value that is greater than the last element in the resulting\r\narray and within an integer multiple of *step* from *start*.\r\n* *step*: The difference between two consecutive elements of\r\nthe array. \r\nThe default value for *step* is `1` for numeric and `1h` for `timespan` or `datetime`", "The following example returns `[1, 4, 7]`:\r\n\r\n\r\n```\r\nT | extend r = range(1, 8, 3)\r\n```\r\n\r\nThe following example returns an array holding all days\r\nin the year 2015:\r\n\r\n\r\n```\r\nT | extend r = range(datetime(2015-01-01), datetime(2015-12-31), 1d)\r\n```\r\n\r\nThe following example returns `[1,2,3]`:\r\n\r\n```\r\nrange(1, 3)\r\n```\r\n\r\nThe follwing example returns `[\"01:00:00\",\"02:00:00\",\"03:00:00\",\"04:00:00\",\"05:00:00\"]`:\r\n```\r\nrange(1h, 5h)\r\n```", "https://kusto.azurewebsites.net/docs/query/rangefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "range", "Generates a single-column table of values.", "Notice that it doesn't have a pipeline input. \r\n\r\n**Syntax**\r\n\r\n`range` *columnName* `from` *start* `to` *stop* `step` *step*\r\n\r\n**Arguments**\r\n\r\n* *columnName*: The name of the single column in the output table.\r\n* *start*: The smallest value in the output.\r\n* *stop*: The highest value being generated in the output (or a bound\r\non the highest value, if *step* steps over this value).\r\n* *step*: The difference between two consecutive values. \r\n\r\nThe arguments must be numeric, date or timespan values. They can't reference the columns of any table. (If you want to compute the range based on an input table, use the range function, maybe with the mvexpand operator.) \r\n\r\n**Returns**\r\n\r\nA table with a single column called *columnName*,\r\nwhose values are *start*, *start* `+` *step*, ... up to and until *stop*.", "A table of midnight at the past seven days. The bin (floor) function reduces each time to the start of the day.\r\n\r\n\r\n```\r\nrange LastWeek from ago(7d) to now() step 1d\r\n```\r\n\r\n|LastWeek|\r\n|---|\r\n|2015-12-05 09:10:04.627|\r\n|2015-12-06 09:10:04.627|\r\n|...|\r\n|2015-12-12 09:10:04.627|\r\n\r\n\r\nA table with a single column called `Steps`\r\nwhose type is `long` and whose values are `1`, `4`, and `7`.\r\n\r\n\r\n```\r\nrange Steps from 1 to 8 step 3\r\n```\r\n\r\nThe next example shows how the `range` operator can be used to create\r\na small, ad-hoc, dimension table which is then used to introduce zeros where the source data has no values.\r\n\r\n\r\n```\r\nrange TIMESTAMP from ago(4h) to now() step 1m\r\n| join kind=fullouter\r\n  (Traces\r\n      | where TIMESTAMP > ago(4h)\r\n      | summarize Count=count() by bin(TIMESTAMP, 1m)\r\n  ) on TIMESTAMP\r\n| project Count=iff(isnull(Count), 0, Count), TIMESTAMP\r\n| render timechart  \r\n```", "https://kusto.azurewebsites.net/docs/query/rangeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "reduce", "The `reduce` operator groups a set of `string` values together based on similarity.", "T | reduce by LogMessage with threshold=0.1\r\n\r\nFor each such group, it outputs a **pattern** that best describes the group (possibly using the\r\nasterix (`*`) character to represent wildcards), a **count** of the number of values in the group,\r\nand a **representative** of the group (one of the original values in the group).\r\n\r\n\r\n**Syntax**\r\n\r\n*T* `|` `reduce` [`kind` `=` *ReduceKind*] `by` *Expr* [`with` [`threshold` `=` *Threshold*] [`,` `characters` `=` *Characters*] ]\r\n\r\n**Arguments**\r\n\r\n* *Expr*: An expression that evaluates to a `string` value.\r\n* *Threshold*: A `real` literal in the range (0..1). Default is 0.1. For large inputs, threshold should be small. \r\n* *Characters*: A `string` literal containing a list of characters to add to the list of characters\r\n  that don't break a term. (For example, if you want `aaa=bbbb` and `aaa:bbb` to each be a whole term,\r\n  rather than break on `=` and `:`, use `\":=\"` as the string literal.)\r\n* *ReduceKind*: Specifies the reduce flavor. The only valid value for the time being is `source`.\r\n\r\n**Returns**\r\n\r\nThis operator returns a table with three columns (`Pattern`, `Count`, and `Representative`),\r\nand as many rows as there are groups. `Pattern` is the pattern value for the group, with `*`\r\nbeing used as a wildcard (representing arbitrary insertion strings), `Count` counts how\r\nmany rows in the input to the operator are represented by this pattern, and `Representative`\r\nis one value from the input that falls into this group.\r\n\r\nIf `[kind=source]` is specified, the operator will append the `Pattern` column to the existing table structure.\r\nNote that the syntax an schema of this flavor might be subjected to future changes.\r\n\r\nFor example, the result of `reduce by city` might include: \r\n\r\n|Pattern     |Count |Representative|\r\n|------------|------|--------------|\r\n| San *      | 5182 |San Bernard   |\r\n| Saint *    | 2846 |Saint Lucy    |\r\n| Moscow     | 3726 |Moscow        |\r\n| \\* -on- \\* | 2730 |One -on- One  |\r\n| Paris      | 2716 |Paris         |\r\n\r\nAnother example with customized tokenization:\r\n\r\n\r\n```\r\nrange x from 1 to 1000 step 1\r\n| project MyText = strcat(\"MachineLearningX\", tostring(toint(rand(10))))\r\n| reduce by MyText  with threshold=0.001 , characters = \"X\" \r\n```\r\n\r\n|Pattern         |Count|Representative   |\r\n|----------------|-----|-----------------|\r\n|MachineLearning*|1000 |MachineLearningX4|", "The following example shows how one might apply the `reduce` operator to a \"sanitized\"\r\ninput, in which GUIDs in the column being reduced are replaced prior to reducing\r\n\r\n\r\n```\r\n// Start with a few records from the Trace table.\r\nTrace | take 10000\r\n// We will reduce the Text column which includes random GUIDs.\r\n// As random GUIDs interfere with the reduce operation, replace them all\r\n// by the string \"GUID\".\r\n| extend Text=replace(@\"[[:xdigit:]]{8}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{4}-[[:xdigit:]]{12}\", @\"GUID\", Text)\r\n// Now perform the reduce. In case there are other \"quasi-random\" identifiers with embedded '-'\r\n// or '_' characters in them, treat these as non-term-breakers.\r\n| reduce by Text with characters=\"-_\"\r\n```\r\n\r\n**See also**\r\n\r\n[autocluster](./autoclusterplugin.md)\r\n\r\n**Notes**\r\n\r\nThe implementation of `reduce` operator is largely based on the paper [A Data Clustering Algorithm for Mining Patterns From Event Logs](https://ristov.github.io/publications/slct-ipom03-web.pdf), by Risto Vaarandi.", "https://kusto.azurewebsites.net/docs/query/reduceoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "render", "Renders results in as graphical output.", "T | render timechart\r\n\r\nThe render operator should be the last operator in the query expression.\r\n\r\n**Syntax**\r\n\r\n*T* `|` `render` *Visualization* [`with` (\r\n\r\n  [`title` `=` *Title*],\r\n\r\n  [`xcolumn` `=` *xColumn*],\r\n\r\n  [`series` `=` *Series*],\r\n\r\n  [`ycolumns` `=` *yColumns*],\r\n\r\n  [`kind` `=` *VisualizationKind*],\r\n\r\n  [`xtitle` `=` *xTitle*],\r\n\r\n  [`ytitle` `=` *yTitle*],\r\n\r\n  [`legend` `=` *Legend*],\r\n\r\n  [`ysplit` `=` *ySplit*],\r\n\r\n  [`accumulate` `=` *Accumulate*]\r\n)]\r\n\r\nWhere:\r\n* *Visualization* indicates the kind of visualization to perform. Supported values are:\r\n\r\n|*Visualization*     |Description|\r\n|--------------------|-|\r\n| `anomalychart`     | Similar to timechart, but [highlights anomalies](./samples.md#get-more-out-of-your-data-in-kusto-using-machine-learning) using an external machine-learning service. |\r\n| `areachart`        | Area graph. First column is x-axis, and should be a numeric column. Other numeric columns are y-axes. |\r\n| `barchart`         | First column is x-axis, and can be text, datetime or numeric. Other columns are numeric, displayed as horizontal strips.|\r\n| `columnchart`      | Like `barchart`, with vertical strips instead of horizontal strips.|\r\n| `ladderchart`      | Last two columns are the x-axis, other columns are y-axis.|\r\n| `linechart`        | Line graph. First column is x-axis, and should be a numeric column. Other numeric columns are y-axes. |\r\n| `piechart`         | First column is color-axis, second column is numeric. |\r\n| `pivotchart`       | Displays a pivot table and chart. User can interactively select data, columns, rows and various chart types. |\r\n| `scatterchart`     | Points graph. First column is x-axis, and should be a numeric column. Other numeric columns are y-axes. |\r\n| `stackedareachart` | Stacked area graph. First column is x-axis, and should be a numeric column. Other numeric columns are y-axes. |\r\n| `table`            | Default - results are shown as a table.|\r\n| `timechart`        | Line graph. First column is x-axis, and should be datetime. Other columns are y-axes.|\r\n| `timepivot`        | Interactive navigation over the events time-line (pivoting on time axis)|\r\n\r\n* *title* is an optional `string` value that holds the title for the results.\r\n\r\n* *xColumn* is an optional column identifier, that defines data from which column will be used as x-axis.\r\n\r\n* *series* is an optional list of columns to control which \"axis\" is driven by which column in the data.\r\n\r\n* *yColumns* is an optional list of columns, data from which will be used as y-values.\r\n\r\n* *kind* is an optional identifier that chooses between the available kinds of the\r\n  chosen *Visualization* (such as `barchart` and `columnchart`), if more than one kind is supported:\r\n\r\n|*Visualization*|*kind*|Description                     |\r\n|---------------|-------------------|--------------------------------|\r\n|`areachart`    |`default`          |Default, same as `unstacked`    |\r\n|               |`unstacked`        |Each \"area\" to its own          |\r\n|               |`stacked`          |\"Areas\" are stacked to the right|\r\n|               |`stacked100`       |\"Areas\" are stacked to the right, and stretched to the same width|\r\n|`barchart`     |`default`          |Default, same as `unstacked`    |\r\n|               |`unstacked`        |Each bar to its own             |\r\n|               |`stacked`          |Bars are stacked to the right   |\r\n|               |`stacked100`       |Bars are stacked to the right, and stretched to the same width|\r\n|`columnchart`  |`default`          |Default, same as `unstacked`    |\r\n|               |`unstacked`        |Each column to its own          |\r\n|               |`stacked`          |Columns are stacked upwards     |\r\n|               |`stacked100`       |Columns are stacked upwards, and stretched to the same height|\r\n\r\n* *xTitle* is an optional `string` value that holds the title for the X-Axis.\r\n\r\n* *yTitle* is an optional `string` value that holds the title for the Y-Axis.\r\n\r\n* *legend* is an optional value that can be set to either `visible` (the default) or `hidden`, which defines whether to display chart legend or not.\r\n\r\n* *ySplit* is an optional identifier that chooses between the available options of Y-Axis visualization:\r\n\r\n|*ySplit*|Description               |\r\n|---------------|-------------------|\r\n|`none`         |Default, chart displayed with single Y-Axis for all series |\r\n|`axes`         |Displayed single chart with separate Y-Axis for each serie |\r\n|`panels`       |For every column, defined as Y, generated separate panel, with binding to the same X-Axis (maximal panels amount is 5)|\r\n\r\n* *accumulate* is an optional value that can be set to either `true` or `false` (the default),\r\n  and indicates whether to accumulate y-axis numeric values for presentation.\r\n\r\n**Tips**\r\n\r\n* Only positive values are displayed.\r\n* Use `where`, `summarize` and `top` to limit the volume that you display.\r\n* Sort the data to define the order of the x-axis.", "[Rendering examples in the tutorial](./tutorial.md#render-display-a-chart-or-table).\r\n\r\n[Anomaly detection](./samples.md#get-more-out-of-your-data-in-kusto-using-machine-learning)", "https://kusto.azurewebsites.net/docs/query/renderoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "repeat", "Generates a dynamic array holding a series of equal values.", "**Syntax**\r\n\r\n`repeat(`*value*`,` *count*`)` \r\n\r\n**Arguments**\r\n\r\n* *value*: The value of the element in the resulting array. The type of *value* can be integer, long, real, datetime, or timespan.   \r\n* *count*: The count of the elements in the resulting array. The *count* must be an integer number.\r\nIf *count* is equal to zero, a empty array is returned.\r\nIf *count* is less than zero, a null value is returned.", "The following example returns `[1, 1, 1]`:\r\n\r\n\r\n```\r\nT | extend r = repeat(1, 3)\r\n```", "https://kusto.azurewebsites.net/docs/query/repeatfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "replace", "Replace all regex matches with another string.", "**Syntax**\r\n\r\n`replace(`*regex*`,` *rewrite*`,` *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: The [regular expression](https://github.com/google/re2/wiki/Syntax) to search *text*. It can contain capture groups in '('parentheses')'. \r\n* *rewrite*: The replacement regex for any match made by *matchingRegex*. Use `\\0` to refer to the whole match, `\\1` for the first capture group, `\\2` and so on for subsequent capture groups.\r\n* *text*: A string.\r\n\r\n**Returns**\r\n\r\n*text* after replacing all matches of *regex* with evaluations of *rewrite*. Matches do not overlap.", "This statement:\r\n\r\n\r\n```\r\nrange x from 1 to 5 step 1\r\n| extend str=strcat('Number is ', tostring(x))\r\n| extend replaced=replace(@'is (\\d+)', @'was: \\1', str)\r\n```\r\n\r\nHas the following results:\r\n\r\n| x    | str | replaced|\r\n|---|---|---|\r\n| 1    | Number is 1.000000  | Number was: 1.000000|\r\n| 2    | Number is 2.000000  | Number was: 2.000000|\r\n| 3    | Number is 3.000000  | Number was: 3.000000|\r\n| 4    | Number is 4.000000  | Number was: 4.000000|\r\n| 5    | Number is 5.000000  | Number was: 5.000000|", "https://kusto.azurewebsites.net/docs/query/replacefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "reverse", "Function makes reverse of input string.", "If input value is not of string type, function forcibly casts the value to string.\r\n\r\n**Syntax**\r\n\r\n`reverse(`*source*`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: input value.  \r\n\r\n**Returns**\r\n\r\nThe reverse order of a string value.", "```\r\nprint str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\r\n| extend rstr = reverse(str)\r\n```\r\n\r\n|str|rstr|\r\n|---|---|\r\n|ABCDEFGHIJKLMNOPQRSTUVWXYZ|ZYXWVUTSRQPONMLKJIHGFEDCBA|\r\n\r\n\r\n\r\n```\r\nprint ['int'] = 12345, ['double'] = 123.45, \r\n['datetime'] = datetime(2017-10-15 12:00), ['timespan'] = 3h\r\n| project rint = reverse(['int']), rdouble = reverse(['double']), \r\nrdatetime = reverse(['datetime']), rtimespan = reverse(['timespan'])\r\n```\r\n\r\n|rint|rdouble|rdatetime|rtimespan|\r\n|---|---|---|---|\r\n|54321|54.321|Z0000000.00:00:21T51-01-7102|00:00:30|", "https://kusto.azurewebsites.net/docs/query/reversefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "round", "Returns the rounded source to the specified precision.", "**Syntax**\r\n\r\n`round(`*source* [`,` *Precision*]`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The source scalar the round is calculated on.\r\n* *Precision*: Number of digits the source will be rounded to.(default value is 0)\r\n\r\n**Returns**\r\n\r\nThe rounded source to the specified precision.\r\n\r\nRound is different than [`bin()`](binfunction.md)/[`floor()`](floorfunction.md) in\r\nthat the first rounds a number to a specific number of digits while the last rounds value to an integer multiple \r\nof a given bin size (round(2.15, 1) returns 2.2 while bin(2.15, 1) returns 2).", "```\r\nround(2.15, 1)                   // 2.2\r\nround(2.15) (which is the same as round(2.15, 0))                   // 2\r\nround(-50.55, -2)                   // -100\r\nround(21.5, -1)                   // 20\r\n```", "https://kusto.azurewebsites.net/docs/query/roundfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "row_cumsum", "Calculates the cumulative sum of a column in a [serialized row set](./windowsfunctions.md#serialized-row-set).", "**Syntax**\r\n\r\n`row_cumsum` `(` *Term* [`,` *Restart*] `)`\r\n\r\n* *Term* is an expression indicating the value to be summed.\r\n  The expression must be a scalar of one of the following types:\r\n  `decimal`, `int`, `long`, or `real`. Null *Term* values do not affect the\r\n  sum.\r\n* *Restart* is an optional argument of type `bool` that indicates when the\r\n  accummulation operation should be restarted (set back to 0). It can be\r\n  used to indicate partitions of the data; see the second example below.\r\n\r\n**Returns**\r\n\r\nThe function returns the cumulative sum of its argument.", "The following example shows how to calculate the cumulative sum of the first\r\nfew odd integers.\r\n\r\n\r\n```\r\ndatatable (a:long) [\r\n    1, 2, 3, 4, 5, 6, 7, 8, 9, 10\r\n]\r\n| where a%2==0\r\n| serialize cs=row_cumsum(a)\r\n```\r\n\r\na    | cs\r\n-----|-----\r\n2    | 2\r\n4    | 6\r\n6    | 12\r\n8    | 20\r\n10   | 30\r\n\r\nThis example shows how to calculate the cumulative sum (here, of `salary`)\r\nwhen the data is partitioned (here, by `name`):\r\n\r\n\r\n```\r\ndatatable (name:string, month:int, salary:long)\r\n[\r\n    \"Alice\", 1, 1000,\r\n    \"Bob\",   1, 1000,\r\n    \"Alice\", 2, 2000,\r\n    \"Bob\",   2, 1950,\r\n    \"Alice\", 3, 1400,\r\n    \"Bob\",   3, 1450,\r\n]\r\n| order by name asc, month asc\r\n| extend total=row_cumsum(salary, name != prev(name))\r\n```\r\n\r\nname   | month  | salary  | total\r\n-------|--------|---------|------\r\nAlice  | 1      | 1000    | 1000\r\nAlice  | 2      | 2000    | 3000\r\nAlice  | 3      | 1400    | 4400\r\nBob    | 1      | 1000    | 1000\r\nBob    | 2      | 1950    | 2950\r\nBob    | 3      | 1450    | 4400", "https://kusto.azurewebsites.net/docs/query/rowcumsumfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "row_number", "Returns the current row's index in a [serialized row set](./windowsfunctions.md#serialized-row-set).\r\nThe row index starts by default at `1` for the first row, and is incremented by `1` for each additional row.\r\nOptionally, the row index can start at a different value than `1`.\r\nAdditionally, the row index may be reset according to some provided predicate.", "**Syntax**\r\n\r\n`row_number` `(` [*StartingIndex* [`,` *Restart*]] `)`\r\n\r\n* *StartingIndex* is a constant expression of type `long` indicating the value\r\n  of the row index to start at (or to restart to). The default value is `1`.\r\n* *Restart* is an optional argument of type `bool` that indicates when the\r\n  numbering is to be restarted to the *StartingIndex* value. If not provided,\r\n  the default value of `false` is used.\r\n\r\n**Returns**\r\n\r\nThe function returns the row index of the current row as a value of type `long`.", "The following example returns a table with two columns, the first column (`a`)\r\nwith numbers from `10` down to `1`, and the second column (`rn`) with numbers\r\nfrom `1` up to `10`:\r\n\r\n\r\n```\r\nrange a from 1 to 10 step 1\r\n| sort by a desc\r\n| extend rn=row_number()\r\n```\r\n\r\nThe following example is similar to the above, only the second column (`rn`)\r\nstarts at `7`:\r\n\r\n\r\n```\r\nrange a from 1 to 10 step 1\r\n| sort by a desc\r\n| extend rn=row_number(7)\r\n```\r\n\r\nThe last example shows how one can partition the data and number the rows\r\nper each partition. Here, we partition the data by `Airport`:\r\n\r\n\r\n```\r\ndatatable (Airport:string, Airline:string, Departures:long)\r\n[\r\n  \"TLV\", \"LH\", 1,\r\n  \"TLV\", \"LY\", 100,\r\n  \"SEA\", \"LH\", 1,\r\n  \"SEA\", \"BA\", 2,\r\n  \"SEA\", \"LY\", 0\r\n]\r\n| sort by Airport asc, Departures desc\r\n| extend Rank=row_number(1, prev(Airport) != Airport)\r\n```\r\n\r\nRunning this query produces the following result:\r\n\r\nAirport  | Airline  | Departures  | Rank\r\n---------|----------|-------------|------\r\nSEA      | BA       | 2           | 1\r\nSEA      | LH       | 1           | 2\r\nSEA      | LY       | 0           | 3\r\nTLV      | LY       | 100         | 1\r\nTLV      | LH       | 1           | 2", "https://kusto.azurewebsites.net/docs/query/rownumberfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "sample", "Returns up to the specified number of random rows from the input table.", " T | sample 5\r\n\r\n**Syntax**\r\n\r\n*T* `| sample`  *NumberOfRows*\r\n\r\n**Arguments**\r\n* *NumberOfRows*: The number of rows of *T* to return. You can specify any numeric expression.\r\n\r\n**Remarks**\r\n\r\n`sample` is a non-deterministic operator, and will return different result set each time it is evaluated during the query. For example, the following query yields two different rows (even if one would expect to return the same row twice).\r\n\r\n\r\n```\r\nlet _data = range x from 1 to 100 step 1;\r\nlet _sample = _data | sample 1;\r\nunion (_sample), (_sample)\r\n```\r\n\r\n|x|\r\n|---|\r\n|83|\r\n|3|\r\n\r\nIn order to ensure that in example above `_sample` is calculated once, one can use [materialize()](./materializefunction.md) function:\r\n\r\n\r\n```\r\nlet _data = range x from 1 to 100 step 1;\r\nlet _sample = materialize(_data | sample 1);\r\nunion (_sample), (_sample)\r\n```\r\n\r\n|x|\r\n|---|\r\n|34|\r\n|34|\r\n\r\n**Tips**\r\n\r\n* if you want to sample a certain percentage of your data (rather than a specified number of rows), you can use \r\n\r\n\r\n```\r\nStormEvents | where rand() < 0.1\r\n```\r\n\r\n* If you want to sample keys rather than rows (for example - sample 100 user ids and get all rows for these user IDS) you can use [`sample-distinct`](./sampledistinctoperator.md) in combination with the `in` operator.", "```\r\nStormEvents | sample 10\r\n```", "https://kusto.azurewebsites.net/docs/query/sampleoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "sample-distinct", "Returns a single column that contains up to the specified number of distinct values of the requested column.", "the default (and currently only) flavor of the operator tries to return an answer as quickly as possible (rather than trying to make a fair sample)\r\n\r\n     T | sample-distinct 5 of DeviceId\r\n\r\n**Syntax**\r\n\r\n*T* `| sample-distinct` *NumberOfValues* `of` *ColumnName*\r\n\r\n**Arguments**\r\n* *NumberOfValues*: The number distinct values of *T* to return. You can specify any numeric expression.\r\n\r\n**Tips**\r\n\r\n Can be handy to sample a population by putting `sample-distinct` in a let statement and later filter using the `in` operator (see example) \r\n\r\n If you want the top values rather than just a sample, you can use the [top-hitters](tophittersoperator.md) operator \r\n\r\n if you want to sample data rows (rather than values of a specific column), refer to the [sample operator](sampleoperator.md)\r\n\r\n**Examples**  \r\nGet 10 distinct values from a population\r\n\r\n```\r\nStormEvents | sample-distinct 10 of EpisodeId\r\n\r\n```\r\n\r\nSample a population and do further computation knowing the summarize won't exceed query limits. \r\n\r\n\r\n```\r\nlet sampleEpisodes = toscalar(StormEvents | sample-distinct 10 of EpisodeId);\r\nStormEvents | where EpisodeId in (sampleEpisodes) | summarize totalInjuries=sum(InjuriesDirect) by EpisodeId\r\n\r\n```", "", "https://kusto.azurewebsites.net/docs/query/sampledistinctoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "search", "The search operator provides a multi-table/multi-column search experience.", "## Syntax\r\n\r\n* [*TabularSource* `|`] `search` [`kind=`*CaseSensitivity*] [`in` `(`*TableSources*`)`] *SearchPredicate*\r\n\r\n## Arguments\r\n\r\n* *TabularSource*: An optional tabular expression that acts as a data source to be searched over,\r\n  such as a table name, a [union operator](unionoperator.md), the results\r\n  of a tabular query, etc. Cannot appear together with the optional phrase that includes *TableSources*.\r\n\r\n* *CaseSensitivity*: An optional flag that controls the behavior of all `string` scalar operators\r\n  with respect to case sensitivity. Valid values are the two synonyms `default` and `case_insensitive`\r\n  (which is the default for operators such as `has`, namely being case-insensitive) and `case_sensitive`\r\n  (which forces all such operators into case-sensitive matching mode).\r\n\r\n* *TableSources*: An optional comma-separated list of \"wildcarded\" table names to take part in the search.\r\n  The list has the same syntax as the list of the [union operator](unionoperator.md).\r\n  Cannot appear together with the optional *TabularSource*.\r\n\r\n* *SearchPredicate*: A mandatory predicate that defines what to search for (in other words,\r\n  a Boolean expression that is evaluated for every record in the input and that, if it returns\r\n  `true`, the record is outputted.)\r\n  The syntax for *SearchPredicate* extends and modifies the normal Kusto syntax for Boolean expressions:\r\n\r\n  **String matching extensions**: String literals that appear as terms in the *SearchPredicate* indicate a term\r\n    match between all columns and the literal using `has`, `hasprefix`, `hassuffix`, and the inverted (`!`)\r\n    or case-sensitive (`sc`) versions of these operators. The decision whether to apply `has`, `hasprefix`,\r\n    or `hassuffix` depends on whether the literal starts or ends (or both) by an asterisk (`*`). Asterisks\r\n    inside the literal are not allowed.\r\n\r\n    |Literal   |Operator   |\r\n    |----------|-----------|\r\n    |`billg`   |`has`      |\r\n    |`*billg`  |`hassuffix`|\r\n    |`billg*`  |`hasprefix`|\r\n    |`*billg*` |`contains` |\r\n    |`bi*lg`   |`matches regex`|\r\n\r\n  **Column restriction**: By default, string matching extensions attempt to match against all columns\r\n    of the data set. It is possible to restrict this matching to a particular column by using\r\n    the following syntax: *ColumnName*`:`*StringLiteral*.\r\n\r\n  **String equality**: Exact matches of a column against a string value (instead of a term-match)\r\n    can be done using the syntax *ColumnName*`==`*StringLiteral*.\r\n\r\n  **Other Boolean expressions**: All regular Kusto Boolean expressions are supported by the syntax.\r\n    For example, `\"error\" and x==123` means: search for records that have the term `error` in any\r\n    of their columns, and have the value `123` in the `x` column.\"\r\n\r\n  **Regex match**: Regular expression matching is indicated using *Column* `matches regex` *StringLiteral*\r\n    syntax, where *StringLiteral* is the regex pattern.\r\n\r\nNote that if both *TabularSource* and *TableSources* are omitted, the search is carried over all unrestricted tables\r\nand views of the database in scope.\r\n\r\n## Summary of string matching extensions\r\n\r\n  |# |Syntax                                 |Meaning (equivalent `where`)           |Comments|\r\n  |--|---------------------------------------|---------------------------------------|--------|\r\n  | 1|`search \"err\"`                         |`where * has \"err\"`                    ||\r\n  | 2|`search in (T1,T2,A*) and \"err\"`       |`union T1,T2,A* | where * has \"err\"`   ||\r\n  | 3|`search col:\"err\"`                     |`where col has \"err\"`                  ||\r\n  | 4|`search col==\"err\"`                    |`where col==\"err\"`                     ||\r\n  | 5|`search \"err*\"`                        |`where * hasprefix \"err\"`              ||\r\n  | 6|`search \"*err\"`                        |`where * hassuffix \"err\"`              ||\r\n  | 7|`search \"*err*\"`                       |`where * contains \"err\"`               ||\r\n  | 8|`search \"Lab*PC\"`                      |`where * matches regex @\"\\bLab\\w*PC\\b\"`||\r\n  | 9|`search *`                             |`where 0==0`                           ||\r\n  |10|`search col matches regex \"...\"`       |`where col matches regex \"...\"`        ||\r\n  |11|`search kind=case_sensitive`           |                                       |All string comparisons are case-sensitive|\r\n  |12|`search \"abc\" and (\"def\" or \"hij\")`    |`where * has \"abc\" and (* has \"def\" or * has hij\")`||\r\n  |13|`search \"err\" or (A>a and A<b)`        |`where * has \"err\" or (A>a and A<b)`   ||\r\n\r\n## Remarks\r\n\r\n**Unlike** the [find operator](findoperator.md), the `search` operator does not support the following:\r\n\r\n1. `withsource=`: The output will always include a column called `$table` of type `string` whose value\r\n   is the table name from which each record was retrieved (or some system-generated name if the source\r\n   is not a table but a composite expression).\r\n2. `project=`, `project-smart`: The output schema is fixed and includes the outer union of all tables\r\n   being searched, up to a limit of 1000 columns.", "```\r\n// 1. Simple term search over all unrestricted tables and views of the database in scope\r\nsearch \"billg\"\r\n\r\n// 2. Like (1), but looking only for records that match both terms\r\nsearch \"billg\" and (\"steveb\" or \"satyan\")\r\n\r\n// 3. Like (1), but looking only in the TraceEvent table\r\nsearch in (TraceEvent) and \"billg\"\r\n\r\n// 4. Like (2), but performing a case-sensitive match of all terms\r\nsearch \"BillB\" and (\"SteveB\" or \"SatyaN\")\r\n\r\n// 5. Like (1), but restricting the match to some columns\r\nsearch CEO:\"billg\" or CSA:\"billg\"\r\n\r\n// 6. Like (1), but only for some specific time limit\r\nsearch \"billg\" and Timestamp >= datetime(1981-01-01)\r\n\r\n// 7. Searches over all the higher-ups\r\nsearch in (C*, TF) \"billg\" or \"davec\" or \"steveb\"\r\n\r\n// 8. A different way to say (7)\r\nunion C*, TF | search \"billg\" or \"davec\" or \"steveb\"\r\n```", "https://kusto.azurewebsites.net/docs/query/searchoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "serialize", "Freezes the order of the input row set arbitrarily, so that [window functions](./windowsfunctions.md)\r\ncould be applied to it.", "T | serialize rn=row_number()\r\n\r\n**Syntax**\r\n\r\n`serialize` [*Name1* `=` *Expr1* [`,` *Name2* `=` *Expr2*]...]\r\n\r\n* The *Name*/*Expr* pairs are similar to those in the [extend operatpr](./extendoperator.md).", "```\r\nTraces\r\n| where ActivityId == \"479671d99b7b\"\r\n| serialize\r\n\r\nTraces\r\n| where ActivityId == \"479671d99b7b\"\r\n| serialize rn = row_number()\r\n```", "https://kusto.azurewebsites.net/docs/query/serializeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_add", "Calculates the element-wise addition of two numeric series inputs.", "**Syntax**\r\n\r\n`series_add(`*series1*`,` *series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *series1, series2*: Input numeric arrays to be element-wise added into a dynamic array result. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of calculated element-wise add operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| project s1 = pack_array(x,y,z), s2 = pack_array(z, y, x)\r\n| extend s1_add_s2 = series_add(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_add_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[5,4,5]|\r\n|[2,4,8]|[8,4,2]|[10,8,10]|\r\n|[3,6,12]|[12,6,3]|[15,12,15]|", "https://kusto.azurewebsites.net/docs/query/series-addfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_decompose", "Applies a decomomposition transformation on a series.", "Takes an expression containing a series (dynamic numerical array) as input and decompose it to seasonal, trend and residual components.\r\n \r\n\r\n**Syntax**\r\n\r\n`series_decompose(`*x* `[,` *seasonality*`,` *trend*`])`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values, typically the resulting output of [make-series](make-seriesoperator.md) or [makelist](makelist-aggfunction.md) operators\r\n* *seasonality*: An integer controlling the seasonal analysis, containing either\r\n    * -1: autodetect seasonality (using [series_periods_detect](series-periods-detectfunction.md) [default] \r\n    * period: positive integer, specifying the expected period in number of bins unit. For example, if the series is in 1h bins, a weekly period is 168 bins\r\n    * 0: no seasonality (i.e. skip extracting this component)    \r\n* *trend*: A string controlling the trend analysis, containing either\r\n    * \"avg\": define trend component as average(x) [default]\r\n    * \"linefit\": extract trend component using linear regression\r\n    * \"none\": no trend, skip extracting this component    \r\n\r\n**Return**\r\n\r\n The function returns the following respective series:\r\n\r\n* `baseline`: the predicted value of the series (sum of seasonal and trend components, see below)\r\n* `seasonal`: the series of the seasonal component:\r\n    * if period is not detected or explicitly set to 0: constant 0\r\n    * if detected or set to positive integer: median of the series points in the same phase\r\n* `trend`: the series of the trend component\r\n* `residual`: the series of the residual component (i.e. x - baseline)\r\n  \r\n\r\n**Notes**\r\n\r\n* Components execution order:\r\n    1. Extract the seasonal series\r\n    2. Subtract it from x, generating the deseasonal series\r\n    3. Extract the trend component from the deseasonal series\r\n    4. Create the baseline = seasonal + trend\r\n    5. Create the residual = x - baseline\r\n    \r\n* Either seasonality and/or trend should be enabled, otherwise the function is redundant and just returns baseline = 0 and residual = x\r\n\r\n**More about series decomposition**\r\n\r\nThis method is usually applied to time series of metrics expected to manifest periodic and/or trend behavior (e.g. service traffic and other usage metrics), in order to either forecast future metric values and/or detect anomalous ones. The implicit assumption of this regression process is that apart from the (a-priori known) seasonal and trend behavior, the time series is stochastic and randomly distributed; consequently, we can forecast future metric values from the seasonal and trend components (ignoring the residual part), while we can detect anomalous values based on outlier detection on the residual part only. Further details can be found in the [Time Series Decomposition chapter](https://www.otexts.org/fpp/6) of this great book.", "**1. Weekly seasonality**\r\n\r\nIn the following example we generate a series with weekly seasonality and without trend, we then add some outliers to it. `series_decompose` finds auto-detects the seasonality and generates a baseline which is almost identical to the the seasonal component. The outliers we added can be clearly seen in the residuals component.\r\n\r\n\r\n```\r\nlet ts=range t from 1 to 24*7*5 step 1 \r\n| extend Timestamp = datetime(2018-03-01 05:00) + 1h * t \r\n| extend y = 2*rand() + iff((t/24)%7>=5, 10.0, 15.0) - (((t%24)/10)*((t%24)/10)) // generate a series with weekly seasonality\r\n| extend y=iff(t==150 or t==200 or t==780, y-8.0, y) // add some dip outliers\r\n| extend y=iff(t==300 or t==400 or t==600, y+8.0, y) // add some spike outliers\r\n| summarize Timestamp=makelist(Timestamp, 10000),y=makelist(y, 10000);\r\nts \r\n| extend series_decompose(y)\r\n| render timechart  \r\n```\r\n![alt text](./Images/samples/series-decompose1.png \"series-decompose1\")\r\n\r\n**2. Weekly seasonality with trend**\r\n\r\nIn this example we add a trend to the series from the previous example. First, we run `series_decompose` with the default parameters in which the trend `avg` default value only takes the average and doesn't compute the trend, we can see that the generated baseline doesn't contain the trend and is less accurate comparing to the previous example, it is most apparent when observing the trend in the residuals.\r\n\r\n\r\n```\r\nlet ts=range t from 1 to 24*7*5 step 1 \r\n| extend Timestamp = datetime(2018-03-01 05:00) + 1h * t \r\n| extend y = 2*rand() + iff((t/24)%7>=5, 5.0, 15.0) - (((t%24)/10)*((t%24)/10)) + t/72.0 // generate a series with weekly seasonality and onlgoing trend\r\n| extend y=iff(t==150 or t==200 or t==780, y-8.0, y) // add some dip outliers\r\n| extend y=iff(t==300 or t==400 or t==600, y+8.0, y) // add some spike outliers\r\n| summarize Timestamp=makelist(Timestamp, 10000),y=makelist(y, 10000);\r\nts \r\n| extend series_decompose(y)\r\n| render timechart  \r\n```\r\n![alt text](./Images/samples/series-decompose2.png \"series-decompose2\")\r\n\r\nNext, we run the same example but since we are expecting a trend in the series, we specify `linefit` in the trend parameter. We can see that the positive trend is detected and the baseline is much closer to the input series. The residuals are close to zero with only the outliers standing out. We can see all the components on the series in the chart.\r\n\r\n\r\n```\r\nlet ts=range t from 1 to 24*7*5 step 1 \r\n| extend Timestamp = datetime(2018-03-01 05:00) + 1h * t \r\n| extend y = 2*rand() + iff((t/24)%7>=5, 5.0, 15.0) - (((t%24)/10)*((t%24)/10)) + t/72.0 // generate a series with weekly seasonality and onlgoing trend\r\n| extend y=iff(t==150 or t==200 or t==780, y-8.0, y) // add some dip outliers\r\n| extend y=iff(t==300 or t==400 or t==600, y+8.0, y) // add some spike outliers\r\n| summarize Timestamp=makelist(Timestamp, 10000),y=makelist(y, 10000);\r\nts \r\n| extend series_decompose(y, -1, 'linefit')\r\n| render timechart  \r\n```\r\n![alt text](./Images/samples/series-decompose3.png \"series-decompose3\")", "https://kusto.azurewebsites.net/docs/query/series-decomposefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_divide", "Calculates the element-wise division of two numeric series inputs.", "**Syntax**\r\n\r\n`series_divide(`*series1*`,` *series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *series1, series2*: Input numeric arrays, the first to be element-wise divided by the second into a dynamic array result. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of calculated element-wise divide operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.\r\n\r\nNote: the result series is of double type, even if the inputs are integers. Division by zero follows the double division by zero (e.g. 2/0 yields double(+inf)).", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| project s1 = pack_array(x,y,z), s2 = pack_array(z, y, x)\r\n| extend s1_divide_s2 = series_divide(s1, s2)\r\n```\r\n\r\n|s1\t        |s2|\t    s1_divide_s2|\r\n|---|---|---|\r\n|[1,2,4]\t|[4,2,1]|\t[0.25,1.0,4.0]|\r\n|[2,4,8]\t|[8,4,2]|\t[0.25,1.0,4.0]|\r\n|[3,6,12]\t|[12,6,3]|\t[0.25,1.0,4.0]|", "https://kusto.azurewebsites.net/docs/query/series-dividefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_equals", "Calculates the element-wise equal [ `==` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_equals (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise equal logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_equals_s2 = series_equals(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_equals_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[false,true,false]|", "https://kusto.azurewebsites.net/docs/query/series-equalsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fill_backward", "Performs backward fill interpolation of missing values in a series.", "Takes an expression containing dynamic numerical array as input, replaces all instances of missing_value_placeholder with the nearest value from its right side other than missing_value_placeholder and returns the resulting array. The rightmost instances of missing_value_placeholder are preserved.\r\n\r\n**Syntax**\r\n\r\n`series_fill_backward(`*x*`[, `*missing_value_placeholder*`])`\r\n* Will return series *x* with all instances of *missing_value_placeholder* filled backward.\r\n\r\n**Arguments**\r\n\r\n* *x*: dynamic array scalar expression which is an array of numeric values.\r\n* *missing_value_placeholder*: optional parameter which specifies a placeholder for a missing values to be replaced. Default value is `double`(*null*).\r\n\r\n**Notes**\r\n\r\n* In order to apply any interpolation functions after [make-series](make-seriesoperator.md) it is recommended to specify *null* as a default value: \r\n\r\n\r\n```\r\nmake-series num=count() default=long(null) on TimeStamp in range(ago(1d), ago(1h), 1h) by Os, Browser\r\n```\r\n\r\n* The *missing_value_placeholder* can be of any type which will be converted to actual element types. Therefore either `double`(*null*), `long`(*null*) or `int`(*null*) have the same meaning.\r\n* If *missing_value_placeholder* is `double`(*null*) (or just omitted which have the same meaning) then a result may contains *null* values. Use other interpolation functions in order to fill them. Currently only [series_outliers()](series-outliersfunction.md) support *null* values in input arrays.\r\n* The functions preserves original type of array elements.", "```\r\nlet data = datatable(arr: dynamic)\r\n[\r\n    dynamic([111,null,36,41,null,null,16,61,33,null,null])   \r\n];\r\ndata \r\n| project arr, \r\n          fill_forward = series_fill_backward(arr)\r\n\r\n```\r\n\r\n|arr|fill_forward|\r\n|---|---|\r\n|[111,null,36,41,null,null,16,61,33,null,null]|[111,36,36,41,16, 16,16,61,33,null,null]|\r\n\r\n  \r\nOne can use [series_fill_forward](series-fill-forwardfunction.md) or [series-fill-const](series-fill-constfunction.md) in order to complete interpolation of the above array.", "https://kusto.azurewebsites.net/docs/query/series-fill-backwardfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fill_const", "Replaces missing values in a series with a specified constant value.", "Takes an expression containing dynamic numerical array as input, replaces all instances of missing_value_placeholder with specified constant_value and returns the resulting array.\r\n\r\n**Syntax**\r\n\r\n`series_fill_const(`*x*`[, `*constant_value*`[,` *missing_value_placeholder*`]])`\r\n* Will return series *x* with all instances of *missing_value_placeholder* replaced with *constant_value*.\r\n\r\n**Arguments**\r\n\r\n* *x*: dynamic array scalar expression which is an array of numeric values.\r\n* *constant_value*: parameter which specifies a placeholder for a missing values to be replaced. Default value is *0*. \r\n* *missing_value_placeholder*: optional parameter which specifies a placeholder for a missing values to be replaced. Default value is `double`(*null*).\r\n\r\n**Notes**\r\n* It is possible to create a series with constant fill in one call using `default = ` *DefaultValue* syntax (or just omitting which will assume 0). See [make-series](make-seriesoperator.md) for more information.\r\n\r\n\r\n```\r\nmake-series num=count() default=-1 on TimeStamp in range(ago(1d), ago(1h), 1h) by Os, Browser\r\n```\r\n  \r\n* In order to apply any interpolation functions after [make-series](make-seriesoperator.md) it is recommended to specify *null* as a default value: \r\n\r\n\r\n```\r\nmake-series num=count() default=long(null) on TimeStamp in range(ago(1d), ago(1h), 1h) by Os, Browser\r\n```\r\n  \r\n* The *missing_value_placeholder* can be of any type which will be converted to actual element types. Therefore either `double`(*null*), `long`(*null*) or `int`(*null*) have the same meaning.\r\n* The function preserves original type of the array elements.", "```\r\nlet data = datatable(arr: dynamic)\r\n[\r\n    dynamic([111,null,36,41,23,null,16,61,33,null,null])   \r\n];\r\ndata \r\n| project arr, \r\n          fill_const1 = series_fill_const(arr, 0.0),\r\n          fill_const2 = series_fill_const(arr, -1)  \r\n```\r\n\r\n|arr|fill_const1|fill_const2|\r\n|---|---|---|\r\n|[111,null,36,41,23,null,16,61,33,null,null]|[111,0.0,36,41,23,0.0,16,61,33,0.0,0.0]|[111,-1,36,41,23,-1,16,61,33,-1,-1]|", "https://kusto.azurewebsites.net/docs/query/series-fill-constfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fill_forward", "Performs forward fill interpolation of missing values in a series.", "Takes an expression containing dynamic numerical array as input, replaces all instances of missing_value_placeholder with the nearest value from its left side other than missing_value_placeholder and returns the resulting array. The leftmost instances of missing_value_placeholder are preserved.\r\n\r\n**Syntax**\r\n\r\n`series_fill_forward(`*x*`[, `*missing_value_placeholder*`])`\r\n* Will return series *x* with all instances of *missing_value_placeholder* filled forward.\r\n\r\n**Arguments**\r\n\r\n* *x*: dynamic array scalar expression which is an array of numeric values. \r\n* *missing_value_placeholder*: optional parameter which specifies a placeholder for a missing values to be replaced. Default value is `double`(*null*).\r\n\r\n**Notes**\r\n\r\n* In order to apply any interpolation functions after [make-series](make-seriesoperator.md) it is recommended to specify *null* as a default value: \r\n\r\n\r\n```\r\nmake-series num=count() default=long(null) on TimeStamp in range(ago(1d), ago(1h), 1h) by Os, Browser\r\n```\r\n\r\n* The *missing_value_placeholder* can be of any type which will be converted to actual element types. Therefore either `double`(*null*), `long`(*null*) or `int`(*null*) have the same meaning.\r\n* If *missing_value_placeholder* is `double`(*null*) (or just omitted which have the same meaning) then a result may contains *null* values. Use other interpolation functions in order to fill them. Currently only [series_outliers()](series-outliersfunction.md) support *null* values in input arrays.\r\n* The functions preserves original type of array elements.", "```\r\nlet data = datatable(arr: dynamic)\r\n[\r\n    dynamic([null,null,36,41,null,null,16,61,33,null,null])   \r\n];\r\ndata \r\n| project arr, \r\n          fill_forward = series_fill_forward(arr)  \r\n\r\n```\r\n\r\n|arr|fill_forward|\r\n|---|---|\r\n|[null,null,36,41,null,null,16,61,33,null,null]|[null,null,36,41,41,41,16,61,33,33,33]|\r\n   \r\nOne can use [series_fill_backward](series-fill-backwardfunction.md) or [series-fill-const](series-fill-constfunction.md) in order to complete interpolation of the above array.", "https://kusto.azurewebsites.net/docs/query/series-fill-forwardfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fill_linear", "Performs linear interpolation of missing values in a series.", "Takes an expression containing dynamic numerical array as input, performs linear interpolation for all instances of missing_value_placeholder and returns the resulting array. If the beginning and end of the array contains missing_value_placeholder, then it will be replaced with the nearest value other than missing_value_placeholder (can be turned off). If the whole array consists of the missing_value_placeholder then the array will be filled with constant_value or 0 if no specified.  \r\n\r\n**Syntax**\r\n\r\n`series_fill_linear(`*x*`[,` *missing_value_placeholder*` [,`*fill_edges*` [,`*constant_value*`]]]))`\r\n* Will return series linear interpolation of *x* using specified parameters.\r\n \r\n\r\n**Arguments**\r\n\r\n* *x*: dynamic array scalar expression which is an array of numeric values.\r\n* *missing_value_placeholder*: optional parameter which specifies a placeholder for the \"missing values\" to be replaced. Default value is `double`(*null*).\r\n* *fill_edges*: Boolean value which indicates whether *missing_value_placeholder* at the start and end of the array should be replaced with nearest value. *True* by default. If set to *false* then *missing_value_placeholder* at the start and end of the array will be preserved.\r\n* *constant_value*: optional parameter relevant only for arrays entirely consists of *null* values, which specifies constant value to fill the series with. Default value is *0*. Setting this parameter it to `double`(*null*) will effectively leave *null* values where they are.\r\n\r\n**Notes**\r\n\r\n* In order to apply any interpolation functions after [make-series](make-seriesoperator.md) it is recommended to specify *null* as a default value: \r\n\r\n\r\n```\r\nmake-series num=count() default=long(null) on TimeStamp in range(ago(1d), ago(1h), 1h) by Os, Browser\r\n```\r\n\r\n* The *missing_value_placeholder* can be of any type which will be converted to actual element types. Therefore either `double`(*null*), `long`(*null*) or `int`(*null*) have the same meaning.\r\n* If *missing_value_placeholder* is `double`(*null*) (or just omitted which have the same meaning) then a result may contains *null* values. Use other interpolation functions in order to fill them. Currently only [series_outliers()](series-outliersfunction.md) support *null* values in input arrays.\r\n* The function preserves original type of array elements. If *x* contains only *int* or *long* elements then the linear interpolation will return rounded interpolated values rather than exact ones.", "```\r\nlet data = datatable(arr: dynamic)\r\n[\r\n    dynamic([null, 111.0, null, 36.0, 41.0, null, null, 16.0, 61.0, 33.0, null, null]), // Array of double    \r\n    dynamic([null, 111,   null, 36,   41,   null, null, 16,   61,   33,   null, null]), // Similar array of int\r\n    dynamic([null, null, null, null])                                                   // Array with missing values only\r\n];\r\ndata\r\n| project arr, \r\n          without_args = series_fill_linear(arr),\r\n          with_edges = series_fill_linear(arr, double(null), true),\r\n          wo_edges = series_fill_linear(arr, double(null), false),\r\n          with_const = series_fill_linear(arr, double(null), true, 3.14159)  \r\n\r\n```\r\n\r\n|arr|without_args|with_edges|wo_edges|with_const|\r\n|---|---|---|---|---|\r\n|[null,111.0,null,36.0,41.0,null,null,16.0,61.0,33.0,null,null]|[111.0,111.0,73.5,36.0,41.0,32.667,24.333,16.0,61.0,33.0,33.0,33.0]|[111.0,111.0,73.5,36.0,41.0,32.667,24.333,16.0,61.0,33.0,33.0,33.0]|[null,111.0,73.5,36.0,41.0,32.667,24.333,16.0,61.0,33.0,null,null]|[111.0,111.0,73.5,36.0,41.0,32.667,24.333,16.0,61.0,33.0,33.0,33.0]|\r\n|[null,111,null,36,41,null,null,16,61,33,null,null]|[111,111,73,36,41,32,24,16,61,33,33,33]|[111,111,73,36,41,32,24,16,61,33,33,33]|[null,111,73,36,41,32,24,16,61,33,null,null]|[111,111,74,38,  41,32,24,16,61,33,33,33]|\r\n|[null,null,null,null]|[0.0,0.0,0.0,0.0]|[0.0,0.0,0.0,0.0]|[0.0,0.0,0.0,0.0]|[3.14159,3.14159,3.14159,3.14159]|", "https://kusto.azurewebsites.net/docs/query/series-fill-linearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fir", "Applies a Finite Impulse Response filter on a series.", "Takes an expression containing dynamic numerical array as input and applies a [Finite Impulse Response](https://en.wikipedia.org/wiki/Finite_impulse_response) filter. By specifying the `filter` coefficients, it can be used for calculating moving average, smoothing, change-detection and many more use cases. The function takes as input the column containing the dynamic array and a static dynamic array of the filter's coefficients and applies the filter on the column. It outputs a new dynamic array column, containing the filtered output.  \r\n\r\n**Syntax**\r\n\r\n`series_fir(`*x*`,` *filter* [`,` *normalize*[`,` *center*]]`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values, typically the resulting output of [make-series](make-seriesoperator.md) or [makelist](makelist-aggfunction.md) operators.\r\n* *filter*: A constant expression containing the coefficients of the filter (stored as a dynamic array of numeric values).\r\n* *normalize*: Optional Boolean value indicating whether the filter should be normalized (i.e. divided by the sum of the coefficients). If *filter* contains negative values then *normalize* must be specified as `false`, otherwise result will be `null`. If not specified then a default value of *normalize* will be assumed depending on presence of negative values in the *filter*: if *filter* contains at least one negative value then *normalize* is assumed to be `false`.  \r\nNormalization is a convenient way to make sure that the sum of the coefficients is 1 and thus the filter doesn't amplifies or attenuates the series. For example, moving average of 4 bins could be specified by *filter*=[1,1,1,1] and *normalized*=true, which is easier than typing [0.25,0.25.0.25,0.25].\r\n* *center*: An optional Boolean value indicating whether the filter is applied symmetrically on a time window before and after the current point, or on a time window from the current point backwards. By default, center is false, which fits the scenario of streaming data, where we can only apply the filter on the current and older points; however, for ad-hoc processing you can set it to true, keeping it synchronized with the time series (see examples below). Technically speaking, this parameter controls the filterâs [group delay](https://en.wikipedia.org/wiki/Group_delay_and_phase_delay).", "* Calculating a moving average of 5 points can be performed by setting *filter*=[1,1,1,1,1] and *normalize*=`true` (default). Note the effect of *center*=`false` (default) vs. `true`:\r\n\r\n\r\n```\r\nrange t from bin(now(), 1h)-23h to bin(now(), 1h) step 1h\r\n| summarize t=makelist(t)\r\n| project id='TS', val=dynamic([0,0,0,0,0,0,0,0,0,10,20,40,100,40,20,10,0,0,0,0,0,0,0,0]), t\r\n| extend 5h_MovingAvg=series_fir(val, dynamic([1,1,1,1,1])),\r\n         5h_MovingAvg_centered=series_fir(val, dynamic([1,1,1,1,1]), true, true)\r\n| render timechart\r\n```\r\n\r\nThis query returns:  \r\n*5h_MovingAvg*: 5 points moving average filter. The spike is smoothed and its peak shifted by (5-1)/2 = 2h.  \r\n*5h_MovingAvg_centered*: same but with setting center=true, causes the peak to stay in its original location.\r\n\r\n![alt text](./Images/samples/series-fir.png \"series-fir\")\r\n\r\n* Calculating the difference between a point and its preceding one can be performed by setting *filter*=[1,-1]:\r\n\r\n\r\n```\r\nrange t from bin(now(), 1h)-11h to bin(now(), 1h) step 1h\r\n| summarize t=makelist(t)\r\n| project id='TS',t,value=dynamic([0,0,0,0,2,2,2,2,3,3,3,3])\r\n| extend diff=series_fir(value, dynamic([1,-1]), false, false)\r\n| render timechart\r\n```\r\n\r\n![alt text](./Images/samples/series-fir2.png \"series-fir2\")", "https://kusto.azurewebsites.net/docs/query/series-firfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fit_2lines", "Applies two segments linear regression on a series, returning multiple columns.", "Takes an expression containing dynamic numerical array as input and applies [two segments linear regression](https://en.wikipedia.org/wiki/Segmented_regression) in order to identify and quantify trend change in a series. The function iterates on the series indexes and in each iteration splits the series to 2 parts, fits a separate line (using [series_fit_line()](series-fit-linefunction.md)) to each part and calculate the total r-square. The best split is the one that maximized r-square; the function returns its parameters:\r\n* `rsquare`: [r-square](https://en.wikipedia.org/wiki/Coefficient_of_determination) is a standard measure of the fit quality. It's a number in the range [0-1], where 1 - is the best possible fit, and 0 means the data is totally unordered and do not fit any line\r\n* `split_idx`: the index of breaking point to 2 segments (zero-based)\r\n* `variance`: variance of the input data\r\n* `rvariance`: residual variance which is the variance between the input data values the approximated ones (by the 2 line segments).\r\n* `line_fit`: numerical array holding a series of values of the best fitted line. The series length is equal to the length of the input array. It is mainly used for charting.\r\n* `right_rsquare`: r-square of the line on the right side of the split, see [series_fit_line()](series-fit-linefunction.md)\r\n* `right_slope`: slope of the right approximated line (this is a from y=ax+b)\r\n* `right_interception`: interception of the approximated left line (this is b from y=ax+b)\r\n* `right_variance`: variance of the input data on the right side of the split\r\n* `right_rvariance`: residual variance of the input data on the right side of the split\r\n* `left_rsquare`: r-square of the line on the left side of the split, see [series_fit_line()](series-fit-linefunction.md)\r\n* `left_slope`: slope of the left approximated line (this is a from y=ax+b)\r\n* `left_interception`: interception of the approximated left line (this is b from y=ax+b)\r\n* `left_variance`: variance of the input data on the left side of the split\r\n* `left_rvariance`: residual variance of the input data on the left side of the split\r\n\r\n*Note* that this function returns multiple columns therefore it cannot be used as an argument for another function.\r\n\r\n**Syntax**\r\n\r\nproject `series_fit_2lines(`*x*`)`\r\n* Will return all mentioned above columns with the following names: series_fit_2lines_x_rsquare, series_fit_2lines_x_split_idx and etc.\r\nproject (rs, si, v)=`series_fit_2lines(`*x*`)`\r\n* Will return the following columns: rs (r-square), si (split index), v (variance) and the rest will look like series_fit_2lines_x_rvariance, series_fit_2lines_x_line_fit and etc.\r\nextend (rs, si, v)=`series_fit_2lines(`*x*`)`\r\n* Will return only: rs (r-square), si (split index) and v (variance).\r\n  \r\n**Arguments**\r\n\r\n* *x*: Dynamic array of numeric values.  \r\n\r\n**Important note**\r\n\r\nMost convenient way of using this function is applying it to results of [make-series](make-seriesoperator.md) operator.", "```\r\nprint id=' ', x=range(bin(now(), 1h)-11h, bin(now(), 1h), 1h), y=dynamic([1,2.2, 2.5, 4.7, 5.0, 12, 10.3, 10.3, 9, 8.3, 6.2])\r\n| extend (Slope,Interception,RSquare,Variance,RVariance,LineFit)=series_fit_line(y), (RSquare2, SplitIdx, Variance2,RVariance2,LineFit2)=series_fit_2lines(y)\r\n| project id, x, y, LineFit, LineFit2\r\n| render timechart\r\n```\r\n\r\n![alt text](./Images/samples/series-fit-2lines.png \"series-fit-2lines\")", "https://kusto.azurewebsites.net/docs/query/series-fit-2linesfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fit_2lines_dynamic", "Applies two segments linear regression on a series, returning dynamic object.", "Takes an expression containing dynamic numerical array as input and applies [two segments linear regression](https://en.wikipedia.org/wiki/Segmented_regression) in order to identify and quantify trend change in a series. The function iterates on the series indexes and in each iteration splits the series to 2 parts, fits a separate line (using [series_fit_line()](series-fit-linefunction.md) or [series_fit_line_dynamic()](series-fit-line-dynamicfunction.md)) to each part and calculate the total r-square. The best split is the one that maximized r-square; the function returns its parameters in dynamic value with the following content::\r\n* `rsquare`: [r-square](https://en.wikipedia.org/wiki/Coefficient_of_determination) is a standard measure of the fit quality. It's a number in the range [0-1], where 1 - is the best possible fit, and 0 means the data is totally unordered and do not fit any line\r\n* `split_idx`: the index of breaking point to 2 segments (zero-based)\r\n* `variance`: variance of the input data\r\n* `rvariance`: residual variance which is the variance between the input data values the approximated ones (by the 2 line segments).\r\n* `line_fit`: numerical array holding a series of values of the best fitted line. The series length is equal to the length of the input array. It is mainly used for charting.\r\n* `right.rsquare`: r-square of the line on the right side of the split, see [series_fit_line()](series-fit-linefunction.md) or[series_fit_line_dynamic()](series-fit-line-dynamicfunction.md)\r\n* `right.slope`: slope of the right approximated line (this is a from y=ax+b)\r\n* `right.interception`: interception of the approximated left line (this is b from y=ax+b)\r\n* `right.variance`: variance of the input data on the right side of the split\r\n* `right.rvariance`: residual variance of the input data on the right side of the split\r\n* `left.rsquare`: r-square of the line on the left side of the split, see [series_fit_line()](series-fit-linefunction.md) or [series_fit_line_dynamic()](series-fit-line-dynamicfunction.md)\r\n* `left.slope`: slope of the left approximated line (this is a from y=ax+b)\r\n* `left.interception`: interception of the approximated left line (this is b from y=ax+b)\r\n* `left.variance`: variance of the input data on the left side of the split\r\n* `left.rvariance`: residual variance of the input data on the left side of the split\r\n\r\nThis operator is similar to [series_fit_2lines](series-fit-2linesfunction.md), but unlike `series-fit-2lines` it returns a dynamic bag.\r\n\r\n**Syntax**\r\n\r\n`series_fit_2lines_dynamic(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array of numeric values.  \r\n\r\n**Important note**\r\n\r\nMost convenient way of using this function is applying it to results of [make-series](make-seriesoperator.md) operator.", "```\r\nprint id=' ', x=range(bin(now(), 1h)-11h, bin(now(), 1h), 1h), y=dynamic([1,2.2, 2.5, 4.7, 5.0, 12, 10.3, 10.3, 9, 8.3, 6.2])\r\n| extend LineFit=series_fit_line_dynamic(y).line_fit, LineFit2=series_fit_2lines_dynamic(y).line_fit\r\n| project id, x, y, LineFit, LineFit2\r\n| render timechart\r\n```\r\n\r\n![alt text](./Images/samples/series-fit-2lines.png \"series-fit-2lines\")", "https://kusto.azurewebsites.net/docs/query/series-fit-2lines-dynamicfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fit_line", "Applies linear regression on a series, returning multiple columns.", "Takes an expression containing dynamic numerical array as input and performs [linear regression](https://en.wikipedia.org/wiki/Line_fitting) in order to find the line that best fits it. This function should be used on time series arrays, fitting the output of make-series operator. It generates the following columns:\r\n* `rsquare`: [r-square](https://en.wikipedia.org/wiki/Coefficient_of_determination) is a standard measure of the fit quality. It's a number in the range [0-1], where 1 - is the best possible fit, and 0 means the data is totally unordered and do not fit any line \r\n* `slope`: slope of the approximated line (this is a from y=ax+b)\r\n* `variance`: variance of the input data\r\n* `rvariance`: residual variance which is the variance between the input data values the approximated ones.\r\n* `interception`: interception of the approximated line (this is b from y=ax+b)\r\n* `line_fit`: numerical array holding a series of values of the best fitted line. The series length is equal to the length of the input array. It is mainly used for charting.\r\n\r\n**Syntax**\r\n\r\n`series_fit_line(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array of numeric values.\r\n\r\n**Important note**\r\n\r\nMost convenient way of using this function is applying it to results of [make-series](make-seriesoperator.md) operator.", "```\r\nprint id=' ', x=range(bin(now(), 1h)-11h, bin(now(), 1h), 1h), y=dynamic([2,5,6,8,11,15,17,18,25,26,30,30])\r\n| extend (RSquare,Slope,Variance,RVariance,Interception,LineFit)=series_fit_line(y)\r\n| render timechart\r\n```\r\n\r\n![alt text](./Images/samples/series-fit-line.png \"series-fit-line\")\r\n\r\n| RSquare | Slope | Variance | RVariance | Interception | LineFit                                                                                     |\r\n|---------|-------|----------|-----------|--------------|---------------------------------------------------------------------------------------------|\r\n| 0.982   | 2.730 | 98.628   | 1.686     | -1.666       | 1.064, 3.7945, 6.526, 9.256, 11.987, 14.718, 17.449, 20.180, 22.910, 25.641, 28.371, 31.102 |", "https://kusto.azurewebsites.net/docs/query/series-fit-linefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_fit_line_dynamic", "Applies linear regression on a series, returning dynamic object.", "Takes an expression containing dynamic numerical array as input and performs [linear regression](https://en.wikipedia.org/wiki/Line_fitting) in order to find the line that best fits it. This function should be used on time series arrays, fitting the output of make-series operator. It generates a dynamic value with the following content:\r\n* `rsquare`: [r-square](https://en.wikipedia.org/wiki/Coefficient_of_determination) is a standard measure of the fit quality. It's a number in the range [0-1], where 1 - is the best possible fit, and 0 means the data is totally unordered and do not fit any line \r\n* `slope`: slope of the approximated line (this is a from y=ax+b)\r\n* `variance`: variance of the input data\r\n* `rvariance`: residual variance which is the variance between the input data values the approximated ones.\r\n* `interception`: interception of the approximated line (this is b from y=ax+b)\r\n* `line_fit`: numerical array holding a series of values of the best fitted line. The series length is equal to the length of the input array. It is mainly used for charting.\r\n\r\nThis operator is similar to [series_fit_line](series-fit-linefunction.md), but unlike `series-fit-line` it returns a dynamic bag.\r\n\r\n**Syntax**\r\n\r\n`series_fit_line_dynamic(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array of numeric values.\r\n\r\n**Important note**\r\n\r\nMost convenient way of using this function is applying it to results of [make-series](make-seriesoperator.md) operator.", "```\r\nprint id=' ', x=range(bin(now(), 1h)-11h, bin(now(), 1h), 1h), y=dynamic([2,5,6,8,11,15,17,18,25,26,30,30])\r\n| extend fit=series_fit_line_dynamic(y)\r\n| extend RSquare=fit.rsquare, Slope=fit.slope, Variance=fit.variance,RVariance=fit.rvariance,Interception=fit.interception,LineFit=fit.line_fit\r\n| render timechart\r\n```\r\n\r\n![alt text](./Images/samples/series-fit-line.png \"series-fit-line\")\r\n\r\n| RSquare | Slope | Variance | RVariance | Interception | LineFit                                                                                     |\r\n|---------|-------|----------|-----------|--------------|---------------------------------------------------------------------------------------------|\r\n| 0.982   | 2.730 | 98.628   | 1.686     | -1.666       | 1.064, 3.7945, 6.526, 9.256, 11.987, 14.718, 17.449, 20.180, 22.910, 25.641, 28.371, 31.102 |", "https://kusto.azurewebsites.net/docs/query/series-fit-line-dynamicfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_greater", "Calculates the element-wise greater [ `>` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_greater (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise greater logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_greater_s2 = series_greater(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_greater_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[false,false,true]|", "https://kusto.azurewebsites.net/docs/query/series-greaterfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_greater_equals", "Calculates the element-wise greater or equal [ `>=` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_greater_equals (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise greater or equal logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_greater_equals_s2 = series_greater_equals(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_greater_equals_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[false,true,true]|", "https://kusto.azurewebsites.net/docs/query/series-greater-equalsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_iir", "Applies a Infinite Impulse Response filter on a series.", "Takes an expression containing dynamic numerical array as input and applies an [Infinite Impulse Response](https://en.wikipedia.org/wiki/Infinite_impulse_response) filter. By specifying the filter coefficients, it can be used, for example, to calculate the cumulative sum of the series, to apply smoothing operations, as well as various [high-pass](https://en.wikipedia.org/wiki/High-pass_filter), [band-pass](https://en.wikipedia.org/wiki/Band-pass_filter) and [low-pass](https://en.wikipedia.org/wiki/Low-pass_filter) filters. The function takes as input the column containing the dynamic array and two static dynamic arrays of the filter's *a* and *b* coefficients, and applies the filter on the column. It outputs a new dynamic array column, containing the filtered output.  \r\n \r\n\r\n**Syntax**\r\n\r\n`series_iir(`*x*`,` *b* `,` *a*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values, typically the resulting output of [make-series](make-seriesoperator.md) or [makelist](makelist-aggfunction.md) operators.\r\n* *b*: A constant expression containing the numerator coefficients of the filter (stored as a dynamic array of numeric values).\r\n* *a*: A constant expression, like *b*. Containing the denominator coefficients of the filter.\r\n\r\n**Important note**\r\n\r\n* The first element of *a* (i.e. `a[0]`) mustnât be zero (to avoid division by 0; see the formula below).\r\n\r\n**More about the filterâs recursive formula**\r\n\r\n* Given an input array X and coefficients arrays a, b of lengths n_a and n_b respectively, the transfer function of the filter, generating the output array Y, is defined by (see also in Wikipedia):\r\n\r\n<div align=\"center\">\r\nY<sub>i</sub> = a<sub>0</sub><sup>-1</sup>(b<sub>0</sub>X<sub>i</sub>\r\n + b<sub>1</sub>X<sub>i-1</sub> + ... + b<sub>n<sub>b</sub>-1</sub>X<sub>i-n<sub>b</sub>-1</sub>\r\n - a<sub>1</sub>Y<sub>i-1</sub>-a<sub>2</sub>Y<sub>i-2</sub> - ... - a<sub>n<sub>a</sub>-1</sub>Y<sub>i-n<sub>a</sub>-1</sub>)\r\n</div>", "Calculating cumulative sum can be performed by iir filter with coefficients *a*=[1,-1] and *b*=[1]:  \r\n\r\n\r\n```\r\nlet x = range(1.0, 10, 1);\r\nprint x=x, y = series_iir(x, dynamic([1]), dynamic([1,-1]))\r\n| mvexpand x, y\r\n```\r\n\r\n| x | y |\r\n|:--|:--|\r\n|1.0|1.0|\r\n|2.0|3.0|\r\n|3.0|6.0|\r\n|4.0|10.0|\r\n\r\nHere's how to wrap it in a function:\r\n\r\n\r\n```\r\nlet vector_sum=(x:dynamic)\r\n{\r\n  let y=arraylength(x) - 1;\r\n  toreal(series_iir(x, dynamic([1]), dynamic([1, -1]))[y])\r\n};\r\nprint d=dynamic([0, 1, 2, 3, 4])\r\n| extend dd=vector_sum(d)\r\n```\r\n\r\n|d            |dd  |\r\n|-------------|----|\r\n|`[0,1,2,3,4]`|`10`|", "https://kusto.azurewebsites.net/docs/query/series-iirfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_less", "Calculates the element-wise less [ `<` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_less (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise less logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_less_s2 = series_less(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_less_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[true,false,false]|", "https://kusto.azurewebsites.net/docs/query/series-lessfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_less_equals", "Calculates the element-wise less or equal [ `<=` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_less_equals (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise less or equal logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_less_equals_s2 = series_less_equals(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_less_equals_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[true,true,false]|", "https://kusto.azurewebsites.net/docs/query/series-less-equalsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_multiply", "Calculates the element-wise multiplication of two numeric series inputs.", "**Syntax**\r\n\r\n`series_multiply(`*series1*`,` *series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *series1, series2*: Input numeric arrays, to be element-wise multiplied into a dynamic array result. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of calculated element-wise multiplication operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| project s1 = pack_array(x,y,z), s2 = pack_array(z, y, x)\r\n| extend s1_multiply_s2 = series_multiply(s1, s2)\r\n```\r\n\r\n|s1\t        |s2|\t    s1_multiply_s2|\r\n|---|---|---|\r\n|[1,2,4]\t|[4,2,1]|\t[4,4,4]|\r\n|[2,4,8]\t|[8,4,2]|\t[16,16,16]|\r\n|[3,6,12]\t|[12,6,3]|\t[36,36,36]|", "https://kusto.azurewebsites.net/docs/query/series-multiplyfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_not_equals", "Calculates the element-wise not equal [ `!=` ] logic operation of two numeric series inputs.", "**Syntax**\r\n\r\n`series_not_equals (`*Series1*`,` *Series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *Series1, Series2*: Input numeric arrays to be element-wise compared. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of booleans containing the calculated element-wise not equal logic operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nprint s1 = dynamic([1,2,4]), s2 = dynamic([4,2,1])\r\n| extend s1_not_equals_s2 = series_not_equals(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_not_equals_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[true,false,true]|", "https://kusto.azurewebsites.net/docs/query/series-not-equalsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_outliers", "Scores anomaly points in a series.", "Takes an expression containing dynamic numerical array as input and generates a dynamic numeric array of the same length. Each value of the array indicates a score of possible anomaly using [Tukey's test](https://en.wikipedia.org/wiki/Outlier#Tukey.27s_test). A value greater than 1.5 or less than -1.5 indicates a rise or decline anomaly respectively in the same element of the input.   \r\n\r\n**Syntax**\r\n\r\n`series_outliers(`*x*`, `*kind*`, `*ignore_val*`, `*min_percentile*`, `*max_percentile*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values\r\n* *kind*: Algorithm of outlier detection. Currently supports `\"tukey\"` (traditional Tukey) and  `\"ctukey\"` (custom Tukey). Default is `\"ctukey\"`\r\n* *ignore_val*: numeric value indicating missing values in the series, default is double(null)\r\n* *min_percentile*: for calulation of the normal inter quantile range, default is 10, custom values supported are in range `[2.0, 98.0]` (`ctukey` only) \r\n* *max_percentile*: same, default is 90, custom values supported are in range `[2.0, 98.0]` (ctukey only) \r\n\r\nThe following table describes differences between `\"tukey\"` and `\"ctukey\"`:\r\n\r\n| Algorithm | Default quantile range | Supports custom quantile range |\r\n|-----------|----------------------- |--------------------------------|\r\n| `\"tukey\"` | 25% / 75%              | No                             |\r\n| `\"ctukey\"`| 10% / 90%              | Yes                            |\r\n\r\n\r\n**Important note**\r\n\r\nMost convenient way of using this function is applying it to results of [make-series](make-seriesoperator.md) operator.", "* For the following input `[30,28,5,27,31,38,29,80,25,37,30]` the series_outliers() returns `[0.0,0.0,-3.206896551724138,-0.1724137931034483,0.0,2.6666666666666667,0.0,16.666666666666669,-0.4482758620689655,2.3333333333333337,0.0]`, meaning the `5` is an anomaly on decline and `80` is an anomaly on rise compared to the rest of the series.\r\n\r\n* Suppose you have a time series with some noise that creates outliers and you would like to replace those outliers (noise) with the average value, you could use series_outliers() to detect the outliers then replace them:\r\n\r\n\r\n```\r\nrange x from 1 to 100 step 1 \r\n| extend y=iff(x==20 or x==80, 10*rand()+10+(50-x)/2, 10*rand()+10) // generate a sample series with outliers at x=20 and x=80\r\n| summarize x=makelist(x),series=makelist(y)\r\n| extend series_stats(series), outliers=series_outliers(series)\r\n| mvexpand x to typeof(long), series to typeof(double), outliers to typeof(double)\r\n| project x, series , outliers_removed=iff(outliers > 1.5 or outliers < -1.5, series_stats_series_avg , series ) // replace outliers with the average\r\n| render linechart\r\n``` \r\n\r\n![alt text](./Images/samples/series-outliers.png \"series-outliers\")", "https://kusto.azurewebsites.net/docs/query/series-outliersfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_periods_detect", "Finds the most significant periods that exist in a time series.", "Very often a metric measuring an applicationâs traffic is characterized by two significant periods: a weekly and a daily. Given such a time series, `series_periods_detect()` shall detect these 2 dominant periods.  \r\nThe function takes as input a column containing a dynamic array of time series (typically the resulting output of [make-series](make-seriesoperator.md) operator), two `real` numbers defining the minimal and maximal period size (i.e. number of bins, e.g. for 1h bin the size of a daily period would be 24) to search for, and a `long` number defining the total number of periods for the function to search. The function outputs 2 columns:\r\n* *periods*: a dynamic array containing the periods that have been found (in units of the bin size), ordered by their scores\r\n* *scores*: a dynamic array containing values between 0 and 1, each measures the significance of a period in its respective position in the *periods* array\r\n \r\n\r\n**Syntax**\r\n\r\n`series_periods_detect(`*x*`,` *min_period*`,` *max_period*`,` *num_periods*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array scalar expression which is an array of numeric values, typically the resulting output of [make-series](make-seriesoperator.md) or [makelist](makelist-aggfunction.md) operators.\r\n* *min_period*: A `real` number specifying the minimal period to search for.\r\n* *max_period*: A `real` number specifying the maximal period to search for.\r\n* *num_periods*: A `long` number specifying the maximum required number of periods. This will be the length of the output dynamic arrays.\r\n\r\n**Important notes**\r\n\r\n* The algorithm can detect periods containing at least 4 points and at most half of the series length. \r\n* You should set the *min_period* a little below and *max_period* a little above the periods you expect to find in the time series. For example, if you have an hourly-aggregated signal, and you look for both daily and weekly periods (that would be 24 & 168 respectively) you can set *min_period*=0.8\\*24, *max_period*=1.2\\*168, leaving 20% margins around these periods.\r\n* The input time series must be regular, i.e. aggregated in constant bins (which is always the case if it has been created using [make-series](make-seriesoperator.md)). Otherwise, the output is meaningless.", "The following query embeds a snapshot of a month of an applicationâs traffic, aggregated twice a day (i.e. the bin size is 12 hours).\r\n\r\n\r\n```\r\nprint y=dynamic([80,139,87,110,68,54,50,51,53,133,86,141,97,156,94,149,95,140,77,61,50,54,47,133,72,152,94,148,105,162,101,160,87,63,53,55,54,151,103,189,108,183,113,175,113,178,90,71,62,62,65,165,109,181,115,182,121,178,114,170])\r\n| project x=range(1, arraylength(y), 1), y  \r\n| render linechart \r\n```\r\n\r\n![alt text](./Images/samples/series-periods.png \"series-periods\")\r\n\r\nRunning `series_periods_detect()` on this series results in the weekly period (14 points long):\r\n\r\n\r\n```\r\nprint y=dynamic([80,139,87,110,68,54,50,51,53,133,86,141,97,156,94,149,95,140,77,61,50,54,47,133,72,152,94,148,105,162,101,160,87,63,53,55,54,151,103,189,108,183,113,175,113,178,90,71,62,62,65,165,109,181,115,182,121,178,114,170])\r\n| project x=range(1, arraylength(y), 1), y  \r\n| project series_periods_detect(y, 0.0, 50.0, 2)\r\n```\r\n\r\n| series\\_periods\\_detect\\_y\\_periods  | series\\_periods\\_detect\\_y\\_periods\\_scores |\r\n|-------------|-------------------|\r\n| [14.0, 0.0] | [0.84, 0.0]  |\r\n\r\n\r\nNote that the daily period that can be also seen in the chart was not found since the sampling is too coarse (12h bin size) so a daily period of 2 bins is bellow the minimum period size of 4 points required by the algorithm.", "https://kusto.azurewebsites.net/docs/query/series-periods-detectfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_periods_validate", "Checks whether a time series contains periodic patterns of given lengths.", "Very often a metric measuring the traffic of an application is characterized by a weekly and/or daily periods. This can be confirmed by running `series_periods_validate()` checking for a weekly and daily periods.\r\n\r\nThe function takes as input a column containing a dynamic array of time series (typically the resulting output of [make-series](make-seriesoperator.md) operator), and one or more `real` numbers that define the lengths of the periods to validate. \r\n\r\nThe function outputs 2 columns:\r\n* *periods*: a dynamic array containing the periods to validate (supplied in the input)\r\n* *scores*: a dynamic array containing a score between 0 and 1 that measures the significance of a period in its respective position in the *periods* array\r\n\r\n**Syntax**\r\n\r\n`series_periods_validate(`*x*`,` *period1* [ `,` *period2* `,` . . . ] `)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array scalar expression which is an array of numeric values, typically the resulting output of [make-series](make-seriesoperator.md) or [makelist](makelist-aggfunction.md) operators.\r\n* *period1*, *period2*, etc.: `real` numbers specifying the periods to validate, in units of the bin size. For example, if the series is in 1h bins, a weekly period is 168 bins.\r\n\r\n**Important notes**\r\n\r\n* The minimal value for each of the *period* arguments is **4** and the maximal is half of the length of the input series; for a *period* argument outside these bounds, the output score will be **0**.\r\n* The input time series must be regular, i.e. aggregated in constant bins (which is always the case if it has been created using [make-series](make-seriesoperator.md)). Otherwise, the output is meaningless.\r\n* The function accepts up to 16 periods to validate.", "The following query embeds a snapshot of a month of an applicationâs traffic, aggregated twice a day (i.e. the bin size is 12 hours).\r\n\r\n\r\n```\r\nprint y=dynamic([80,139,87,110,68,54,50,51,53,133,86,141,97,156,94,149,95,140,77,61,50,54,47,133,72,152,94,148,105,162,101,160,87,63,53,55,54,151,103,189,108,183,113,175,113,178,90,71,62,62,65,165,109,181,115,182,121,178,114,170])\r\n| project x=range(1, arraylength(y), 1), y  \r\n| render linechart \r\n```\r\n\r\n![alt text](./Images/samples/series-periods.png \"series-periods\")\r\n\r\nRunning `series_periods_validate()` on this series to validate a weekly period (14 points long) results in a high score,  and with a **0** score  when validating a five days period (10 points long).\r\n\r\n\r\n```\r\nprint y=dynamic([80,139,87,110,68,54,50,51,53,133,86,141,97,156,94,149,95,140,77,61,50,54,47,133,72,152,94,148,105,162,101,160,87,63,53,55,54,151,103,189,108,183,113,175,113,178,90,71,62,62,65,165,109,181,115,182,121,178,114,170])\r\n| project x=range(1, arraylength(y), 1), y  \r\n| project series_periods_validate(y, 14.0, 10.0)\r\n```\r\n\r\n| series\\_periods\\_validate\\_y\\_periods  | series\\_periods\\_validate\\_y\\_scores |\r\n|-------------|-------------------|\r\n| [14.0, 10.0] | [0.84,0.0]  |", "https://kusto.azurewebsites.net/docs/query/series-periods-validatefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_seasonal", "Calculates the seasonal component of a series according to the detected or given seasonal period.", "**Syntax**\r\n\r\n`series_seasonal(`*series* `[,` *period*`])`\r\n\r\n**Arguments**\r\n\r\n* *series*: Input numeric dynamic array\r\n* *period* (optional): Integer number of bins in each seasonal period, possible values:\r\n    *  -1 (default): auto detect the period using [series_periods_detect()](series-periods-detectfunction.md) with a threshold of *0.7*, returns zeroes if seasonality is not detected\r\n    * positive integer: will be used as the period for the seasonal component\r\n    * any other value: ignore seasonality and return a series of zeroes\r\n\r\n**Returns**\r\n\r\nDynamic array of the same length as the *series* input containing the calculated seasonal component of the series. The seasonal component is calculated as the *median* of all the values corresponding to the location of the bin across the periods.\r\n\r\n**See also:**\r\n\r\n* [series_periods_detect()](series-periods-detectfunction.md)\r\n* [series_periods_validate()](series-periods-validatefunction.md)", "**1. Auto detect the period**\r\n\r\nIn the following example the series' period is automatically detected, the first series' period is detected to be 6 bins and the second 5 bins, the third series' period is too short to be detected and returns a series of zeroes (see next example on how to force the period).\r\n\r\n\r\n```\r\nprint s=dynamic([2,5,3,4,3,2,1,2,3,4,3,2,1,2,3,4,3,2,1,2,3,4,3,2,1])\r\n| union (print s=dynamic([8,12,14,12,10,10,12,14,12,10,10,12,14,12,10,10,12,14,12,10]))\r\n| union (print s=dynamic([1,3,5,2,4,6,1,3,5,2,4,6]))\r\n| extend s_seasonal = series_seasonal(s)\r\n```\r\n|s|s_seasonal|\r\n|---|---|\r\n|[2,5,3,4,3,2,1,2,3,4,3,2,1,2,3,4,3,2,1,2,3,4,3,2,1]|[1.0,2.0,3.0,4.0,3.0,2.0,1.0,2.0,3.0,4.0,3.0,2.0,1.0,2.0,3.0,4.0,3.0,2.0,1.0,2.0,3.0,4.0,3.0,2.0,1.0]|\r\n|[8,12,14,12,10,10,12,14,12,10,10,12,14,12,10,10,12,14,12,10]|[10.0,12.0,14.0,12.0,10.0,10.0,12.0,14.0,12.0,10.0,10.0,12.0,14.0,12.0,10.0,10.0,12.0,14.0,12.0,10.0]|\r\n|[1,3,5,2,4,6,1,3,5,2,4,6]|[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]|\r\n\r\n\r\n\r\n**2. Force a period**\r\n\r\nIn the following example the series' period is too short to be detected by [series_periods_detect()](series-periods-detectfunction.md) so we force the period explicitly to get the seasonal pattern.\r\n\r\n\r\n```\r\nprint s=dynamic([1,3,5,1,3,5,2,4,6]) \r\n| union (print s=dynamic([1,3,5,2,4,6,1,3,5,2,4,6]))\r\n| extend s_seasonal = series_seasonal(s,3)\r\n```\r\n|s|s_seasonal|\r\n|---|---|\r\n|[1,3,5,1,3,5,2,4,6]|[1.0,3.0,5.0,1.0,3.0,5.0,1.0,3.0,5.0]|\r\n|[1,3,5,2,4,6,1,3,5,2,4,6]|[1.5,3.5,5.5,1.5,3.5,5.5,1.5,3.5,5.5,1.5,3.5,5.5]|", "https://kusto.azurewebsites.net/docs/query/series-seasonalfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_stats", "Returns statistics for a series in multiple columns.", "The `series_stats()` function takes a column containing dynamic numerical array as input and calculates the following columns:\r\n* `min`: minimum value in the input array\r\n* `min_idx`: minimum value in the input array\r\n* `max`: maximum value in the input array\r\n* `max_idx`: maximum value in the input array\r\n* `avg`: average value of the input array\r\n* `variance`: sample variance of input array\r\n* `stdev`: sample standard deviation of the input array\r\n\r\n*Note* that this function returns multiple columns therefore it cannot be used as an argument for another function.\r\n\r\n**Syntax**\r\n\r\nproject `series_stats(`*x*`)` or extend `series_stats(`*x*`)` \r\n* Will return all mentioned above columns with the following names: series_stats_x_min, series_stats_x_min_idx and etc.\r\n \r\nproject (m, mi)=`series_stats(`*x*`)` or extend (m, mi)=`series_stats(`*x*`)`\r\n* Will return the following columns: m (min) and mi (min_idx).\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values.", "```\r\nprint x=dynamic([23,46,23,87,4,8,3,75,2,56,13,75,32,16,29]) \r\n| project series_stats(x)\r\n\r\n```\r\n\r\n|series_stats_x_min|series_stats_x_min_idx|series_stats_x_max|series_stats_x_max_idx|series_stats_x_avg|series_stats_x_stdev|series_stats_x_variance|\r\n|---|---|---|---|---|---|---|\r\n|2|8|87|3|32.8|28.5036338535483|812.457142857143|", "https://kusto.azurewebsites.net/docs/query/series-statsfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_stats_dynamic", "Returns statistics for a series in dynamic object.", "The `series_stats_dynamic()` function takes a column containing dynamic numerical array as input and generates a dynamic value with the following content:\r\n* `min`: minimum value in the input array\r\n* `min_idx`: minimum value in the input array\r\n* `max`: maximum value in the input array\r\n* `max_idx`: maximum value in the input array\r\n* `avg`: average value of the input array\r\n* `variance`: sample variance of input array\r\n* `stdev`: sample standard deviation of the input array\r\n\r\n**Syntax**\r\n\r\n`series_stats_dynamic(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: Dynamic array cell which is an array of numeric values.", "```\r\nprint x=dynamic([23,46,23,87,4,8,3,75,2,56,13,75,32,16,29]) \r\n| project stats=series_stats_dynamic(x)\r\n\r\n```\r\n\r\n\r\n|stats\r\n|--\r\n|{\"min\": 2.0, \"min_idx\": 8, \"max\": 87.0, \"max_idx\": 3, \"avg\": 32.8, \"stdev\": 28.503633853548269, \"variance\": 812.45714285714291 }", "https://kusto.azurewebsites.net/docs/query/series-stats-dynamicfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "series_subtract", "Calculates the element-wise subtraction of two numeric series inputs.", "**Syntax**\r\n\r\n`series_subtract(`*series1*`,` *series2*`)`\r\n\r\n**Arguments**\r\n\r\n* *series1, series2*: Input numeric arrays, the second to be element-wise subtracted from the first into a dynamic array result. All arguments must be dynamic arrays. \r\n\r\n**Returns**\r\n\r\nDynamic array of calculated element-wise subtract operation between the two inputs. Any non-numeric element or non-existing element (arrays of different sizes) yields a `null` element value.", "```\r\nrange x from 1 to 3 step 1\r\n| extend y = x * 2\r\n| extend z = y * 2\r\n| project s1 = pack_array(x,y,z), s2 = pack_array(z, y, x)\r\n| extend s1_subtract_s2 = series_subtract(s1, s2)\r\n```\r\n\r\n|s1|s2|s1_subtract_s2|\r\n|---|---|---|\r\n|[1,2,4]|[4,2,1]|[-3,0,3]|\r\n|[2,4,8]|[8,4,2]|[-6,0,6]|\r\n|[3,6,12]|[12,6,3]|[-9,0,9]|", "https://kusto.azurewebsites.net/docs/query/series-subtractfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "sign", "Sign of a numeric expression", "**Syntax**\r\n\r\n`sign(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The positive (+1), zero (0), or negative (-1) sign of the specified expression.", "```\r\nprint s1 = sign(-42), s2 = sign(0), s3 = sign(11.2)\r\n\r\n```\r\n\r\n|s1|s2|s3|\r\n|---|---|---|\r\n|-1|0|1|", "https://kusto.azurewebsites.net/docs/query/signfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "sin", "Returns the sine function.", "**Syntax**\r\n\r\n`sin(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The result of `sin(x)`", "", "https://kusto.azurewebsites.net/docs/query/sinfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "sort", "Sort the rows of the input table into order by one or more columns.", "T | sort by strlen(country) asc, price desc\r\n\r\n**Alias**\r\n\r\n`order`\r\n\r\n**Syntax**\r\n\r\n*T* `| sort by` *expression* [`asc` | `desc`] [`nulls first` | `nulls last`] [`,` ...]\r\n\r\n**Arguments**\r\n\r\n* *T*: The table input to sort.\r\n* *expression*: A scalar expression by which to sort. The type of the values must be numeric, date, time or string.\r\n* `asc` Sort by into ascending order, low to high. The default is `desc`, descending high to low.\r\n* `nulls first` (the default for `asc` order) will place the null values at the beginning and `nulls last` (the default for `desc` order) will place the null values at the end.", "```\r\nTraces\r\n| where ActivityId == \"479671d99b7b\"\r\n| sort by Timestamp asc nulls first\r\n```\r\n\r\nAll rows in table Traces that have a specific `ActivityId`, sorted by their timestamp. If `Timestamp` column contains null values, those will appear at the first lines of the result.\r\n\r\nIn order to exclude null values from the result add a filter before the call to sort:\r\n\r\n\r\n```\r\nTraces\r\n| where ActivityId == \"479671d99b7b\" and isnotnull(Timestamp)\r\n| sort by Timestamp asc\r\n```", "https://kusto.azurewebsites.net/docs/query/sortoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "split", "Splits a given string according to a given delimiter and returns a string array with the conatined substrings.", "Optionally, a specific substring can be returned if exists.\r\n\r\n    split(\"aaa_bbb_ccc\", \"_\") == [\"aaa\",\"bbb\",\"ccc\"]\r\n\r\n**Syntax**\r\n\r\n`split(`*source*`,` *delimiter* [`,` *requestedIndex*]`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The source string that will be splitted according to the given delimiter.\r\n* *delimiter*: The delimiter that will be used in order to split the source string.\r\n* *requestedIndex*: An optional zero-based index `int`. If provided, the returned string array will contain the requested substring if exists. \r\n\r\n**Returns**\r\n\r\nA string array that contains the substrings of the given source string that are delimited by the given delimiter.", "```\r\nsplit(\"aa_bb\", \"_\")           // [\"aa\",\"bb\"]\r\nsplit(\"aaa_bbb_ccc\", \"_\", 1)  // [\"bbb\"]\r\nsplit(\"\", \"_\")                // [\"\"]\r\nsplit(\"a__b\")                 // [\"a\",\"\",\"b\"]\r\nsplit(\"aabbcc\", \"bb\")         // [\"aa\",\"cc\"]\r\n```", "https://kusto.azurewebsites.net/docs/query/splitfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "sqrt", "Returns the square root function.", "**Syntax**\r\n\r\n`sqrt(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number >= 0.\r\n\r\n**Returns**\r\n\r\n* A positive number such that `sqrt(x) * sqrt(x) == x`\r\n* `null` if the argument is negative or cannot be converted to a `real` value.", "", "https://kusto.azurewebsites.net/docs/query/sqrtfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "startofday", "Returns the start of the day containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`startofday(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset days from the input date (integer, default - 0). \r\n\r\n**Returns**\r\n\r\nA datetime representing the start of the day for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project dayStart = startofday(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|dayStart|\r\n|---|\r\n|2016-12-31 00:00:00.0000000|\r\n|2017-01-01 00:00:00.0000000|\r\n|2017-01-02 00:00:00.0000000|", "https://kusto.azurewebsites.net/docs/query/startofdayfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "startofmonth", "Returns the start of the month containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`startofmonth(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset months from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the start of the month for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project monthStart = startofmonth(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|monthStart|\r\n|---|\r\n|2016-12-01 00:00:00.0000000|\r\n|2017-01-01 00:00:00.0000000|\r\n|2017-02-01 00:00:00.0000000|", "https://kusto.azurewebsites.net/docs/query/startofmonthfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "startofweek", "Returns the start of the week containing the date, shifted by an offset, if provided.", "Start of the week is considered to be a Sunday.\r\n\r\n**Syntax**\r\n\r\n`startofweek(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset weeks from the input date (integer, default - 0).\r\n\r\n**Returns**\r\n\r\nA datetime representing the start of the week for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project weekStart = startofweek(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|weekStart|\r\n|---|\r\n|2016-12-25 00:00:00.0000000|\r\n|2017-01-01 00:00:00.0000000|\r\n|2017-01-08 00:00:00.0000000|", "https://kusto.azurewebsites.net/docs/query/startofweekfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "startofyear", "Returns the start of the year containing the date, shifted by an offset, if provided.", "**Syntax**\r\n\r\n`startofyear(`*date* [`,`*offset*]`)`\r\n\r\n**Arguments**\r\n\r\n* `date`: The input date.\r\n* `offset`: An optional number of offset years from the input date (integer, default - 0). \r\n\r\n**Returns**\r\n\r\nA datetime representing the start of the year for the given *date* value, with the offset, if specified.", "```\r\n  range offset from -1 to 1 step 1\r\n | project yearStart = startofyear(datetime(2017-01-01 10:10:17), offset) \r\n```\r\n\r\n|yearStart|\r\n|---|\r\n|2016-01-01 00:00:00.0000000|\r\n|2017-01-01 00:00:00.0000000|\r\n|2018-01-01 00:00:00.0000000|", "https://kusto.azurewebsites.net/docs/query/startofyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "stdev", "Calculates the standard deviation of *Expr* across the group, considering the group as a [sample](https://en.wikipedia.org/wiki/Sample_%28statistics%29).", "* Used formula:\r\n![alt text](./images/aggregations/stdev-sample.png \"stdev-sample\")\r\n\r\n* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `stdev(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe standard deviation value of *Expr* across the group.", "```\r\nrange x from 1 to 5 step 1\r\n| summarize makelist(x), stdev(x)\r\n\r\n```\r\n\r\n|list_x|stdev_x|\r\n|---|---|\r\n|[ 1, 2, 3, 4, 5]|1.58113883008419|", "https://kusto.azurewebsites.net/docs/query/stdev-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "stdevif", "Calculates the [stdev](stdev-aggfunction.md) of *Expr* across the group for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `stdevif(`*Expr*`, `*Predicate*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Predicate*:  predicate that if true, the *Expr* calculated value will be added to the standard deviation.\r\n\r\n**Returns**\r\n\r\nThe standard deviation value of *Expr* across the group where *Predicate* evaluates to `true`.", "```\r\nrange x from 1 to 100 step 1\r\n| summarize stdevif(x, x%2 == 0)\r\n\r\n```\r\n\r\n|stdevif_x|\r\n|---|\r\n|29.1547594742265|", "https://kusto.azurewebsites.net/docs/query/stdevif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "stdevp", "Calculates the standard deviation of *Expr* across the group, considering the group as a [population](https://en.wikipedia.org/wiki/Statistical_population).", "* Used formula:\r\n![alt text](./images/aggregations/stdev-population.png \"stdev-population\")\r\n\r\n* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `stdevp(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe standard deviation value of *Expr* across the group.", "```\r\nrange x from 1 to 5 step 1\r\n| summarize makelist(x), stdevp(x)\r\n\r\n```\r\n\r\n|list_x|stdevp_x|\r\n|---|---|\r\n|[ 1, 2, 3, 4, 5]|1.4142135623731|", "https://kusto.azurewebsites.net/docs/query/stdevp-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strcat", "Concatenates between 1 and 64 arguments.", "* In case if arguments are not of string type, they will be forcibly converted to string.\r\n\r\n**Syntax**\r\n\r\n`strcat(`*argument1*,*argument2* [, *argumentN*]`)`\r\n\r\n**Arguments**\r\n\r\n* *argument1* ... *argumentN* : expressions to be concatenated.\r\n\r\n**Returns**\r\n\r\nArguments, concatenated to a single string.", "```\r\nprint str = strcat(\"hello\", \" \", \"world\")\r\n```\r\n\r\n|str|\r\n|---|\r\n|hello world|", "https://kusto.azurewebsites.net/docs/query/strcatfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strcat_array", "Creates a concatenated string of array values using specified delimeter.", "**Syntax**\r\n\r\n`strcat_array(`*array*, *delimiter*`)`\r\n\r\n**Arguments**\r\n\r\n* *array*: A `dynamic` value representing an array of values to be concatenated.\r\n* *delimeter*: A `string` value that will be used to concatenate the values in *array*\r\n\r\n**Returns**\r\n\r\nArray values, concatenated to a single string.", "```\r\nprint str = strcat_array(dynamic([1, 2, 3]), \"->\")\r\n```\r\n\r\n|str|\r\n|---|\r\n|1->2->3|", "https://kusto.azurewebsites.net/docs/query/strcat-arrayfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strcat_delim", "Concatenates between 2 and 64 arguments, with delimiter, provided as first argument.", "* In case if arguments are not of string type, they will be forcibly converted to string.\r\n\r\n**Syntax**\r\n\r\n`strcat_delim(`*delimiter*,*argument1*,*argument2* [, *argumentN*]`)`\r\n\r\n**Arguments**\r\n\r\n* *delimiter*: string expression, which will be used as seperator.\r\n* *argument1* ... *argumentN* : expressions to be concatenated.\r\n\r\n**Returns**\r\n\r\nArguments, concatenated to a single string with *delimiter*.", "```\r\nprint st = strcat_delim('-', 1, '2', 'A', 1s)\r\n\r\n```\r\n\r\n|st|\r\n|---|\r\n|1-2-A-00:00:01|", "https://kusto.azurewebsites.net/docs/query/strcat-delimfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strcmp", "Compares two strings.", "The function starts comparing the first character of each string. If they are equal to each other, it continues with the following pairs until the characters differ or until the end of shorter string is reached.\r\n\r\n**Syntax**\r\n\r\n`strcmp(`*string1*`,` *string2*`)` \r\n\r\n**Arguments**\r\n\r\n* *string1*: first input string for comparison. \r\n* *string2*: second input string for comparison.\r\n\r\n**Returns**\r\n\r\nReturns an integral value indicating the relationship between the strings:\r\n* *<0* - the first character that does not match has a lower value in string1 than in string2\r\n* *0* - the contents of both strings are equal\r\n* *>0* - the first character that does not match has a greater value in string1 than in string2", "```\r\ndatatable(string1:string, string2:string)\r\n[\"ABC\",\"ABC\",\r\n\"abc\",\"ABC\",\r\n\"ABC\",\"abc\",\r\n\"abcde\",\"abc\"]\r\n| extend result = strcmp(string1,string2)\r\n```\r\n\r\n|string1|string2|result|\r\n|---|---|---|\r\n|ABC|ABC|0|\r\n|abc|ABC|1|\r\n|ABC|abc|-1|\r\n|abcde|abc|1|", "https://kusto.azurewebsites.net/docs/query/strcmpfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "string_size", "Returns the size, in bytes, of the input string.", "**Syntax**\r\n\r\n`string_size(`*source*`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The source string that will be measured for string size.\r\n\r\n**Returns**\r\n\r\nReturns the length, in bytes, of the input string.", "```\r\nprint size = string_size(\"hello\")\r\n```\r\n\r\n|size|\r\n|---|\r\n|5|\r\n\r\n\r\n```\r\nprint size = string_size(\"â¦â°â®â¯âª\")\r\n```\r\n\r\n|size|\r\n|---|\r\n|15|", "https://kusto.azurewebsites.net/docs/query/stringsizefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strlen", "Returns the length, in characters, of the input string.", "**Syntax**\r\n\r\n`strlen(`*source*`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The source string that will be measured for string length.\r\n\r\n**Returns**\r\n\r\nReturns the length, in characters, of the input string.\r\n\r\n**Remarks**\r\n\r\nEach Unicode character in the string is equal to `1`, including surrogates.\r\n(e.g: Chinese charachters will be counted once despite the fact that it requires more than one value in UTF-8 encoding).", "```\r\nprint length = strlen(\"hello\")\r\n```\r\n\r\n|length|\r\n|---|\r\n|5|\r\n\r\n\r\n```\r\nprint length = strlen(\"â¦â°â®â¯âª\")\r\n```\r\n\r\n|length|\r\n|---|\r\n|5|", "https://kusto.azurewebsites.net/docs/query/strlenfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "strrep", "Repeates given [string](./scalar-data-types/string.md) provided amount of times.", "* In case if first or third argument is not of a string type, it will be forcibly converted to string.\r\n\r\n**Syntax**\r\n\r\n`strrep(`*value*,*multiplier*,[*delimiter*]`)`\r\n\r\n**Arguments**\r\n\r\n* *value*: input expression\r\n* *multiplier*: positive integer value (from 1 to 1024)\r\n* *delimiter*: an optional string expression (default: empty string)\r\n\r\n**Returns**\r\n\r\nValue repeated for a specified number of times, concatenated with *delimiter*.\r\n\r\nIn case if *multiplier* is more than maximal allowed value (1024), input string will be repeated 1024 times.", "```\r\nprint from_str = strrep('ABC', 2), from_int = strrep(123,3,'.'), from_time = strrep(3s,2,' ')\r\n```\r\n\r\n|from_str|from_int|from_time|\r\n|---|---|---|\r\n|ABCABC|123.123.123|00:00:03 00:00:03|", "https://kusto.azurewebsites.net/docs/query/strrepfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "substring", "Extracts a substring from a source string starting from some index to the end of the string.", "Optionally, the length of the requested substring can be specified.\r\n\r\n    substring(\"abcdefg\", 1, 2) == \"bc\"\r\n\r\n**Syntax**\r\n\r\n`substring(`*source*`,` *startingIndex* [`,` *length*]`)`\r\n\r\n**Arguments**\r\n\r\n* *source*: The source string that the substring will be taken from.\r\n* *startingIndex*: The zero-based starting character position of the requested substring.\r\n* *length*: An optional parameter that can be used to specify the requested number of characters in the substring. \r\n\r\n**Returns**\r\n\r\nA substring from the given string. The substring starts at startingIndex (zero-based) character position and continues to the end of the string or length characters if specified.", "```\r\nsubstring(\"123456\", 1)        // 23456\r\nsubstring(\"123456\", 2, 2)     // 34\r\nsubstring(\"ABCD\", 0, 2)       // AB\r\n```", "https://kusto.azurewebsites.net/docs/query/substringfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "sum", "Calculates the sum of *Expr* across the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `sum(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe sum value of *Expr* across the group.", "", "https://kusto.azurewebsites.net/docs/query/sum-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "sumif", "Returns a sum of *Expr* for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\nSee also - [sum()](sum-aggfunction.md) function, which sums rows without predicate expression.\r\n\r\n**Syntax**\r\n\r\nsummarize `sumif(`*Expr*`,`*Predicate*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Predicate*: predicate that if true, the *Expr* calculated value will be added to the sum. \r\n\r\n**Returns**\r\n\r\nThe sum value of *Expr* for which *Predicate* evaluates to `true`.\r\n\r\n**Tip**\r\n\r\nUse `summarize sumif(expr, filter)` instead of `where filter | summarize sum(expr)`", "", "https://kusto.azurewebsites.net/docs/query/sumif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "summarize", "Produces a table that aggregates the content of the input table.", "T | summarize count(), avg(price) by fruit, supplier\r\n\r\nA table that shows the number and average price of each fruit from each supplier. There's a row in the output for each distinct combination of fruit and supplier. The output columns show the count, average price, fruit and supplier. All other input columns are ignored.\r\n\r\n\r\n    T | summarize count() by price_range=bin(price, 10.0)\r\n\r\nA table that shows how many items have prices in each interval  [0,10.0], [10.0,20.0], and so on. This example has a column for the count and one for the price range. All other input columns are ignored.\r\n\r\n\r\n**Syntax**\r\n\r\n*T* `| summarize`\r\n      [[*Column* `=`] *Aggregation* [`,` ...]]\r\n    [`by`\r\n      [*Column* `=`] *GroupExpression* [`,` ...]]\r\n\r\n**Arguments**\r\n\r\n* *Column:* Optional name for a result column. Defaults to a name derived from the expression.\r\n* *Aggregation:* A call to an [aggregation function](summarizeoperator.md#list-of-aggregation-functions) such as `count()` or `avg()`, with column names as arguments. See the [list of aggregation functions](summarizeoperator.md#list-of-aggregation-functions).\r\n* *GroupExpression:* An expression over the columns, that provides a set of distinct values. Typically it's either a column name that already provides a restricted set of values, or `bin()` with a numeric or time column as argument. \r\n\r\n    If you don't provide a *GroupExpression,* the whole table is summarized in a single output row.\r\n\r\n**Returns**\r\n\r\nThe input rows are arranged into groups having the same values of the `by` expressions. Then the specified aggregation functions are computed over each group, producing a row for each group. The result contains the `by` columns and also at least one column for each computed aggregate. (Some aggregation functions return multiple columns.)\r\n\r\nThe result has as many rows as there are distinct combinations of `by` values. If you want to summarize over ranges of numeric values, use `bin()` to reduce ranges to discrete values.\r\n\r\n**Notes**\r\n\r\nAlthough you can provide arbitrary expressions for both the aggregation and grouping expressions, it's more efficient to use simple column names, or apply `bin()` to a numeric column.\r\n\r\nThe automatic hourly bins for datetime columns is no longer supported. Use explicit binning instead - for example `summarize by bin(timestamp, 1h)`.\r\n\r\n## List of aggregation functions\r\n\r\n|Function|Description|\r\n|--------|-----------|\r\n|[any()](any-aggfunction.md)|Returns random non-empty value for the group|\r\n|[argmax()](argmax-aggfunction.md)|Returns one or more expressions when argument is maximized|\r\n|[argmin()](argmin-aggfunction.md)|Returns one or more expressions when argument is minimized|\r\n|[avg()](avg-aggfunction.md)|Retuns average value across the group|\r\n|[buildschema()](buildschema-aggfunction.md)|Returns the minimal schema that admits all values of the `dynamic` input|\r\n|[count()](count-aggfunction.md)|Returns count of the group|\r\n|[countif()](countif-aggfunction.md)|Returns count with the predicate of the group|\r\n|[dcount()](dcount-aggfunction.md)|Returns approximate distinct count of the group elements|\r\n|[makelist()](makelist-aggfunction.md)|Returns a list of all the values within the group|\r\n|[makeset()](makeset-aggfunction.md)|Returns a set of distinct values within the group|\r\n|[max()](max-aggfunction.md)|Returns the maximum value across the group|\r\n|[min()](min-aggfunction.md)|Returns the minimum value across the group|\r\n|[percentiles()](percentiles-aggfunction.md)|Returns the percentile approximate of the group|\r\n|[stdev()](stdev-aggfunction.md)|Returns the standard deviateion across the group|\r\n|[sum()](sum-aggfunction.md)|Returns the sum of the elements withing the group|\r\n|[variance()](variance-aggfunction.md)|Returns the variance across the group|\r\n\r\n## Aggregates default values\r\n\r\nThe following table summarizes the default values of aggregations\r\n\r\nOperator       |Default value                         \r\n---------------|------------------------------------\r\n `count()`, `countif()`, `dcount()`, `dcountif()`         |   0                            \r\n `makeset()`, `makelist()`          |    empty dynamic array              ([])          \r\n `any()`, `argmax()`. `argmin()`, `avg()`, `buildschema()`, `hll()`, `max()`, `min()`, `percentiles()`, `stdev()`, `sum()`, `sumif()`, `tdigest()`, `variance()`          |   null                           \r\n\r\n In addition, when using these aggregates over entities which includes null values, the null values will be ignored and won't participate in the calculation (See examples below).", "![alt text](./Images/aggregations/01.png \"01\")\r\n\r\n**Example**\r\n\r\nDetermine what unique combinations of\r\n`ActivityType` and `CompletionStatus` there are in a table. Note that\r\nthere are no aggregation functions, just group-by keys. The output will just show the columns for those results:\r\n\r\n```\r\nActivities | summarize by ActivityType, completionStatus\r\n```\r\n\r\n|`ActivityType`|`completionStatus`\r\n|---|---\r\n|`dancing`|`started`\r\n|`singing`|`started`\r\n|`dancing`|`abandoned`\r\n|`singing`|`completed`\r\n\r\n**Example**\r\n\r\nFinds the minimum and maximum timestamp of all records in the Activities table. There is no group-by clause, so there is just one row in the output:\r\n\r\n```\r\nActivities | summarize Min = min(Timestamp), Max = max(Timestamp)\r\n```\r\n\r\n|`Min`|`Max`\r\n|---|---\r\n|`1975-06-09 09:21:45` | `2015-12-24 23:45:00`\r\n\r\n**Example**\r\n\r\nCreate a row for each continent, showing a count of the cities in which activities occur. Because there are few values for \"continent\", no grouping function is needed in the 'by' clause:\r\n\r\n    Activities | summarize cities=dcount(city) by continent\r\n\r\n|`cities`|`continent`\r\n|---:|---\r\n|`4290`|`Asia`|\r\n|`3267`|`Europe`|\r\n|`2673`|`North America`|\r\n\r\n\r\n**Example**\r\n\r\nThe following example calculates a  histogram for each activity\r\ntype. Because `Duration` has many values, we use `bin` to group its values into 10-minute intervals:\r\n\r\n```\r\nActivities | summarize count() by ActivityType, length=bin(Duration, 10m)\r\n```\r\n\r\n|`count_`|`ActivityType`|`length`\r\n|---:|---|---\r\n|`354`| `dancing` | `0:00:00.000`\r\n|`23`|`singing` | `0:00:00.000`\r\n|`2717`|`dancing`|`0:10:00.000`\r\n|`341`|`singing`|`0:10:00.000`\r\n|`725`|`dancing`|`0:20:00.000`\r\n|`2876`|`singing`|`0:20:00.000`\r\n|...\r\n\r\n**Examples for the aggregates default values**\r\n\r\nWhen the input of summarize operator that has at least one group-by key is empty then it's result is empty too.\r\n\r\nWhen the input of summarize operator that doesn't have any group-by key is empty, then the result is the default values of the aggregates used in the summarize:\r\n\r\n\r\n```\r\nrange x from 1 to 10 step 1\r\n| where 1 == 2\r\n| summarize any(x), argmax(x, x), argmin(x, x), avg(x), buildschema(todynamic(tostring(x))), max(x), min(x), percentile(x, 55), hll(x) ,stdev(x), sum(x), sumif(x, x > 0), tdigest(x), variance(x)\r\n\r\n\r\n```\r\n\r\n|any_x|max_x|max_x_x|min_x|min_x_x|avg_x|schema_x|max_x1|min_x1|percentile_x_55|hll_x|stdev_x|sum_x|sumif_x|tdigest_x|variance_x|\r\n|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|\r\n|||||||||||||||||\r\n\r\n\r\n```\r\nrange x from 1 to 10 step 1\r\n| where 1 == 2\r\n| summarize  count(x), countif(x > 0) , dcount(x), dcountif(x, x > 0)\r\n```\r\n\r\n|count_x|countif_|dcount_x|dcountif_x|\r\n|---|---|---|---|\r\n|0|0|0|0|\r\n\r\n\r\n```\r\nrange x from 1 to 10 step 1\r\n| where 1 == 2\r\n| summarize  makeset(x), makelist(x)\r\n```\r\n\r\n|set_x|list_x|\r\n|---|---|\r\n|[]|[]|\r\n\r\nThe aggregate avg sums all the non-nulls and counts only those which participated in the calculation (will not take nulls into account).\r\n\r\n\r\n```\r\nrange x from 1 to 2 step 1\r\n| extend y = iff(x == 1, real(null), real(5))\r\n| summarize sum(y), avg(y)\r\n```\r\n\r\n|sum_y|avg_y|\r\n|---|---|\r\n|5|5|\r\n\r\nThe regular count will count nulls: \r\n\r\n\r\n```\r\nrange x from 1 to 2 step 1\r\n| extend y = iff(x == 1, real(null), real(5))\r\n| summarize count(y)\r\n```\r\n\r\n|count_y|\r\n|---|\r\n|2|\r\n\r\n\r\n```\r\nrange x from 1 to 2 step 1\r\n| extend y = iff(x == 1, real(null), real(5))\r\n| summarize makeset(y), makeset(y)\r\n```\r\n\r\n|set_y|set_y1|\r\n|---|---|\r\n|[5.0]|[5.0]|", "https://kusto.azurewebsites.net/docs/query/summarizeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "table", "References specific table using an query-time evaluated string-expression.", "table('StormEvent')\r\n\r\n**Syntax**\r\n\r\n`table(`*stringConstant* [`,` *query_data_scope* ]`)`\r\n\r\n**Arguments**\r\n\r\n* *stringConstant*: Name of the table that is referenced. Argument has to be _constant_ prior of query execution, i.e. cannot come from sub-query evaluation.\r\n\r\n* *query_data_scope*: An optional parameter that controls the tables's datascope -- whether the query applies to all data or just part of it. Possible values:\r\n    - `\"hotcache\"`: Table scope is data that is covered by [cache policy](../concepts/cachepolicy.md)\r\n    - `\"all\"`: Table scope is all data, hot or cold.\r\n    - `\"default\"`: Table scope is default (cluster default policy)", "### Use table() to access table of the current database. \r\n\r\n\r\n```\r\ntable('StormEvent') | count\r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use table() inside let statements \r\n\r\nThe same query as above can be rewritten to use inline function (let statement) that \r\nreceives a parameter `tableName` - which is passed into the table() function.\r\n\r\n\r\n```\r\nlet foo = (tableName:string)\r\n{\r\n    table(tableName) | count\r\n};\r\nfoo('help')\r\n```\r\n\r\n|Count|\r\n|---|\r\n|59066|\r\n\r\n### Use table() inside Functions \r\n\r\nThe same query as above can be rewritten to be used in a function that \r\nreceives a parameter `tableName` - which is passed into the table() function.\r\n\r\n\r\n```\r\n.create function foo(tableName:string)\r\n{\r\n    table(tableName) | count\r\n};\r\n```\r\n\r\n**Note:** such functions can be used only locally and not in the cross-cluster query.\r\n\r\n### Use table() with non-constant parameter\r\n\r\nA parameter, which is not scalar constant string can't be passed as parameter to `table()` function.\r\n\r\nBelow, given an example of workaround for such case.\r\n\r\n\r\n```\r\nlet T1 = print x=1;\r\nlet T2 = print x=2;\r\nlet _choose = (_selector:string)\r\n{\r\n    union \r\n    (T1 | where _selector == 'T1'),\r\n    (T2 | where _selector == 'T2')\r\n};\r\n_choose('T2')\r\n\r\n```\r\n\r\n|x|\r\n|---|\r\n|2|", "https://kusto.azurewebsites.net/docs/query/tablefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "take", "Return up to the specified number of rows.", " T | take 5\r\n\r\nThere is no guarantee which records are returned, unless\r\nthe source data is sorted.\r\n\r\n**Syntax**\r\n\r\n`take` *NumberOfRows*\r\n`limit` *NumberOfRows*\r\n\r\n(`take` and `limit` are synonyms.)\r\n\r\n**Remarks**\r\n\r\n`take` is a simple, quick, and efficient way to view a small sample of records\r\nwhen browing data interactively, but be aware that it doesn't guarantee any consistency\r\nin its results when executing multiple times, even if the data set hasn't changed.\r\n\r\nEven is the number of rows returned by the query is not explicitly limited\r\nby the query (no `take` operator is used), Kusto limits that number by default.\r\nPlease see [Kusto query limits](../concepts/querylimits.md) for details.\r\n\r\nSee:\r\n[sort operator](sortoperator.md)\r\n[top operator](topoperator.md)\r\n[top-nested operator](topnestedoperator.md)\r\n\r\n## A note on paging through a large resultset (or: the lack of a `skip` operator)\r\n\r\nKusto does not support the complementary `skip` operator. This is intentional, as\r\n`take` and `skip` together are mainly used for thin client paging, and have a major\r\nperformance impact on the service. Application builders that want to support result\r\npaging are advised to query for several pages of data (say, 10,000 records at a time)\r\nand then display a page of data at a time to the user.", "", "https://kusto.azurewebsites.net/docs/query/takeoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tan", "Returns the tangent function.", "**Syntax**\r\n\r\n`tan(`*x*`)`\r\n\r\n**Arguments**\r\n\r\n* *x*: A real number.\r\n\r\n**Returns**\r\n\r\n* The result of `tan(x)`", "", "https://kusto.azurewebsites.net/docs/query/tanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tdigest", "Calculates the Intermediate results of [`percentiles()`](percentiles-aggfunction.md) across the group.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md).\r\n\r\nRead more about the underlying algorithm (T-Digest) and the estimated error [here](percentiles-aggfunction.md#estimation-error-in-percentiles).\r\n\r\n**Syntax**\r\n\r\n`summarize` `tdigest(`*Expr* [`,` *WeightExpr*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *WeightExpr*: Expression that will be used as the weight of values for aggregation calculation.\r\n\r\n\t\r\n**Returns**\r\n\r\nThe Intermediate results of weighted percentiles of *Expr* across the group.\r\n \r\n \r\n**Tips**\r\n\r\n1) You may use the aggregation function [`merge_tdigests()`](merge-tdigests-aggfunction.md) to merge the output of tdigest again across another group.\r\n\r\n2) You may use the function [`percentile_tdigest()`] (percentile-tdigestfunction.md) to calculate the percentile/percentilew of the tdigest results.", "```\r\nStormEvents\r\n| summarize tdigest(DamageProperty) by State\r\n```\r\n\r\n|State|tdigest_DamageProperty|\r\n|---|---|\r\n|ATLANTIC SOUTH|[[5],[0],[193]]|\r\n|FLORIDA|[[5],[250,10,600000,5000,375000,15000000,20000,6000000,0,110000,150000,500,12000,30000,15000,46000000,7000000,6200000,200000,40000,8000,52000000,62000000,1200000,130000,1500000,4000000,7000,250000,875000,3000,100000,10600000,300000,1000000,25000,75000,2000,60000,10000,170000,350000,50000,1000,16000,80000,2500,400000],[9,1,1,22,1,1,9,1,842,1,3,7,2,4,7,1,1,1,2,5,3,3,1,1,1,1,2,2,1,1,9,7,1,1,2,5,2,9,2,27,1,1,7,27,1,1,1,1]]|\r\n|GEORGIA|[[5],[468,209,300000,3000,250000,775000,14000,500000,0,75000,4500000,500,6928,22767,9714,800000,700000,600000,150000,25000,5000,1600000,1250000,2700000,1500000,2250000,400000,4000,175000,325000,2500,73750,750000,1400000,350000,28000000,39000,1500,35000,6455,140000,225000,30000,1000,110000000,21700000,2000,275000,200000,100000,1000000,2600000,370000,2100000,355000,117500,50000,20100,10000],[11,11,4,53,21,1,6,10,1317,8,1,56,8,6,7,1,1,1,14,29,69,1,2,1,1,1,3,14,5,1,3,4,4,1,4,1,5,14,3,5,2,1,9,96,1,1,72,1,10,17,3,1,1,1,1,2,21,4,31]]|\r\n|MISSISSIPPI|[[5],[267,55,90000,3000,75000,300000,11167,160000,0,32000,40000,1000,7000,13000,8000,400000,200000,180000,50000,15000,5000,700000,500000,120000,650000,1000000,150000,4000,60000,100000,2500,30000,250000,600000,110000,12000,20000,1500,17000,6000,45000,70000,15250,1219,10000,25000,2000,80000,65000,35000,450000,1200000,130000,750000],[3,2,6,21,1,4,6,1,741,4,13,44,8,2,8,1,5,1,23,21,32,1,3,1,1,1,5,18,17,4,1,14,2,4,4,16,13,10,4,9,2,10,4,8,31,17,51,13,1,1,1,2,1,1]]|\r\n|AMERICAN SAMOA|[[5],[0,250000],[15,1]]|", "https://kusto.azurewebsites.net/docs/query/tdigest-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tdigest_merge", "Merges tdigest results (scalar version of the aggregate version [`tdigest_merge()`](tdigest-merge-aggfunction.md)).", "Read more about the underlying algorithm (T-Digest) and the estimated error [here](percentiles-aggfunction.md#estimation-error-in-percentiles).\r\n\r\n**Syntax**\r\n\r\n`tdigest_merge(` *Expr1*`,` *Expr2*`, ...)` \r\n\r\n**Arguments**\r\n\r\n* Columns which has the tdigests to be merged.\r\n\r\n**Returns**\r\n\r\nThe result for merging the columns `*Exrp1*`, `*Expr2*`, ... `*ExprN*` to one tdigest.", "```\r\nrange x from 1 to 10 step 1 \r\n| extend y = x + 10\r\n| summarize tdigestX = tdigest(x), tdigestY = tdigest(y)\r\n| project merged = tdigest_merge(tdigestX, tdigestY)\r\n| project percentile_tdigest(merged, 100, typeof(long))\r\n```\r\n\r\n|percentile_tdigest_merged|\r\n|---|\r\n|20|", "https://kusto.azurewebsites.net/docs/query/tdigest-mergefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tobool", "Converts input to boolean (signed 8-bit) representation.", "tobool(\"true\") == true\r\n    tobool(\"false\") == false\r\n    tobool(1) == true\r\n    tobool(123) == true\r\n\r\n**Syntax**\r\n\r\n`tobool(`*Expr*`)`\r\n`toboolean(`*Expr*`)` (alias)\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to boolean. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a boolean.\r\nIf conversion is not successful, result will be `null`.", "", "https://kusto.azurewebsites.net/docs/query/toboolfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "todatetime", "Converts input to [datetime](./scalar-data-types/datetime.md) scalar.", "todatetime(\"2015-12-24\") == datetime(2015-12-24)\r\n\r\n**Syntax**\r\n\r\n`todatetime(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to [datetime](./scalar-data-types/datetime.md). \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a [datetime](./scalar-data-types/datetime.md) value.\r\nIf conversion is not successful, result will be null.\r\n \r\n*Note*: Prefer using [datetime()](./scalar-data-types/datetime.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/todatetimefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "todecimal", "Converts input to decimal number representation.", "todecimal(\"123.45678\") == decimal(123.45678)\r\n\r\n**Syntax**\r\n\r\n`todecimal(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to decimal. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a decimal number.\r\nIf conversion is not successful, result will be `null`.\r\n \r\n*Note*: Prefer using [real()](./scalar-data-types/real.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/todecimalfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "todouble", "Converts the input to a value of type `real`. (`todouble()` and `toreal()` are synonyms.)", "toreal(\"123.4\") == 123.4\r\n\r\n**Syntax**\r\n\r\n`toreal(`*Expr*`)`\r\n`todouble(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: An expression whose value will be converted to a value of type `real`.\r\n\r\n**Returns**\r\n\r\nIf conversion is successful, the result is a value of type `real`.\r\nIf conversion is not successful, the result is the value `real(null)`.\r\n\r\n*Note*: Prefer using [double() or real()](./scalar-data-types/real.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/todoublefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "todynamic", "Interprets a `string` as a [JSON value](https://json.org/) and returns the value as [`dynamic`](./scalar-data-types/dynamic.md).", "It is superior to using [extractjson() function](./extractjsonfunction.md)\r\nwhen you need to extract more than one element of a JSON compound object.\r\n\r\nAliases to [parsejson()](./parsejsonfunction.md) function.\r\n\r\n**Syntax**\r\n\r\n`todynamic(`*json*`)`\r\n`toobject(`*json*`)`\r\n\r\n**Arguments**\r\n\r\n* *json*: A JSON document.\r\n\r\n**Returns**\r\n\r\nAn object of type `dynamic` specified by *json*.\r\n\r\n*Note*: Prefer using [dynamic()](./scalar-data-types/dynamic.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/todynamicfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "toguid", "Converts input to [`guid`](./scalar-data-types/guid.md) representation.", "toguid(\"70fc66f7-8279-44fc-9092-d364d70fce44\") == guid(\"70fc66f7-8279-44fc-9092-d364d70fce44\")\r\n\r\n**Syntax**\r\n\r\n`toguid(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to [`guid`](./scalar-data-types/guid.md) scalar. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a [`guid`](./scalar-data-types/guid.md) scalar.\r\nIf conversion is not successful, result will be `null`.\r\n\r\n*Note*: Prefer using [guid()](./scalar-data-types/guid.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/toguidfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tohex", "Converts input to a hexadecimal string.", "tohex(256) == '100'\r\n    tohex(-256) == 'ffffffffffffff00' // 64-bit 2's complement of -256\r\n    tohex(toint(-256), 8) == 'ffffff00' // 32-bit 2's complement of -256\r\n    tohex(256, 8) == '00000100'\r\n    tohex(256, 2) == '100' // Exceeds min length of 2, so min length is ignored.\r\n\r\n**Syntax**\r\n\r\n`tohex(`*Expr*`, [`,` *MinLength*]`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: int or long value that will be converted to a hex string.  Other types are not supported.\r\n* *MinLength*: numeric value representing the number of leading characters to include in the output.  Values between 1 and 16 are supported, values greater than 16 will be truncated to 16.  If the string is longer than minLength without leading characters, then minLength is effectively ignored.  Negative numbers may only be represented at minimum by their underlying data size, so for an int (32-bit) the minLength will be at minimum 8, for a long (64-bit) it will be at minimum 16.\r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a string value.\r\nIf conversion is not successful, result will be null.", "", "https://kusto.azurewebsites.net/docs/query/tohexfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "toint", "Converts input to integener (signed 32-bit) number representation.", "toint(\"123\") == 123\r\n\r\n**Syntax**\r\n\r\n`toint(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to integer. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a integer number.\r\nIf conversion is not successful, result will be `null`.\r\n \r\n*Note*: Prefer using [int()](./scalar-data-types/int.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/tointfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tolong", "Converts input to long (signed 64-bit) number representation.", "tolong(\"123\") == 123\r\n\r\n**Syntax**\r\n\r\n`tolong(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to long. \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a long number.\r\nIf conversion is not successful, result will be `null`.\r\n \r\n*Note*: Prefer using [long()](./scalar-data-types/long.md) when possible.", "", "https://kusto.azurewebsites.net/docs/query/tolongfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tolower", "Converts input string to lower case.", "tolower(\"Hello\") == \"hello\"", "", "https://kusto.azurewebsites.net/docs/query/tolowerfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "top", "Returns the first *N* records sorted by the specified columns.", "T | top 5 by Name desc nulls last\r\n\r\n**Syntax**\r\n\r\n*T* `| top` *NumberOfRows* `by` *Expression* [`asc` | `desc`] [`nulls first` | `nulls last`]\r\n\r\n**Arguments**\r\n\r\n* *NumberOfRows*: The number of rows of *T* to return. You can specify any numeric expression.\r\n* *Expression*: A scalar expression by which to sort. The type of the values must be numeric, date, time or string.\r\n* `asc` or `desc` (the default) may appear to control whether selection is actually from the \"bottom\" or \"top\" of the range.\r\n* `nulls first` (the default for `asc` order) or `nulls last` (the default for `desc` order) may appear to control whether null values will be at the beginning or the end of the range.\r\n\r\n\r\n**Tips**\r\n\r\n`top 5 by name` is superficially equivalent to `sort by name | take 5`. However, it runs faster and always returns sorted results, whereas `take` makes no such guarantee.\r\n[top-nested](topnestedoperator.md) allows to produce hierarchical top results.", "", "https://kusto.azurewebsites.net/docs/query/topoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "top-hitters", "Returns an approximation of the first *N* results (assuming skewed distribution of the input).", "T | top-hitters 25 of Page by Views \r\n\r\n**Syntax**\r\n\r\n*T* `| top-hitters` *NumberOfRows* `of` *sort_key* `[` `by` *expression* `]`\r\n\r\n**Arguments**\r\n\r\n* *NumberOfRows*: The number of rows of *T* to return. You can specify any numeric expression.\r\n* *sort_key*: The name of the column by which to sort the rows.\r\n* *expression*: (optional) An expression which will be used for the top-hitters estimation. \r\n    * *expression*: top-hitters will return *NumberOfRows* rows which have an approximated maximum of sum(*expression*). Expression can be a column, or any other expression that evaluates to a number. \r\n    *  If *expression* is not mentioned, top-hitters algorithm will count the occurences of the *sort-key*.  \r\n\r\n**Notes**\r\n\r\n`top-hitters` is an approximation algorithm and should be used when running with large data. \r\nThe approximation of the the top-hitters is based on the [Count-Min-Sketch](https://en.wikipedia.org/wiki/Count%E2%80%93min_sketch) algorithm.", "## Getting top hitters (most frequent items) \r\n\r\nThe next example shows how to find top-5  languages with most pages in Wikipedia (accessed after during April 2016). \r\n\r\n\r\n```\r\nPageViews\r\n| where Timestamp > datetime(2016-04-01) and Timestamp < datetime(2016-05-01) \r\n| top-hitters 5 of Language \r\n```\r\n\r\n|Language|approximate_count_Language|\r\n|---|---|\r\n|en|1539954127|\r\n|zh|339827659|\r\n|de|262197491|\r\n|ru|227003107|\r\n|fr|207943448|\r\n\r\n## Getting top hitters (based on column value) ***\r\n\r\nThe next example shows how to find most viewed English pages of Wikipedia of the year 2016. \r\nThe query uses 'Views' (integer number) to calculate page popularity (number of views). \r\n\r\n\r\n```\r\nPageViews\r\n| where Timestamp > datetime(2016-01-01)\r\n| where Language == \"en\"\r\n| where Page !has 'Special'\r\n| top-hitters 10 of Page by Views\r\n```\r\n\r\n|Page|approximate_sum_Views|\r\n|---|---|\r\n|Main_Page|1325856754|\r\n|Web_scraping|43979153|\r\n|Java_(programming_language)|16489491|\r\n|United_States|13928841|\r\n|Wikipedia|13584915|\r\n|Donald_Trump|12376448|\r\n|YouTube|11917252|\r\n|The_Revenant_(2015_film)|10714263|\r\n|Star_Wars:_The_Force_Awakens|9770653|\r\n|Portal:Current_events|9578000|", "https://kusto.azurewebsites.net/docs/query/tophittersoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "top-nested", "Produces hierarchical top results, where each level is a drill-down based on previous level values.", "T | top-nested 3 of Location with others=\"Others\" by sum(MachinesNumber), top-nested 4 of bin(Timestamp,5m) by sum(MachinesNumber)\r\n\r\nIt is useful for dashboard visualization scenarios, or when it is necessary to answer to a question that \r\nsounds like: \"find what are top-N values of K1 (using some aggregation); for each of them, find what are the top-M values of K2 (using another aggregation); ...\"\r\n\r\n**Syntax**\r\n\r\n*T* `|` `top-nested` [*N1*] `of` *Expression1* [`with others=` *ConstExpr1*] `by` [*AggName1* `=`] *Aggregation1* [`asc` | `desc`] [`,`...]\r\n\r\n**Arguments**\r\n\r\nfor each top-nested rule:\r\n* *N1*: The number of top values to return for each hierarchy level. Optional (if omitted, all distinct values will be returned).\r\n* *Expression1*: An expression by which to select the top values. Typically it's either a column name in *T*, or some binning operation (e.g., `bin()`) on such a column. \r\n* *ConstExpr1*: If specified, then for the applicable nesting level, an additional row will be appended that holds the aggregated result for the other values that are not included in the top values.\r\n* *Aggregation1*: A call to an aggregation function which may be one of:\r\n  [sum()](sum-aggfunction.md),\r\n  [count()](count-aggfunction.md),\r\n  [max()](max-aggfunction.md),\r\n  [min()](min-aggfunction.md),\r\n  [dcount()](dcountif-aggfunction.md),\r\n  [avg()](avg-aggfunction.md),\r\n  [percentile()](percentiles-aggfunction.md),\r\n  [percentilew()](percentiles-aggfunction.md),\r\n  or any algebric combination of these aggregations.\r\n* `asc` or `desc` (the default) may appear to control whether selection is actually from the \"bottom\" or \"top\" of the range.\r\n\r\n**Returns**\r\n\r\nHierarchial table which includes input columns and for each one a new column is produced to include result of the Aggregation for the same level for each element.\r\nThe columns are arranged in the same order of the input columns and the new produced column will be close to the aggregated column. \r\nEach record has a hierarchial structure where each value is selected after applying all the previous top-nested rules on all the previous levels and then applying the current level's rule on this output.\r\nThis means that the top n values for level i are calculated for each value in level i - 1.\r\n \r\n**Tips**\r\n\r\n* Use columns renaming in for *Aggregation* results: T | top-nested 3 of Location by MachinesNumberForLocation = sum(MachinesNumber) ... .\r\n\r\n* The number of records returned might be quite large; up to (*N1*+1) * (*N2*+1) * ... * (*Nm*+1) (where m is the number of the levels and *Ni* is the top count for level i).\r\n\r\n* The Aggregation must receive a numeric column with aggregation function which is one of the mentioned above.\r\n\r\n* Use the `with others=` option in order to get the aggregated value of all other values that was not top N values in some level.\r\n\r\n* If you are not interested in getting `with others=` for some level, null values will be appended (for the aggreagated column and the level key, see example below).\r\n\r\n\r\n* It is possible to return additional columns for the selected top-nested candidates by appending additional top-nested statements like these (see examples below):\r\n\r\n\r\n```\r\ntop-nested 2 of ...., ..., ..., top-nested of <additionalRequiredColumn1> by max(1), top-nested of <additionalRequiredColumn2> by max(1)\r\n```", "```\r\nStormEvents\r\n| top-nested 2 of State by sum(BeginLat),\r\n  top-nested 3 of Source by sum(BeginLat),\r\n  top-nested 1 of EndLocation by sum(BeginLat)\r\n```\r\n\r\n|State|aggregated_State|Source|aggregated_Source|EndLocation|aggregated_EndLocation|\r\n|---|---|---|---|---|---|\r\n|KANSAS|87771.2355000001|Law Enforcement|18744.823|FT SCOTT|264.858|\r\n|KANSAS|87771.2355000001|Public|22855.6206|BUCKLIN|488.2457|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|SHARON SPGS|388.7404|\r\n|TEXAS|123400.5101|Public|13650.9079|AMARILLO|246.2598|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|PERRYTON|289.3178|\r\n|TEXAS|123400.5101|Trained Spotter|13997.7124|CLAUDE|421.44|\r\n\r\n\r\n* With others example:\r\n\r\n\r\n```\r\nStormEvents\r\n| top-nested 2 of State with others = \"All Other States\" by sum(BeginLat),\r\n  top-nested 3 of Source by sum(BeginLat),\r\n  top-nested 1 of EndLocation with others = \"All Other End Locations\" by  sum(BeginLat)\r\n\r\n\r\n```\r\n\r\n|State|aggregated_State|Source|aggregated_Source|EndLocation|aggregated_EndLocation|\r\n|---|---|---|---|---|---|\r\n|KANSAS|87771.2355000001|Law Enforcement|18744.823|FT SCOTT|264.858|\r\n|KANSAS|87771.2355000001|Public|22855.6206|BUCKLIN|488.2457|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|SHARON SPGS|388.7404|\r\n|TEXAS|123400.5101|Public|13650.9079|AMARILLO|246.2598|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|PERRYTON|289.3178|\r\n|TEXAS|123400.5101|Trained Spotter|13997.7124|CLAUDE|421.44|\r\n|KANSAS|87771.2355000001|Law Enforcement|18744.823|All Other End Locations|18479.965|\r\n|KANSAS|87771.2355000001|Public|22855.6206|All Other End Locations|22367.3749|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|All Other End Locations|20890.9679|\r\n|TEXAS|123400.5101|Public|13650.9079|All Other End Locations|13404.6481|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|All Other End Locations|36939.2788|\r\n|TEXAS|123400.5101|Trained Spotter|13997.7124|All Other End Locations|13576.2724|\r\n|KANSAS|87771.2355000001|||All Other End Locations|24891.0836|\r\n|TEXAS|123400.5101|||All Other End Locations|58523.2932000001|\r\n|All Other States|1149279.5923|||All Other End Locations|1149279.5923|\r\n\r\n\r\nThe following query shows the same results for the first level used in the example above:\r\n\r\n\r\n```\r\n StormEvents\r\n | where State !in ('TEXAS', 'KANSAS')\r\n | summarize sum(BeginLat)\r\n```\r\n\r\n|sum_BeginLat|\r\n|---|\r\n|1149279.5923|\r\n\r\n\r\nRequesting another column (EventType) to the top-nested result: \r\n\r\n\r\n```\r\nStormEvents\r\n| top-nested 2 of State by sum(BeginLat),    top-nested 2 of Source by sum(BeginLat),    top-nested 1 of EndLocation by sum(BeginLat), top-nested of EventType  by tmp = max(1)\r\n| project-away tmp\r\n\r\n\r\n```\r\n\r\n|State|aggregated_State|Source|aggregated_Source|EndLocation|aggregated_EndLocation|EventType|\r\n|---|---|---|---|---|---|---|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|SHARON SPGS|388.7404|Thunderstorm Wind|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|SHARON SPGS|388.7404|Hail|\r\n|KANSAS|87771.2355000001|Trained Spotter|21279.7083|SHARON SPGS|388.7404|Tornado|\r\n|KANSAS|87771.2355000001|Public|22855.6206|BUCKLIN|488.2457|Hail|\r\n|KANSAS|87771.2355000001|Public|22855.6206|BUCKLIN|488.2457|Thunderstorm Wind|\r\n|KANSAS|87771.2355000001|Public|22855.6206|BUCKLIN|488.2457|Flood|\r\n|TEXAS|123400.5101|Trained Spotter|13997.7124|CLAUDE|421.44|Hail|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|PERRYTON|289.3178|Hail|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|PERRYTON|289.3178|Flood|\r\n|TEXAS|123400.5101|Law Enforcement|37228.5966|PERRYTON|289.3178|Flash Flood|\r\n\r\nIn order to sort the result by the last nested level (in this example by EndLocation) and give an index sort order for each value in this level (per group) :\r\n\r\n\r\n```\r\nStormEvents\r\n| top-nested 2 of State  by sum(BeginLat),    top-nested 2 of Source by sum(BeginLat),    top-nested 4 of EndLocation by  sum(BeginLat)\r\n| order by State , Source, aggregated_EndLocation\r\n| summarize EndLocations = makelist(EndLocation, 10000) , endLocationSums = makelist(aggregated_EndLocation, 10000) by State, Source\r\n| extend indicies = range(0, arraylength(EndLocations) - 1, 1)\r\n| mvexpand EndLocations, endLocationSums, indicies\r\n\r\n\r\n\r\n```\r\n\r\n|State|Source|EndLocations|endLocationSums|indicies|\r\n|---|---|---|---|---|\r\n|TEXAS|Trained Spotter|CLAUDE|421.44|0|\r\n|TEXAS|Trained Spotter|AMARILLO|316.8892|1|\r\n|TEXAS|Trained Spotter|DALHART|252.6186|2|\r\n|TEXAS|Trained Spotter|PERRYTON|216.7826|3|\r\n|TEXAS|Law Enforcement|PERRYTON|289.3178|0|\r\n|TEXAS|Law Enforcement|LEAKEY|267.9825|1|\r\n|TEXAS|Law Enforcement|BRACKETTVILLE|264.3483|2|\r\n|TEXAS|Law Enforcement|GILMER|261.9068|3|\r\n|KANSAS|Trained Spotter|SHARON SPGS|388.7404|0|\r\n|KANSAS|Trained Spotter|ATWOOD|358.6136|1|\r\n|KANSAS|Trained Spotter|LENORA|317.0718|2|\r\n|KANSAS|Trained Spotter|SCOTT CITY|307.84|3|\r\n|KANSAS|Public|BUCKLIN|488.2457|0|\r\n|KANSAS|Public|ASHLAND|446.4218|1|\r\n|KANSAS|Public|PROTECTION|446.11|2|\r\n|KANSAS|Public|MEADE STATE PARK|371.1|3|", "https://kusto.azurewebsites.net/docs/query/topnestedoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "toscalar", "Returns a scalar constant value of the evaluated expression.", "This function is useful for queries that require staged calculations, as for example\r\ncalculating a total count of events and then use it for for filtering groups\r\nthat exceed certain percent of all events. \r\n\r\n**Syntax**\r\n\r\n`toscalar(`*Expression*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expression*: Expression that will be evaluated for scalar conversion  \r\n\r\n**Returns**\r\n\r\nA scalar constant value of the evaluated expression.\r\nIf expression result is a tabular, then the first column and first row will be taken for conversion.\r\n\r\n**Tip**\r\nYou can use [`let` statement](letstatement.md) for readability of the query when using `toscalar()`. \r\n\r\n**Notes**\r\n\r\n`toscalar()` can be calculated a constant number of times during the query execution.\r\nIn other words, `toscalar()` function cannot be applied on row-level of (for-each-row scenario).", "The following query evaluates `Start`, `End` and `Step` as scalar constants - and\r\nuse it for `range` evaluation. \r\n\r\n\r\n```\r\nlet Start = toscalar(print x=1);\r\nlet End = toscalar(range x from 1 to 9 step 1 | count);\r\nlet Step = toscalar(2);\r\nrange z from Start to End step Step | extend start=Start, end=End, step=Step\r\n```\r\n\r\n|z|start|end|step|\r\n|---|---|---|---|\r\n|1|1|9|2|\r\n|3|1|9|2|\r\n|5|1|9|2|\r\n|7|1|9|2|\r\n|9|1|9|2|", "https://kusto.azurewebsites.net/docs/query/toscalarfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "tostring", "Converts input to a string representation.", "tostring(123) == \"123\"\r\n\r\n**Syntax**\r\n\r\n`tostring(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to string. \r\n\r\n**Returns**\r\n\r\nIf *Expr* value is non-null result will be a string representation of *Expr*.\r\nIf *Expr* value is null, result will be empty string.", "", "https://kusto.azurewebsites.net/docs/query/tostringfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "totimespan", "Converts input  to [timespan](./scalar-data-types/timespan.md) scalar.", "totimespan(\"0.00:01:00\") == time(1min)\r\n\r\n**Syntax**\r\n\r\n`totimespan(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be converted to [timespan](./scalar-data-types/timespan.md). \r\n\r\n**Returns**\r\n\r\nIf conversion is successful, result will be a [timespan](./scalar-data-types/timespan.md) value.\r\nIf conversion is not successful, result will be null.", "", "https://kusto.azurewebsites.net/docs/query/totimespanfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "toupper", "Converts a string to upper case.", "toupper(\"hello\") == \"HELLO\"", "", "https://kusto.azurewebsites.net/docs/query/toupperfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "translate", "Replaces a set of characters ('searchList') with another set of characters ('replacementList') in a given a string.\r\nThe function searches for characters in the 'searchList' and replaces them with the corresponding characters in 'replacementList'", "**Syntax**\r\n\r\n`translate(`*searchList*`,` *replacementList*,` *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *searchList*: The list of characters that should be replaced\r\n* *replacementList*: The list of characters that should replace the characters in 'searchList'\r\n* *text*: A string to search\r\n\r\n**Returns**\r\n\r\n*text* after replacing all ocurrences of characters in 'replacementList' with the corresponding characters in 'searchList'", "|||\r\n|---|---\r\n|`translate(\"abc\", \"x\", \"abc\")`| \"xxx\" \r\n|`translate(\"abc\", \"\", \"ab\")`| \"\"\r\n|`translate(\"krasp\", \"otsku\", \"spark\")`| \"kusto\"", "https://kusto.azurewebsites.net/docs/query/translatefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "treepath", "Enumerates all the path expressions that identify leaves in a dynamic object.", "`treepath(`*dynamic object*`)`\r\n\r\n**Returns**\r\n\r\nAn array of path expressions.", "|Expression|Evaluates to|\r\n|---|---|\r\n|`treepath(parsejson('{\"a\":\"b\", \"c\":123}'))` | `[\"['a']\",\"['c']\"]`|\r\n|`treepath(parsejson('{\"prop1\":[1,2,3,4], \"prop2\":\"value2\"}'))`|`[\"['prop1']\",\"['prop1'][0]\",\"['prop2']\"]`|\r\n|`treepath(parsejson('{\"listProperty\":[100,200,300,\"abcde\",{\"x\":\"y\"}]}'))`|`[\"['listProperty']\",\"['listProperty'][0]\",\"['listProperty'][0]['x']\"]`|", "https://kusto.azurewebsites.net/docs/query/treepathfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "trim", "Removes all leading and trailing matches of the specified regular expression.", "**Syntax**\r\n\r\n`trim(`*regex*`,` *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: String or [regular expression](re2.md) to be trimmed from the beginning and/or the end of *text*.  \r\n* *text*: A string.\r\n\r\n**Returns**\r\n\r\n*text* after trimming matches of *regex* found in the beginning and/or the end of *text*.", "Statement bellow trims *substring*  from the start and the end of the *string_to_trim*:\r\n\r\n\r\n```\r\nlet string_to_trim = @\"--https://bing.com--\";\r\nlet substring = \"--\";\r\nprint string_to_trim = string_to_trim, trimmed_string = trim(substring,string_to_trim)\r\n```\r\n\r\n|string_to_trim|trimmed_string|\r\n|---|---|\r\n|--https://bing.com--|https://bing.com|\r\n\r\nNext statement trims all non-word characters from start and end of the string:\r\n\r\n\r\n```\r\nrange x from 1 to 5 step 1\r\n| project str = strcat(\"-  \",\"Te st\",x,@\"// $\")\r\n| extend trimmed_str = trim(@\"[^\\w]+\",str)\r\n```\r\n\r\n|str|trimmed_str|\r\n|---|---|\r\n|-  Te st1// $|Te st1|\r\n|-  Te st2// $|Te st2|\r\n|-  Te st3// $|Te st3|\r\n|-  Te st4// $|Te st4|\r\n|-  Te st5// $|Te st5|", "https://kusto.azurewebsites.net/docs/query/trimfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "trim_end", "Removes trailing match of the specified regular expression.", "**Syntax**\r\n\r\n`trim_end(`*regex*`,` *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: String or [regular expression](re2.md) to be trimmed from the end of *text*.  \r\n* *text*: A string.\r\n\r\n**Returns**\r\n\r\n*text* after trimming matches of *regex* found in the end of *text*.", "Statement bellow trims *substring*  from the end of *string_to_trim*:\r\n\r\n\r\n```\r\nlet string_to_trim = @\"bing.com\";\r\nlet substring = \".com\";\r\nprint string_to_trim = string_to_trim,trimmed_string = trim_end(substring,string_to_trim)\r\n```\r\n\r\n|string_to_trim|trimmed_string|\r\n|--------------|--------------|\r\n|bing.com      |bing          |\r\n\r\nNext statement trims all non-word characters from the end of the string:\r\n\r\n\r\n```\r\nprint str = strcat(\"-  \",\"Te st\",x,@\"// $\")\r\n| extend trimmed_str = trim_end(@\"[^\\w]+\",str)\r\n```\r\n\r\n|str          |trimmed_str|\r\n|-------------|-----------|\r\n|-  Te st1// $|-  Te st1  |\r\n|-  Te st2// $|-  Te st2  |\r\n|-  Te st3// $|-  Te st3  |\r\n|-  Te st4// $|-  Te st4  |\r\n|-  Te st5// $|-  Te st5  |", "https://kusto.azurewebsites.net/docs/query/trimendfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "trim_start", "Removes leading match of the specified regular expression.", "**Syntax**\r\n\r\n`trim_start(`*regex*`,` *text*`)`\r\n\r\n**Arguments**\r\n\r\n* *regex*: String or [regular expression](re2.md) to be trimmed from the beginning of *text*.  \r\n* *text*: A string.\r\n\r\n**Returns**\r\n\r\n*text* after trimming match of *regex* found in the beginning of *text*.", "Statement bellow trims *substring*  from the start of *string_to_trim*:\r\n\r\n\r\n```\r\nlet string_to_trim = @\"https://bing.com\";\r\nlet substring = \"https://\";\r\nprint string_to_trim = string_to_trim,trimmed_string = trim_start(substring,string_to_trim)\r\n```\r\n\r\n|string_to_trim|trimmed_string|\r\n|---|---|\r\n|https://bing.com|bing.com|\r\n\r\nNext statement trims all non-word characters from the beginning of the string:\r\n\r\n\r\n```\r\nrange x from 1 to 5 step 1\r\n| project str = strcat(\"-  \",\"Te st\",x,@\"// $\")\r\n| extend trimmed_str = trim_start(@\"[^\\w]+\",str)\r\n```\r\n\r\n|str|trimmed_str|\r\n|---|---|\r\n|-  Te st1// $|Te st1// $|\r\n|-  Te st2// $|Te st2// $|\r\n|-  Te st3// $|Te st3// $|\r\n|-  Te st4// $|Te st4// $|\r\n|-  Te st5// $|Te st5// $|", "https://kusto.azurewebsites.net/docs/query/trimstartfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "union", "Takes two or more tables and returns the rows of all of them.", "```\r\nTable1 | union Table2, Table3\r\n```\r\n\r\n**Syntax**\r\n\r\n*T* `| union` [`kind=` `inner`|`outer`] [`withsource=`*ColumnName*] [`isfuzzy=` `true`|`false`] *Table* [`,` *Table*]...  \r\n\r\nAlternative form with no piped input:\r\n\r\n`union` [`kind=` `inner`|`outer`] [`withsource=`*ColumnName*] [`isfuzzy=` `true`|`false`] *Table* [`,` *Table*]...  \r\n\r\n**Arguments**\r\n\r\n* `Table`:\r\n    *  The name of a table, such as `Events`; or\r\n    *  A query expression that must be enclosed with parenthesis, such as `(Events | where id==42)` or `(cluster(\"https://help.kusto.windows.net:443\").database(\"Samples\").table(\"*\"))`; or\r\n    *  A set of tables specified with a wildcard. For example, `E*` would form the union of all the tables in the database whose names begin `E`.\r\n* `kind`: \r\n    * `inner` - The result has the subset of columns that are common to all of the input tables.\r\n    * `outer` - The result has all the columns that occur in any of the inputs. Cells that were not defined by an input row are set to `null`.\r\n* `withsource`=*ColumnName*: If specified, the output will include a column\r\ncalled *ColumnName* whose value indicates which source table has contributed each row.\r\nIf the query effectively (after wildcard matching) references tables from more than one database (default database always counts) the value of this column will have a table name qualified with the database.\r\nSimilarly __cluster and database__ qualifications will be present in the value if more than one cluster is referenced. \r\n* `isfuzzy=` `true` | `false`: If `isfuzzy` is set to `true` - allows fuzzy resolution of union legs. `Fuzzy` applies to the set of `union` sources. It means that while analyzing the query and preparing for execution, the set of union sources is reduced to the set of table references that exist and are accessible at the time. If at least one such table was found, any resolution failure will yield a warning in the query status results (one for each missing reference), but will not prevent the query execution; if no resolutions were successful - the query will return an error.\r\nThe default is `isfuzzy=` `false`.\r\n\r\n**Returns**\r\n\r\nA table with as many rows as there are in all the input tables.\r\n\r\n**Notes**\r\n1. `union` scope can include [let statements](./letstatement.md) if those are \r\nattributed with [view keyword](./letstatement.md)\r\n2. `union` scope will not include [functions](../management/functions.md). To include \r\nfunction in the union scope - define a [let statement](./letstatement.md) \r\nwith [view keyword](./letstatement.md)\r\n3. If the `union` input is [tables](../management/tables.md) (as oppose to [tabular expressions](./findoperator.md)), and the `union` is followed by a [where operator](./whereoperator.md), consider replacing both with [find](./cross-cluster-or-database-queries.md) for better performance. Please note the different [output schema](./findoperator.md#output-schema) produced by the `find` operator. \r\n4. `isfuzzy=` `true` applies only to the phase of the `union` sources resolution. Once the set of source tables was determined, possible additional query failures will not be suppressed.", "```\r\nunion K* | where * has \"Kusto\"\r\n```\r\n\r\nRows from all tables in the database whose name starts with `K`, and in which any column includes the word `Kusto`.\r\n\r\n**Example**\r\n\r\n\r\n```\r\nunion withsource=SourceTable kind=outer Query, Command\r\n| where Timestamp > ago(1d)\r\n| summarize dcount(UserId)\r\n```\r\n\r\nThe number of distinct users that have produced\r\neither a `Query` event or a `Command` event over the past day. In the result, the 'SourceTable' column will indicate either \"Query\" or \"Command\".\r\n\r\n\r\n```\r\nQuery\r\n| where Timestamp > ago(1d)\r\n| union withsource=SourceTable kind=outer \r\n   (Command | where Timestamp > ago(1d))\r\n| summarize dcount(UserId)\r\n```\r\n\r\nThis more efficient version produces the same result. It filters each table before creating the union.\r\n\r\n**Example: Using `isfuzzy=true`**\r\n \r\n\r\n```     \r\n// Using union isfuzzy=true to access non-existing view:                   \r\n// Using union isfuzzy=true to access non-existing view:                   \r\nlet View_1 = view () { print x=1 };\r\nlet View_2 = view () { print x=1 };\r\nlet OtherView_1 = view () { print x=1 };\r\nunion isfuzzy=true\r\n(View_1 | where x > 0), \r\n(View_2 | where x > 0),\r\n(View_3 | where x > 0)\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|2|\r\n\r\nObserving Query Status - the following warning returned:\r\n`Failed to resolve entity 'View_3'`\r\n\r\n\r\n```\r\n// Using union isfuzzy=true and wildcard access:\r\nlet View_1 = view () { print x=1 };\r\nlet View_2 = view () { print x=1 };\r\nlet OtherView_1 = view () { print x=1 };\r\nunion isfuzzy=true View*, SomeView*, OtherView*\r\n| count \r\n```\r\n\r\n|Count|\r\n|---|\r\n|3|\r\n\r\nObserving Query Status - the following warning returned:\r\n`Failed to resolve entity 'SomeView*'`", "https://kusto.azurewebsites.net/docs/query/unionoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "url_decode", "The function converts encoded URL into a to regular URL representation.", "Detailed information about URL decoding and encoding can be found [here](https://en.wikipedia.org/wiki/Percent-encoding).\r\n\r\n**Syntax**\r\n\r\n`url_decode(`*encoded url*`)`\r\n\r\n**Arguments**\r\n\r\n* *encoded url*: encoded URL (string).  \r\n\r\n**Returns**\r\n\r\nURL (string) in a regular representation.", "```\r\nlet url = @'https%3a%2f%2fwww.bing.com%2f';\r\nprint original = url, decoded = url_decode(url)\r\n```\r\n\r\n|original|decoded|\r\n|---|---|\r\n|https%3a%2f%2fwww.bing.com%2f|https://www.bing.com/|", "https://kusto.azurewebsites.net/docs/query/urldecodefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "url_encode", "The function converts characters of the input URL into a format that can be transmitted over the Internet.", "Detailed information about URL encoding and decoding can be found [here](https://en.wikipedia.org/wiki/Percent-encoding).\r\n\r\n**Syntax**\r\n\r\n`url_encode(`*url*`)`\r\n\r\n**Arguments**\r\n\r\n* *url*: input URL (string).  \r\n\r\n**Returns**\r\n\r\nURL (string) converted into a format that can be transmitted over the Internet.", "```\r\nlet url = @'https://www.bing.com/';\r\nprint original = url, encoded = url_encode(url)\r\n```\r\n\r\n|original|encoded|\r\n|---|---|\r\n|https://www.bing.com/|https%3a%2f%2fwww.bing.com%2f|", "https://kusto.azurewebsites.net/docs/query/urlencodefunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "variance", "Calculates the variance of *Expr* across the group, considering the group as a [sample](https://en.wikipedia.org/wiki/Sample_%28statistics%29).", "* Used formula:\r\n![alt text](./images/aggregations/variance-sample.png \"variance-sample\")\r\n\r\n* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `variance(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe variance value of *Expr* across the group.", "```\r\nrange x from 1 to 5 step 1\r\n| summarize makelist(x), variance(x) \r\n```\r\n\r\n|list_x|variance_x|\r\n|---|---|\r\n|[ 1, 2, 3, 4, 5]|2.5|", "https://kusto.azurewebsites.net/docs/query/variance-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "varianceif", "Calculates the [variance](variance-aggfunction.md) of *Expr* across the group for which *Predicate* evaluates to `true`.", "* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `varianceif(`*Expr*`, `*Predicate*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n* *Predicate*:  predicate that if true, the *Expr* calculated value will be added to the variance.\r\n\r\n**Returns**\r\n\r\nThe variance value of *Expr* across the group where *Predicate* evaluates to `true`.", "```\r\nrange x from 1 to 100 step 1\r\n| summarize varianceif(x, x%2 == 0)\r\n\r\n```\r\n\r\n|varianceif_x|\r\n|---|\r\n|850|", "https://kusto.azurewebsites.net/docs/query/varianceif-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "variancep", "Calculates the variance of *Expr* across the group, considering the group as a [population](https://en.wikipedia.org/wiki/Statistical_population).", "* Used formula:\r\n![alt text](./images/aggregations/variance-population.png \"variance-population\")\r\n\r\n* Can be used only in context of aggregation inside [summarize](summarizeoperator.md)\r\n\r\n**Syntax**\r\n\r\nsummarize `variancep(`*Expr*`)`\r\n\r\n**Arguments**\r\n\r\n* *Expr*: Expression that will be used for aggregation calculation. \r\n\r\n**Returns**\r\n\r\nThe variance value of *Expr* across the group.", "```\r\nrange x from 1 to 5 step 1\r\n| summarize makelist(x), variancep(x) \r\n```\r\n\r\n|list_x|variance_x|\r\n|---|---|\r\n|[ 1, 2, 3, 4, 5]|2|", "https://kusto.azurewebsites.net/docs/query/variancep-aggfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "weekofyear", "Retunrs the integer number represents the week number.", "Aligned with ISO 8601 standards, where first day of the week is Sunday.\r\n\r\n    weekofyear(datetime(\"2015-12-14\"))\r\n\r\n**Syntax**\r\n\r\n`weekofyear(`*a_date*`)`\r\n\r\n**Arguments**\r\n\r\n* `a_date`: A `datetime`.\r\n\r\n**Returns**\r\n\r\n`week number` - The week number that contains the given date.", "", "https://kusto.azurewebsites.net/docs/query/weekofyearfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "welch_test", "Computes the p_value of the [Welch-test function](https://en.wikipedia.org/wiki/Welch%27s_t-test)", "```\r\n// s1, s2 values are from https://en.wikipedia.org/wiki/Welch%27s_t-test\r\nprint\r\n    s1 = dynamic([27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4]),\r\n    s2 = dynamic([27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4])\r\n| mvexpand s1 to typeof(double), s2 to typeof(double)\r\n| summarize m1=avg(s1), v1=variance(s1), c1=count(), m2=avg(s2), v2=variance(s2), c2=count()\r\n| extend pValue=welch_test(m1,v1,c1,m2,v2,c2)\r\n\r\n// pValue = 0.021\r\n```\r\n\r\n**Syntax**\r\n\r\n`welch_test(`*mean1*`, `*variance1*`, `*count1*`, `*mean2*`, `*variance2*`, `*count2*`)`\r\n\r\n**Arguments**\r\n\r\n* *mean1*: Expression that represents the mean (average) value of the 1st series\r\n* *variance1*:  Expression that represents the variance value of the 1st series\r\n* *count1*:  Expression that represents the count of values in the 1st series\r\n* *mean2*: Expression that represents the mean (average) value of the 2nd series\r\n* *variance2*:  Expression that represents the variance value of the 2nd series\r\n* *count2*:  Expression that represents the count of values in the 2nd series\r\n\r\n**Returns**\r\n\r\nFrom [Wikipedia](https://en.wikipedia.org/wiki/Welch%27s_t-test):\r\n\r\nIn statistics, Welch's t-test, or unequal variances t-test, is a two-sample location test \r\nwhich is used to test the hypothesis that two populations have equal means. Welch's t-test \r\nis an adaptation of Student's t-test, that is, it has been derived with the help of Student's \r\nt-test and is more reliable when the two samples have unequal variances and unequal sample\r\nsizes. These tests are often referred to as \"unpaired\" or \"independent samples\" t-tests, \r\nas they are typically applied when the statistical units underlying the two samples\r\nbeing compared are non-overlapping. Given that Welch's t-test has been less popular than \r\nStudent's t-test and may be less familiar to readers, a more informative name is \"Welch's \r\nunequal variances t-test\" or \"unequal variances t-test\" for brevity.", "", "https://kusto.azurewebsites.net/docs/query/welch-testfunction.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.OperatorToken, "where", "Filters a table to the subset of rows that satisfy a predicate.", " T | where fruit==\"apple\"\r\n\r\n**Alias** `filter`\r\n\r\n**Syntax**\r\n\r\n*T* `| where` *Predicate*\r\n\r\n**Arguments**\r\n\r\n* *T*: The tabular input whose records are to be filtered.\r\n* *Predicate*: A `boolean` [expression](./scalar-data-types/bool.md) over the columns of *T*. It is evaluated for each row in *T*.\r\n\r\n**Returns**\r\n\r\nRows in *T* for which *Predicate* is `true`.\r\n\r\n**Notes**\r\nNull values: all filtering functions return false when compared with null values. \r\nYou can use special null-aware functions to write queries that take null values into account:\r\n[isnull()](./isnullfunction.md),\r\n[isnotnull()](./isnotnullfunction.md),\r\n[isempty()](./isemptyfunction.md),\r\n[isnotempty()](./isnotemptyfunction.md). \r\n\r\n**Tips**\r\n\r\nTo get the fastest performance:\r\n\r\n* **Use simple comparisons** between column names and constants. ('Constant' means constant over the table - so `now()` and `ago()` are OK, and so are scalar values assigned using a [`let` statement](./letstatement.md).)\r\n\r\n    For example, prefer `where Timestamp >= ago(1d)` to `where floor(Timestamp, 1d) == ago(1d)`.\r\n\r\n* **Simplest terms first**: If you have multiple clauses conjoined with `and`, put first the clauses that involve just one column. So `Timestamp > ago(1d) and OpId == EventId` is better than the other way around.\r\n\r\n[See here](./datatypes-string-operators.md) for a summary of available string operators.\r\n\r\n[See here](./numoperators.md) for a summary of available numeric operators.", "```\r\nTraces\r\n| where Timestamp > ago(1h)\r\n    and Source == \"Kuskus\"\r\n    and ActivityId == SubActivityId \r\n```\r\n\r\nRecords that are no older than 1 hour,\r\nand come from the Source called \"Kuskus\", and have two columns of the same value. \r\n\r\nNotice that we put the comparison between two columns last, as it can't utilize the index and forces a scan.\r\n\r\n**Example**\r\n\r\n\r\n```\r\nTraces | where * has \"Kusto\"\r\n```\r\n\r\nAll the rows in which the word \"Kusto\" appears in any column.", "https://kusto.azurewebsites.net/docs/query/whereoperator.html"));
                this.AddTopic(new Kusto.Data.IntelliSense.CslTopicDocumentation(Kusto.Data.IntelliSense.CslCommandToken.Kind.FunctionNameToken, "zip", "The `zip` function accepts any number of `dynamic` arrays, and returns an\r\narray whose elements are each an array holding the elements of the input\r\narrays of the same index.", "**Syntax**\r\n\r\n`zip(`*array1*`,` *array2*`, ... )`\r\n\r\n**Arguments**\r\n\r\nBetween 2 and 16 dynamic arrays.", "The following example returns `[[1,2],[3,4],[5,6]]`:\r\n\r\n\r\n```\r\nprint zip(dynamic([1,3,5]), dynamic([2,4,6]))\r\n```\r\n\r\nThe following example returns `[[\"A\",{}], [1,\"B\"], [1.5, null]]`:\r\n\r\n\r\n```\r\nprint zip(dynamic([\"A\", 1, 1.5]), dynamic([{}, \"B\"]))\r\n```\r\n\r\nThe following example returns `[[1,\"one\"],[2,\"two\"],[3,\"three\"]]`:\r\n\r\n\r\n```\r\ndatatable(a:int, b:string) [1,\"one\",2,\"two\",3,\"three\"]\r\n| summarize a = makelist(a), b = makelist(b)\r\n| project zip(a, b)\r\n```", "https://kusto.azurewebsites.net/docs/query/zipfunction.html"));
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslDocumentation", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslDocumentation, {
        f1: function (kvp) {
            return kvp.value;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult", {
        $kind: "nested enum",
        statics: {
            fields: {
                None: 0,
                AppendEntities: 1,
                ReplaceEntities: 2
            }
        }
    });

    /** @namespace Kusto.Data.IntelliSense */

    /**
     * Holds the documentation of a single csl token.
     *
     * @public
     * @class Kusto.Data.IntelliSense.CslTopicDocumentation
     */
    Bridge.define("Kusto.Data.IntelliSense.CslTopicDocumentation", {
        props: {
            TokenKind: 0,
            Name: null,
            ShortDescription: null,
            LongDescription: null,
            Examples: null,
            Url: null
        },
        ctors: {
            ctor: function (tokenKind, name, shortDescription, longDescription, examples, url) {
                if (url === void 0) { url = null; }

                this.$initialize();
                this.TokenKind = tokenKind;
                this.Name = name;
                this.ShortDescription = shortDescription;
                this.LongDescription = longDescription;
                this.Examples = examples;
                this.Url = url;
            }
        },
        methods: {
            GetMarkDownText: function () {
                var $t;
                var sb = new System.Text.StringBuilder();
                sb.appendFormat(System.String.format("## [{0}]({1})", this.Name, this.Url));
                sb.appendLine();
                sb.appendLine();

                $t = Bridge.getEnumerator(System.Array.init([this.ShortDescription, this.LongDescription, this.Examples], System.String));
                try {
                    while ($t.moveNext()) {
                        var part = $t.Current;
                        if (!System.String.isNullOrEmpty(part)) {
                            sb.appendLine(part);
                            sb.appendLine();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return sb.toString();
            },
            equals: function (obj) {
                if (obj == null) {
                    return false;
                }

                var other = Bridge.as(obj, Kusto.Data.IntelliSense.CslTopicDocumentation);
                if (other == null) {
                    return false;
                }

                return this.TokenKind === other.TokenKind && Bridge.referenceEquals(this.Name, other.Name) && Bridge.referenceEquals(this.ShortDescription, other.ShortDescription) && Bridge.referenceEquals(this.Examples, other.Examples);
            },
            getHashCode: function () {
                var $t, $t1, $t2, $t3;
                return Bridge.getHashCode(this.TokenKind) ^ Bridge.getHashCode(this.Name) ^ (($t = (($t1 = this.ShortDescription) != null ? Bridge.getHashCode($t1) : null), $t != null ? $t : 0)) ^ (($t2 = (($t3 = this.Examples) != null ? Bridge.getHashCode($t3) : null), $t2 != null ? $t2 : 0));
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.DMRuleKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Start: 0,
                YieldAdminCommandsOptions: 0,
                YieldShowCommandOptions: 1,
                YieldShowClustersKeywordOptions: 2,
                YieldShowClustersSettingsKeywordOptions: 3,
                YieldShowClustersSettingsVersionKeywordOptions: 4,
                YieldShowPrincipalRolesCommandOptions: 5,
                YieldAlterCommandOptions: 6,
                YieldAlterMergeCommandOptions: 7,
                YieldAlterClustersSettingsKeywordOptions: 8,
                YieldCreateCommandOptions: 9,
                YieldDropCommandOptions: 10,
                YieldAddCommandOptions: 11,
                YieldAddOrAlterCommandOptions: 12,
                YieldAddDataObtainerKeyworkOptions: 13,
                YieldAddDataObtainerInitializeKeyworkOptions: 14,
                YieldAddDataObtainerInitializeWithKeyworkOptions: 15,
                YieldGetCommandOptions: 16,
                YieldGetIngestionQueuesCommandOptions: 17,
                YieldGetIngestionQueuesTypeCommandOptions: 18,
                YieldFlushCommandOptions: 19,
                YieldInitializeCommandOptions: 20,
                YieldInitializeClusterConfigCommandOptions: 21,
                YieldInitializeClusterConfigEncryptionCommandOptions: 22,
                YieldResetCommandOptions: 23,
                YieldSetCommandOptions: 24,
                YieldAlterClustersSettingsFromKeywordOptions: 25,
                YieldAlterObtainerQueuesOptions: 26,
                YieldAddOrAlterEventHubIngestionSourceSettingsOptions: 27
            },
            ctors: {
                init: function () {
                    this.None = Kusto.Data.IntelliSense.RuleKind.None;
                    this.Start = Kusto.Data.IntelliSense.RuleKind.Last;
                }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.EntityDataType", {
        $kind: "enum",
        statics: {
            fields: {
                Empty: 0,
                Object: 1,
                DBNull: 2,
                Boolean: 3,
                Char: 4,
                SByte: 5,
                Byte: 6,
                Int16: 7,
                UInt16: 8,
                Int32: 9,
                UInt32: 10,
                Int64: 11,
                UInt64: 12,
                Single: 13,
                Double: 14,
                Decimal: 15,
                DateTime: 16,
                String: 18,
                Dynamic: 19,
                TimeSpan: 20
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.EntityDataTypeConverter", {
        statics: {
            methods: {
                FromType: function (typeName) {
                    var typeCode = { v : Kusto.Data.IntelliSense.EntityDataType.String };
                    // Attempt to parse the type
                    if (!System.Enum.tryParse(Bridge.global.Kusto.Data.IntelliSense.EntityDataType, typeName, typeCode)) {
                        if (Bridge.referenceEquals(typeName, "Guid")) {
                            typeCode.v = Kusto.Data.IntelliSense.EntityDataType.String;
                        }
                    }

                    return typeCode.v;
                }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ExpressionEntity", {
        fields: {
            Operator: null,
            Name: null,
            Arguments: null,
            IsGenerated: false
        },
        ctors: {
            init: function () {
                this.IsGenerated = false;
            }
        },
        methods: {
            FirstArgument: function () {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, this.Arguments)) {
                    return System.Linq.Enumerable.from(this.Arguments).first();
                }

                return "";
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ExpressionEntityParser", {
        statics: {
            methods: {
                /**
                 * Parses string list 
                 count(), any(SubscriptionId), LogicalServerName, AppName, database_id, bin(TIMESTAMP, time(10m)) 
                 into list of Entity objects
                 *
                 * @static
                 * @public
                 * @this Kusto.Data.IntelliSense.ExpressionEntityParser
                 * @memberof Kusto.Data.IntelliSense.ExpressionEntityParser
                 * @param   {string}                               input
                 * @return  {System.Collections.Generic.List$1}
                 */
                ParseEntities: function (input) {
                    return Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntitiesList(Bridge.global.Kusto.Data.IntelliSense.ExpressionEntity, input, Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntityExpression);
                },
                /**
                 * Parses string list 
                 count(), any(SubscriptionId), LogicalServerName, AppName, database_id, bin(TIMESTAMP, time(10m)), (a,b,c)=foo()
                 into list of Entity objects. Allows to generate implicit names for functions with multicolumn output
                 *
                 * @static
                 * @public
                 * @this Kusto.Data.IntelliSense.ExpressionEntityParser
                 * @memberof Kusto.Data.IntelliSense.ExpressionEntityParser
                 * @param   {string}                               input                       Input
                 * @param   {System.Func}                          generateImplicitEntities    Action which generates multicolumn results for columns that were not specified explicitly:
                 bool generateImplicitEntities(functionName, arguments, explicitColumnCount, listOfResultsToAddTo)
                 returns true if implicit entities were added
                 * @return  {System.Collections.Generic.List$1}
                 */
                ParseEntities$1: function (input, generateImplicitEntities) {
                    return Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntitiesList(Bridge.global.Kusto.Data.IntelliSense.ExpressionEntity, input, Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntityExpression, generateImplicitEntities);
                },
                ParseEntitiesList: function (T, entities, parse, generateImplicitEntities) {
                    if (generateImplicitEntities === void 0) { generateImplicitEntities = null; }
                    var result = new (System.Collections.Generic.List$1(T)).ctor();

                    if (System.String.isNullOrWhiteSpace(entities)) {
                        return result;
                    }

                    var state = 0;
                    var chars = System.String.toCharArray(entities, 0, entities.length);
                    var startToken = 0;
                    var multipleColumnsResultsCount = { v : 0 }; // Used for parsing of (a,b,c)=foo(x)
                    var startFunctionName = -1;
                    for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];

                        // state == 0: looking for start of the token
                        if (state === 0) {
                            startToken = i;
                            // Looking for start of the token
                            if (ch === 61) {
                                state = 2;
                                startFunctionName = (i + 1) | 0;
                            } else if ((System.Char.isDigit(ch) || System.Char.isLetter(ch)) || ch === 42) {
                                multipleColumnsResultsCount.v = 0;
                                state = 1;
                                startFunctionName = i;
                            } else if (ch === 91) {
                                i = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 93, ((i + 1) | 0));
                                multipleColumnsResultsCount.v = result.Count;
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, i, parse);
                                multipleColumnsResultsCount.v = (result.Count - multipleColumnsResultsCount.v) | 0;
                            } else if (ch === 40) {
                                i = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 41, ((i + 1) | 0));
                                multipleColumnsResultsCount.v = result.Count;
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, i, parse);
                                multipleColumnsResultsCount.v = (result.Count - multipleColumnsResultsCount.v) | 0;
                            } else if (ch === 41) {
                                // Closing bracket in this state is interpreted as a termination of the string
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, i, parse);
                                break; // end of "for" loop
                            }

                            if (i === ((chars.length - 1) | 0)) {
                                // We've just parsed the very beginning of the token at the end of the string
                                // Let's step back and give it a chance to be parsed
                                i = (i - 1) | 0;

                                if (state === 0) {
                                    // don't loop on it indefinitely and force to end the token
                                    // it may happen on syntactically wrong strings (e.g. with ',' in the end)
                                    state = 1;
                                }
                            }
                        } else if (state === 1) {
                            multipleColumnsResultsCount.v = 0;
                            if (ch === 61) {
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, ((i - 1) | 0), parse);
                                state = 2;
                            } else if (ch === 44) {
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, ((i - 1) | 0), parse);
                                state = 0;
                            } else if (ch === 40) {
                                var closingBracket = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 41, ((i + 1) | 0));
                                if (Kusto.Data.IntelliSense.ExpressionEntityParser.GenerateMultipleColumnOutput(T, entities, i, startFunctionName, closingBracket, multipleColumnsResultsCount, result, parse, generateImplicitEntities)) {
                                    // change of plans, this was a multicolumn result function call, reseting the parsing
                                    i = (closingBracket + 1) | 0;
                                    state = 0;
                                    continue;
                                }

                                i = closingBracket;
                            }

                            if (i === ((chars.length - 1) | 0)) {
                                Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, result, startToken, i, parse);
                            }
                        } else if (state === 2) {
                            if (ch === 44) {
                                multipleColumnsResultsCount.v = 0;
                                state = 0;
                            } else if (ch === 40) {
                                var closingBracket1 = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 41, ((i + 1) | 0));
                                Kusto.Data.IntelliSense.ExpressionEntityParser.GenerateMultipleColumnOutput(T, entities, i, startFunctionName, closingBracket1, multipleColumnsResultsCount, result, parse, generateImplicitEntities);
                                i = closingBracket1;
                            } else if (ch === 41) {
                                break; // Closing bracket in this state is interpreted as a termination of the string
                            }
                        }
                    }

                    return result;
                },
                GenerateMultipleColumnOutput: function (T, entities, currentChar, startFunctionName, closingBracket, multipleColumnsResultsCount, result, parse, generateImplicitEntities) {
                    var added = false;
                    if (!Bridge.staticEquals(generateImplicitEntities, null) && startFunctionName !== -1) {
                        var args = new (System.Collections.Generic.List$1(T)).ctor();
                        Kusto.Data.IntelliSense.ExpressionEntityParser.AddEntity(T, entities, args, currentChar, closingBracket, parse);

                        var funcName = entities.substr(startFunctionName, ((currentChar - startFunctionName) | 0)).trim();
                        added = generateImplicitEntities(funcName, args, multipleColumnsResultsCount.v, result);
                        multipleColumnsResultsCount.v = 0;
                        startFunctionName = -1;
                    }

                    return added;
                },
                AddEntity: function (T, entities, result, startIndex, endIndex, parse) {
                    var tokenLen = (((endIndex - startIndex) | 0) + 1) | 0;
                    if (tokenLen <= 0) {
                        return;
                    }

                    var token;
                    if (((startIndex + tokenLen) | 0) >= entities.length) {
                        token = entities.substr(startIndex);
                    } else {
                        token = entities.substr(startIndex, tokenLen);
                    }

                    token = Kusto.Data.IntelliSense.ExpressionEntityParser.UnescapeEntityName(token);
                    var entity = parse(token);
                    result.AddRange(entity);
                },
                UnescapeEntityName: function (token) {
                    token = token.trim();
                    token = Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalancedSquareBrackets(token);
                    token = Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalancedSingleAndDoubleQuotes(token);
                    return token;
                },
                NormalizeEntityName: function (entityName) {
                    if (System.String.isNullOrEmpty(entityName)) {
                        return "";
                    }

                    if (!System.Linq.Enumerable.from(entityName).contains(46) && !System.Linq.Enumerable.from(entityName).contains(91)) {
                        return entityName;
                    }

                    var sb = new System.Text.StringBuilder();

                    var chars = System.String.toCharArray(entityName, 0, entityName.length);
                    var state = 0;
                    for (var i = 0; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];
                        switch (state) {
                            case 0: 
                                if (ch === 46) {
                                    sb.append("_");
                                    state = 1; // Move to the state where we're expecting either '[' or beginning of the path expression
                                } else if (ch === 91) {
                                    sb.append("_");
                                    state = 2; // We expect beginning of the sub-expression
                                } else {
                                    sb.append(String.fromCharCode(ch));
                                }
                                break;
                            case 1: 
                                if (ch !== 91) {
                                    sb.append(String.fromCharCode(ch));
                                }
                                state = 2;
                                break;
                            case 2: 
                                if (ch === 39 || ch === 34) {
                                    var start = (i + 1) | 0;
                                    var end = Kusto.Data.IntelliSense.ExpressionEntityParser.ConsumeTill(chars, start, ch);
                                    var entity_part = entityName.substr(start, ((end - start) | 0));
                                    entity_part = System.String.replaceAll(entity_part, String.fromCharCode(32), String.fromCharCode(95));
                                    sb.append(entity_part);
                                    i = end;
                                } else if (ch === 93) {
                                    state = 0;
                                } else {
                                    sb.append(String.fromCharCode(ch));
                                }
                                break;
                        }
                    }

                    var result = sb.toString();
                    return result;
                },
                ConsumeTill: function (chars, start, ch) {
                    for (var i = start; i < chars.length; i = (i + 1) | 0) {
                        if (chars[System.Array.index(i, chars)] === ch) {
                            return i;
                        }
                    }

                    return chars.length;
                },
                ParseEntityExpression: function (token) {
                    var $t;
                    var indexOfAssignment = System.String.indexOf(token, String.fromCharCode(61));
                    var indexOfStartingBracket = System.String.indexOf(token, String.fromCharCode(40));
                    if (indexOfAssignment > 0 && (indexOfStartingBracket < 0 || indexOfAssignment < indexOfStartingBracket)) {
                        var entityName = Kusto.Data.IntelliSense.ExpressionEntityParser.NormalizeEntityName(token.substr(0, indexOfAssignment).trim());
                        return System.Array.init([($t = new Kusto.Data.IntelliSense.ExpressionEntity(), $t.Name = entityName, $t)], Kusto.Data.IntelliSense.ExpressionEntity);
                    }

                    if (indexOfStartingBracket < 0) {
                        var indexOfEndingBracket = System.String.indexOf(token, String.fromCharCode(41));
                        if (indexOfEndingBracket >= 0) {
                            token = token.substr(0, indexOfEndingBracket);
                        }
                        var entityName1 = Kusto.Data.IntelliSense.ExpressionEntityParser.NormalizeEntityName(token.trim());
                        return System.Array.init([($t = new Kusto.Data.IntelliSense.ExpressionEntity(), $t.Name = entityName1, $t)], Kusto.Data.IntelliSense.ExpressionEntity);
                    } else if (indexOfStartingBracket === 0) {
                        var entitiesList = Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalancedRoundBrackets(token);
                        var entities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntitiesList(System.String, entitiesList, $asm.$.Kusto.Data.IntelliSense.ExpressionEntityParser.f1);
                        return System.Linq.Enumerable.from(entities).select($asm.$.Kusto.Data.IntelliSense.ExpressionEntityParser.f2);
                    }

                    var op = token.substr(0, indexOfStartingBracket).trim();
                    var argList = Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalancedRoundBrackets(token.substr(indexOfStartingBracket));
                    var $arguments = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntitiesList(System.String, argList, $asm.$.Kusto.Data.IntelliSense.ExpressionEntityParser.f1);
                    var result = ($t = new Kusto.Data.IntelliSense.ExpressionEntity(), $t.Operator = op, $t);
                    if (System.Linq.Enumerable.from($arguments).any()) {
                        result.Name = Kusto.Cloud.Platform.Utils.ExtendedString.TrimBalancedRoundBrackets($arguments.getItem(0));
                        result.Arguments = System.Linq.Enumerable.from($arguments).skip(1).ToArray(System.String);
                    }

                    return System.Array.init([result], Kusto.Data.IntelliSense.ExpressionEntity);
                },
                IndexOfClosingBracket: function (chars, closingBracket, startIndex) {
                    for (var i = startIndex; i < chars.length; i = (i + 1) | 0) {
                        var ch = chars[System.Array.index(i, chars)];
                        if (ch === 40) {
                            i = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 41, ((i + 1) | 0));
                        } else if (ch === 91) {
                            i = Kusto.Data.IntelliSense.ExpressionEntityParser.IndexOfClosingBracket(chars, 93, ((i + 1) | 0));
                        } else if (ch === closingBracket) {
                            return i;
                        }
                    }

                    // If we're out of the for - closing bracket was not found
                    return chars.length;
                }
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.ExpressionEntityParser", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.ExpressionEntityParser, {
        f1: function (s) {
            return System.Array.init([s.trim()], System.String);
        },
        f2: function (e) {
            var $t1;
            return ($t1 = new Kusto.Data.IntelliSense.ExpressionEntity(), $t1.Name = Kusto.Data.IntelliSense.ExpressionEntityParser.NormalizeEntityName(e), $t1);
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.IKustoIntelliSenseSchemaResolver", {
        $kind: "interface"
    });

    Bridge.define("Kusto.Data.IntelliSense.IntelliSenseCommandTip", {
        fields: {
            m_signature: null
        },
        props: {
            Name: null,
            Signature: {
                get: function () {
                    if (System.String.isNullOrEmpty(this.m_signature)) {
                        if (this.NameSuffix != null) {
                            this.m_signature = (this.Name || "") + (this.NameSuffix || "");
                        } else if (this.Parameters != null && System.Linq.Enumerable.from(this.Parameters).any()) {
                            var parameters = Bridge.toArray(System.Linq.Enumerable.from(this.Parameters).select($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip.f1)).join(", ");
                            this.m_signature = System.String.format("<b>{0}(</b>{1}<b>)</b>", this.Name, parameters);
                        } else {
                            this.m_signature = (this.Name || "") + "()";
                        }
                    }
                    return this.m_signature;
                }
            },
            Summary: null,
            Usage: null,
            NameSuffix: null,
            Parameters: null
        },
        methods: {
            GetSignatureWithBoldParameter: function (i) {
                var $t;
                var signature;
                if (this.Parameters != null && System.Linq.Enumerable.from(this.Parameters).any()) {
                    if (System.Linq.Enumerable.from(this.Parameters).count() > i) {
                        var boldElement = System.Array.init([System.String.format("<b>{0}</b>", [($t = System.Linq.Enumerable.from(this.Parameters).ToArray())[System.Array.index(i, $t)].PlainSignature])], System.String);
                        var parameters = Bridge.toArray(System.Linq.Enumerable.from(this.Parameters).take(i).select($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip.f2).concat(boldElement).concat(System.Linq.Enumerable.from(this.Parameters).skip(((i + 1) | 0)).select($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip.f2))).join(", ");
                        signature = System.String.format("<font color=\"blue\"><b>{0}</font>(</b>{1}<b>)</b>", this.Name, parameters);
                    } else {
                        var parameters1 = Bridge.toArray(System.Linq.Enumerable.from(this.Parameters).select($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip.f2)).join(", ");
                        signature = System.String.format("<font color=\"blue\"><b>{0}</font>(</b>{1}<b>)</b>", this.Name, parameters1);
                    }
                } else if (this.NameSuffix != null) {
                    signature = (this.Name || "") + (this.NameSuffix || "");
                } else {
                    signature = (this.Name || "") + "()";
                }
                return signature;
            },
            Clone: function () {
                var $t;
                var parameters = (this.Parameters != null && System.Linq.Enumerable.from(this.Parameters).any()) ? System.Linq.Enumerable.from(this.Parameters).select($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip.f3).ToArray(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter) : null;
                return ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = this.Name, $t.NameSuffix = this.NameSuffix, $t.Parameters = parameters, $t.Summary = this.Summary, $t.Usage = this.Usage, $t);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.IntelliSenseCommandTip", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.IntelliSenseCommandTip, {
        f1: function (p) {
            return p.Singature;
        },
        f2: function (p) {
            return p.PlainSignature;
        },
        f3: function (p) {
            return p.Clone();
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter", {
        props: {
            Name: null,
            Description: null,
            DataType: null,
            Optional: false,
            IsArgsArray: false,
            Singature: {
                get: function () {
                    if (this.IsArgsArray) {
                        return "...";
                    }

                    return System.String.format("<b>{0}{1}</b> <i>{2}</i>", this.Optional ? "[?] " : "", this.DataType, this.Name);
                }
            },
            PlainSignature: {
                get: function () {
                    if (this.IsArgsArray) {
                        return "...";
                    }

                    return System.String.format("{0}<font color=\"blue\">{1}</font> <i>{2}</i>", this.Optional ? "[?] " : "", this.DataType, this.Name);
                }
            }
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = this.DataType, $t.Description = this.Description, $t.IsArgsArray = this.IsArgsArray, $t.Name = this.Name, $t.Optional = this.Optional, $t);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer", {
        $kind: "nested class",
        statics: {
            fields: {
                Tracer: null
            },
            ctors: {
                init: function () {
                    this.Tracer = new Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.PrivateTracer();
                }
            }
        },
        methods: {
            TraceVerbose: function (format, list) {
                if (list === void 0) { list = []; }
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoCommandContext", {
        inherits: function () { return [System.IEquatable$1(Kusto.Data.IntelliSense.KustoCommandContext)]; },
        statics: {
            fields: {
                Empty: null
            },
            ctors: {
                init: function () {
                    this.Empty = new Kusto.Data.IntelliSense.KustoCommandContext("");
                }
            }
        },
        props: {
            Context: null,
            Operation: 0
        },
        alias: ["equalsT", "System$IEquatable$1$Kusto$Data$IntelliSense$KustoCommandContext$equalsT"],
        ctors: {
            ctor: function (context, operation) {
                if (operation === void 0) { operation = 0; }

                this.$initialize();
                this.Context = context;
                this.Operation = operation;
            }
        },
        methods: {
            equalsT: function (other) {
                return other != null && System.String.equals(other.Context, this.Context) && other.Operation === this.Operation;
            },
            getHashCode: function () {
                return Bridge.getHashCode(this.Context) ^ Bridge.getHashCode(this.Operation);
            },
            Flatten: function () {
                return System.Linq.Enumerable.from(System.String.split(this.Context, System.Array.init([44], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1)).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.KustoCommandContext.f1)).ToArray(Kusto.Data.IntelliSense.KustoCommandContext);
            },
            IsEmpty: function () {
                return System.String.isNullOrEmpty(this.Context);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.KustoCommandContext", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.KustoCommandContext, {
        f1: function (t) {
            return new Kusto.Data.IntelliSense.KustoCommandContext(t.trim(), this.Operation);
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseAccountEntity", {
        props: {
            Name: null
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity", {
        props: {
            ConnectionString: null,
            Alias: null,
            Databases: null,
            Plugins: null
        },
        methods: {
            Clone: function () {
                var $t, $t1, $t2;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity(), $t.ConnectionString = this.ConnectionString, $t.Alias = this.Alias, $t.Databases = ($t1 = this.Databases) != null ? System.Linq.Enumerable.from($t1).select($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity.f1).ToArray(Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity) : null, $t.Plugins = ($t2 = this.Plugins) != null ? System.Linq.Enumerable.from($t2).select($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity.f2).ToArray(Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity) : null, $t);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity, {
        f1: function (db) {
            return db.Clone();
        },
        f2: function (p) {
            return p.Clone();
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity", {
        props: {
            Name: null,
            TypeCode: 0
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t.Name = this.Name, $t.TypeCode = this.TypeCode, $t);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity", {
        props: {
            Name: null,
            Alias: null,
            Tables: null,
            Functions: null,
            IsInitialized: false
        },
        methods: {
            Clone: function () {
                var $t, $t1, $t2;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity(), $t.Name = this.Name, $t.Alias = this.Alias, $t.Tables = ($t1 = this.Tables) != null ? System.Linq.Enumerable.from($t1).select($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity.f1).ToArray(Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity) : null, $t.Functions = ($t2 = this.Functions) != null ? System.Linq.Enumerable.from($t2).select($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity.f2).ToArray(Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity) : null, $t.IsInitialized = this.IsInitialized, $t);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity, {
        f1: function (t) {
            return t.Clone();
        },
        f2: function (f) {
            return f.Clone();
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity", {
        props: {
            Name: null,
            CallName: null,
            Expression: null
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t.Name = this.Name, $t.CallName = this.CallName, $t.Expression = this.Expression, $t);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity", {
        props: {
            Name: null
        },
        methods: {
            Clone: function () {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity(), $t.Name = this.Name, $t);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseQuerySchema", {
        props: {
            Cluster: null,
            Database: null
        },
        ctors: {
            ctor: function (cluster, database) {
                this.$initialize();
                this.Cluster = cluster;
                this.Database = database;
            }
        },
        methods: {
            Clone: function () {
                return new Kusto.Data.IntelliSense.KustoIntelliSenseQuerySchema((this.Cluster != null) ? this.Cluster.Clone() : null, (this.Database != null) ? this.Database.Clone() : null);
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseServiceEntity", {
        props: {
            Name: null
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity", {
        props: {
            Name: null,
            IsInvisible: false,
            Columns: null
        },
        methods: {
            Clone: function () {
                var $t, $t1;
                return ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity(), $t.Name = this.Name, $t.Columns = ($t1 = this.Columns) != null ? System.Linq.Enumerable.from($t1).select($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity.f1).ToArray(Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity) : null, $t.IsInvisible = this.IsInvisible, $t);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity, {
        f1: function (c) {
            return c.Clone();
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.OptionKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                Operator: 1,
                Command: 2,
                Service: 3,
                Policy: 4,
                Database: 5,
                Table: 6,
                DataType: 7,
                Literal: 8,
                Parameter: 9,
                IngestionMapping: 10,
                ExpressionFunction: 11,
                Option: 12,
                OptionKind: 13,
                OptionRender: 14,
                Column: 15,
                ColumnString: 16,
                ColumnNumeric: 17,
                ColumnDateTime: 18,
                ColumnTimespan: 19,
                FunctionServerSide: 20,
                FunctionAggregation: 21,
                FunctionFilter: 22,
                FunctionScalar: 23,
                ClientDirective: 24
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ParseMode", {
        $kind: "enum",
        statics: {
            fields: {
                CommandTokensOnly: 0,
                TokenizeAllText: 1
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.RuleKind", {
        $kind: "enum",
        statics: {
            fields: {
                None: 0,
                YieldColumnNamesForFilter: 1,
                YieldColumnNamesForProject: 2,
                YieldColumnNamesForProjectAway: 3,
                YieldColumnNamesForProjectRename: 4,
                YieldColumnNamesForJoin: 5,
                YieldKindFlavorsForJoin: 6,
                YieldKindFlavorsForReduceBy: 7,
                YieldColumnNamesForOrdering: 8,
                YieldColumnNamesForTwoParamFunctions: 9,
                YieldColumnNamesForThreeParamFunctions: 10,
                YieldColumnNamesForManyParamFunctions: 11,
                YieldColumnNamesAndFunctionsForExtend: 12,
                YieldColumnNamesForMakeSeries: 13,
                YieldTableNames: 14,
                YieldTableNamesForFindIn: 15,
                YieldRenderOptions: 16,
                YieldRenderKindKeywordOption: 17,
                YieldRenderKindOptions: 18,
                YieldOperatorsAfterPipe: 19,
                YieldStringComparisonOptions: 20,
                YieldNumericComparisonOptions: 21,
                YieldDateTimeOperatorsOptions: 22,
                YieldSummarizeOperatorOptions: 23,
                YieldAscendingDescendingOptions: 24,
                YieldNumericScalarOptions: 25,
                YieldByKeywordOptions: 26,
                YieldWithKeywordOptions: 27,
                YieldStarOption: 28,
                YieldParseTypesKeywordOptions: 29,
                YieldColumnNamesForParse: 30,
                YieldColumnNamesForDiffPatternsPluginSplitParameter: 31,
                YieldParseKeywordKindsOptions: 32,
                YieldRangeFromOptions: 33,
                YieldRangeFromToOptions: 34,
                YieldRangeFromToStepOptions: 35,
                YieldQueryParameters: 36,
                YieldEvaluateOperatorOptions: 37,
                YieldPostJoinOptions: 38,
                YieldPostFindInOptions: 39,
                YieldPostFindOptions: 40,
                YieldTopNestedOfKeywordOption: 41,
                YieldTopNestedOthersOption: 42,
                YieldTopNestedKeywordOption: 43,
                YieldTopHittersKeywordOption: 44,
                YieldTimespanOptions: 45,
                YieldDatabaseNamesOptions: 46,
                YieldClusterNamesOptions: 47,
                YieldDatabaseFunctionOption: 48,
                YieldNullsFirstNullsLastOptions: 49,
                YieldTableNamesForRemoteQueryOptions: 50,
                YieldColumnNamesForRender: 51,
                YieldColumnNamesForFilterInFind: 52,
                YieldColumnNamesForProjectInFind: 53,
                YieldEndOrContinueFindInOptions: 54,
                YieldPostFindInListOptions: 55,
                YieldFindProjectSmartOptions: 56,
                YieldMakeSeriesOperatorOptions: 57,
                YieldMakeSeriesOperatorForDefaultOrOn: 58,
                YieldMakeSeriesOperatorForOn: 59,
                YieldMakeSeriesOperatorForRange: 60,
                YieldMakeSeriesOperatorForBy: 61,
                YieldPostSearchOptions: 62,
                YieldPostSearchKindOptions: 63,
                YieldSearchKindOptions: 64,
                YieldInsideSearchOptions: 65,
                YieldClientDirectivesOptions: 66,
                YieldClientDirective_ConnectOptions: 67,
                Last: 68
            }
        }
    });

    /** @namespace Kusto.Data.Net.Common */

    /**
     * Extensions for enum KustoDataStreamFormat
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Net.Common.ExtendedKustoDataStreamFormat
     */
    Bridge.define("Kusto.Data.Net.Common.ExtendedKustoDataStreamFormat", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoJsonDataStream: 
                            return "KustoJsonDataStream";
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoDataStream: 
                            return "KustoDataStream";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.Net.Common.KustoDataStreamFormat() };
                    return Kusto.Data.Net.Common.ExtendedKustoDataStreamFormat.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoJsonDataStream: 
                            return true;
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoDataStream: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Net.Common.KustoDataStreamFormat() };
                    if (Kusto.Data.Net.Common.ExtendedKustoDataStreamFormat.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "0": 
                        case "KustoJsonDataStream": 
                            ret.v = Kusto.Data.Net.Common.KustoDataStreamFormat.KustoJsonDataStream;
                            return true;
                        case "1": 
                        case "KustoDataStream": 
                            ret.v = Kusto.Data.Net.Common.KustoDataStreamFormat.KustoDataStream;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "kustojsondatastream": 
                                ret.v = Kusto.Data.Net.Common.KustoDataStreamFormat.KustoJsonDataStream;
                                return true;
                            case "kustodatastream": 
                                ret.v = Kusto.Data.Net.Common.KustoDataStreamFormat.KustoDataStream;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoJsonDataStream: 
                            return "JSON representation of the Kusto Data Stream (stable).";
                        case Kusto.Data.Net.Common.KustoDataStreamFormat.KustoDataStream: 
                            return "Binary data stream emitted by the Kusto engine. For internal use only (may change with no notice).";
                        default: 
                            return null;
                    }
                }
            }
        }
    });

    /**
     * Extensions for enum RemoteServiceType
     *
     * @static
     * @abstract
     * @public
     * @class Kusto.Data.Net.Common.ExtendedRemoteServiceType
     */
    Bridge.define("Kusto.Data.Net.Common.ExtendedRemoteServiceType", {
        statics: {
            methods: {
                FastToString: function (that) {
                    switch (that) {
                        case Kusto.Data.Net.Common.RemoteServiceType.Admin: 
                            return "Admin";
                        case Kusto.Data.Net.Common.RemoteServiceType.Query: 
                            return "Query";
                        case Kusto.Data.Net.Common.RemoteServiceType.UIRedirect: 
                            return "UIRedirect";
                        case Kusto.Data.Net.Common.RemoteServiceType.DataManagement: 
                            return "DataManagement";
                        case Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement: 
                            return "ClusterManagement";
                        case Kusto.Data.Net.Common.RemoteServiceType.Bridge: 
                            return "Bridge";
                        case Kusto.Data.Net.Common.RemoteServiceType.Ping: 
                            return "Ping";
                        case Kusto.Data.Net.Common.RemoteServiceType.CustomType: 
                            return "CustomType";
                        case Kusto.Data.Net.Common.RemoteServiceType.StreamIngest: 
                            return "StreamIngest";
                        case Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin: 
                            return "PassiveLogin";
                        case Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider: 
                            return "ArmResourceProvider";
                        case Kusto.Data.Net.Common.RemoteServiceType.AllControlCommands: 
                            return "AllControlCommands";
                        default: 
                            return System.String.format("[unknown: {0}]", [Bridge.box(that, System.Int32)]);
                    }
                },
                FastIsDefined$1: function (value) {
                    var dummy = { v : new Kusto.Data.Net.Common.RemoteServiceType() };
                    return Kusto.Data.Net.Common.ExtendedRemoteServiceType.FastTryParse(value, dummy, false, true);
                },
                FastIsDefined: function (value) {
                    switch (value) {
                        case Kusto.Data.Net.Common.RemoteServiceType.Admin: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.Query: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.UIRedirect: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.DataManagement: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.Bridge: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.Ping: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.CustomType: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.StreamIngest: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider: 
                            return true;
                        case Kusto.Data.Net.Common.RemoteServiceType.AllControlCommands: 
                            return true;
                        default: 
                            return false;
                    }
                },
                FastHasFlag$1: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasFlag: function (that, flag) {
                    return ((that & flag) === flag);
                },
                FastHasAllFlags: function (that, flags) {
                    return ((that & flags) === flags);
                },
                FastCountIntersectionsWith: function (that, flags) {
                    var intersections = that & flags;
                    return Kusto.Cloud.Platform.Utils.BitTwiddling.CountBits(intersections);
                },
                FastParse: function (value, ignoreCase) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    var ret = { v : new Kusto.Data.Net.Common.RemoteServiceType() };
                    if (Kusto.Data.Net.Common.ExtendedRemoteServiceType.FastTryParse(value, ret, ignoreCase)) {
                        return ret.v;
                    }
                    throw new System.Exception("Invalid enum value: " + (value || ""));
                },
                FastTryParse: function (value, ret, ignoreCase, ignoreInts) {
                    if (ignoreCase === void 0) { ignoreCase = false; }
                    if (ignoreInts === void 0) { ignoreInts = false; }
                    // If it is a simple value, just use that
                    switch (value) {
                        case "1": 
                        case "Admin": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.Admin;
                            return true;
                        case "2": 
                        case "Query": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.Query;
                            return true;
                        case "4": 
                        case "UIRedirect": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.UIRedirect;
                            return true;
                        case "8": 
                        case "DataManagement": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.DataManagement;
                            return true;
                        case "16": 
                        case "ClusterManagement": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement;
                            return true;
                        case "32": 
                        case "Bridge": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.Bridge;
                            return true;
                        case "64": 
                        case "Ping": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.Ping;
                            return true;
                        case "1024": 
                        case "CustomType": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.CustomType;
                            return true;
                        case "2048": 
                        case "StreamIngest": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.StreamIngest;
                            return true;
                        case "4096": 
                        case "PassiveLogin": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin;
                            return true;
                        case "8192": 
                        case "ArmResourceProvider": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider;
                            return true;
                        case "Admin | DataManagement | ClusterManagement | Bridge": 
                        case "AllControlCommands": 
                            ret.v = Kusto.Data.Net.Common.RemoteServiceType.AllControlCommands;
                            return true;
                        default: 
                            break;
                    }
                    if (ignoreCase && !System.String.isNullOrEmpty(value)) {
                        switch (value.toLowerCase()) {
                            case "admin": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.Admin;
                                return true;
                            case "query": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.Query;
                                return true;
                            case "uiredirect": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.UIRedirect;
                                return true;
                            case "datamanagement": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.DataManagement;
                                return true;
                            case "clustermanagement": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement;
                                return true;
                            case "bridge": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.Bridge;
                                return true;
                            case "ping": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.Ping;
                                return true;
                            case "customtype": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.CustomType;
                                return true;
                            case "streamingest": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.StreamIngest;
                                return true;
                            case "passivelogin": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin;
                                return true;
                            case "armresourceprovider": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider;
                                return true;
                            case "allcontrolcommands": 
                                ret.v = Kusto.Data.Net.Common.RemoteServiceType.AllControlCommands;
                                return true;
                            default: 
                                break;
                        }
                    }

                    // If it can be interpreted as an integer, do so (use IsDefined if unwanted)
                    if (!ignoreInts) {
                        var reti = { v : 0 };
                        if (System.Int32.tryParse(value, reti)) {
                            ret.v = reti.v;
                            return true;
                        }
                    }

                    // TODO: Here we might want to break the line on commas and try again, like Enum.TryParse
                    ret.v = 0;
                    return false;
                },
                FastGetDescription: function (that) {
                    switch (that) {
                        case Kusto.Data.Net.Common.RemoteServiceType.Admin: 
                            return "Controls Kusto Engine.";
                        case Kusto.Data.Net.Common.RemoteServiceType.Query: 
                            return "Queries Kusto Engine.";
                        case Kusto.Data.Net.Common.RemoteServiceType.UIRedirect: 
                            return "Redirects to Kusto.Explorer or similar client.";
                        case Kusto.Data.Net.Common.RemoteServiceType.DataManagement: 
                            return "Controls Kusto DM.";
                        case Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement: 
                            return "Controls Kusto CM.";
                        case Kusto.Data.Net.Common.RemoteServiceType.Bridge: 
                            return "Controls Kusto Bridge to Geneva/Aria pipelines.";
                        case Kusto.Data.Net.Common.RemoteServiceType.Ping: 
                            return "Load-balancer ping responder.";
                        case Kusto.Data.Net.Common.RemoteServiceType.CustomType: 
                            return "Custom.";
                        case Kusto.Data.Net.Common.RemoteServiceType.StreamIngest: 
                            return "Streaming ingestion into Kusto Engine.";
                        case Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin: 
                            return "Manages passive authentication flows.";
                        case Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider: 
                            return "Controls Kusto RP.";
                        case Kusto.Data.Net.Common.RemoteServiceType.AllControlCommands: 
                            return "A bitwise OR of all service types that provide control commands.";
                        default: 
                            return null;
                    }
                },
                FastGetFlags: function (that) {
                    return new (Bridge.GeneratorEnumerable$1(Kusto.Data.Net.Common.RemoteServiceType))(Bridge.fn.bind(this, function (that) {
                        var $step = 0,
                            $jumpFromFinally,
                            $returnValue,
                            $async_e;

                        var $enumerator = new (Bridge.GeneratorEnumerator$1(Kusto.Data.Net.Common.RemoteServiceType))(Bridge.fn.bind(this, function () {
                            try {
                                for (;;) {
                                    switch ($step) {
                                        case 0: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.Admin) === Kusto.Data.Net.Common.RemoteServiceType.Admin) {
                                                    $step = 1;
                                                    continue;
                                                } 
                                                $step = 3;
                                                continue;
                                        }
                                        case 1: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.Admin;
                                                $step = 2;
                                                return true;
                                        }
                                        case 2: {
                                            $step = 3;
                                            continue;
                                        }
                                        case 3: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.Query) === Kusto.Data.Net.Common.RemoteServiceType.Query) {
                                                    $step = 4;
                                                    continue;
                                                } 
                                                $step = 6;
                                                continue;
                                        }
                                        case 4: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.Query;
                                                $step = 5;
                                                return true;
                                        }
                                        case 5: {
                                            $step = 6;
                                            continue;
                                        }
                                        case 6: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.UIRedirect) === Kusto.Data.Net.Common.RemoteServiceType.UIRedirect) {
                                                    $step = 7;
                                                    continue;
                                                } 
                                                $step = 9;
                                                continue;
                                        }
                                        case 7: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.UIRedirect;
                                                $step = 8;
                                                return true;
                                        }
                                        case 8: {
                                            $step = 9;
                                            continue;
                                        }
                                        case 9: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.DataManagement) === Kusto.Data.Net.Common.RemoteServiceType.DataManagement) {
                                                    $step = 10;
                                                    continue;
                                                } 
                                                $step = 12;
                                                continue;
                                        }
                                        case 10: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.DataManagement;
                                                $step = 11;
                                                return true;
                                        }
                                        case 11: {
                                            $step = 12;
                                            continue;
                                        }
                                        case 12: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement) === Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement) {
                                                    $step = 13;
                                                    continue;
                                                } 
                                                $step = 15;
                                                continue;
                                        }
                                        case 13: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.ClusterManagement;
                                                $step = 14;
                                                return true;
                                        }
                                        case 14: {
                                            $step = 15;
                                            continue;
                                        }
                                        case 15: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.Bridge) === Kusto.Data.Net.Common.RemoteServiceType.Bridge) {
                                                    $step = 16;
                                                    continue;
                                                } 
                                                $step = 18;
                                                continue;
                                        }
                                        case 16: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.Bridge;
                                                $step = 17;
                                                return true;
                                        }
                                        case 17: {
                                            $step = 18;
                                            continue;
                                        }
                                        case 18: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.Ping) === Kusto.Data.Net.Common.RemoteServiceType.Ping) {
                                                    $step = 19;
                                                    continue;
                                                } 
                                                $step = 21;
                                                continue;
                                        }
                                        case 19: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.Ping;
                                                $step = 20;
                                                return true;
                                        }
                                        case 20: {
                                            $step = 21;
                                            continue;
                                        }
                                        case 21: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.CustomType) === Kusto.Data.Net.Common.RemoteServiceType.CustomType) {
                                                    $step = 22;
                                                    continue;
                                                } 
                                                $step = 24;
                                                continue;
                                        }
                                        case 22: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.CustomType;
                                                $step = 23;
                                                return true;
                                        }
                                        case 23: {
                                            $step = 24;
                                            continue;
                                        }
                                        case 24: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.StreamIngest) === Kusto.Data.Net.Common.RemoteServiceType.StreamIngest) {
                                                    $step = 25;
                                                    continue;
                                                } 
                                                $step = 27;
                                                continue;
                                        }
                                        case 25: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.StreamIngest;
                                                $step = 26;
                                                return true;
                                        }
                                        case 26: {
                                            $step = 27;
                                            continue;
                                        }
                                        case 27: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin) === Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin) {
                                                    $step = 28;
                                                    continue;
                                                } 
                                                $step = 30;
                                                continue;
                                        }
                                        case 28: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.PassiveLogin;
                                                $step = 29;
                                                return true;
                                        }
                                        case 29: {
                                            $step = 30;
                                            continue;
                                        }
                                        case 30: {
                                            if ((that & Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider) === Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider) {
                                                    $step = 31;
                                                    continue;
                                                } 
                                                $step = 33;
                                                continue;
                                        }
                                        case 31: {
                                            $enumerator.current = Kusto.Data.Net.Common.RemoteServiceType.ArmResourceProvider;
                                                $step = 32;
                                                return true;
                                        }
                                        case 32: {
                                            $step = 33;
                                            continue;
                                        }
                                        case 33: {

                                        }
                                        default: {
                                            return false;
                                        }
                                    }
                                }
                            } catch($async_e1) {
                                $async_e = System.Exception.create($async_e1);
                                throw $async_e;
                            }
                        }));
                        return $enumerator;
                    }, arguments));
                }
            }
        }
    });

    /**
     * The format of the data stream returned by a Kusto service.
     *
     * @public
     * @class Kusto.Data.Net.Common.KustoDataStreamFormat
     */
    Bridge.define("Kusto.Data.Net.Common.KustoDataStreamFormat", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * JSON representation of the Kusto Data Stream (stable).
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.KustoDataStreamFormat
                 * @constant
                 * @default 0
                 * @type Kusto.Data.Net.Common.KustoDataStreamFormat
                 */
                KustoJsonDataStream: 0,
                /**
                 * Binary data stream emitted by the Kusto engine. For internal use only (may change with no notice).
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.KustoDataStreamFormat
                 * @constant
                 * @default 1
                 * @type Kusto.Data.Net.Common.KustoDataStreamFormat
                 */
                KustoDataStream: 1
            }
        }
    });

    /**
     * A bitmask that represents one or more externally-visible Kusto network services
     *
     * @public
     * @class Kusto.Data.Net.Common.RemoteServiceType
     */
    Bridge.define("Kusto.Data.Net.Common.RemoteServiceType", {
        $kind: "enum",
        statics: {
            fields: {
                /**
                 * Controls Kusto Engine.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 1
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                Admin: 1,
                /**
                 * Queries Kusto Engine.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 2
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                Query: 2,
                /**
                 * Redirects to Kusto.Explorer or similar client.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 4
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                UIRedirect: 4,
                /**
                 * Controls Kusto DM.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 8
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                DataManagement: 8,
                /**
                 * Controls Kusto CM.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 16
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                ClusterManagement: 16,
                /**
                 * Controls Kusto Bridge to Geneva/Aria pipelines.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 32
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                Bridge: 32,
                /**
                 * Load-balancer ping responder.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 64
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                Ping: 64,
                /**
                 * Custom.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 1024
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                CustomType: 1024,
                /**
                 * Streaming ingestion into Kusto Engine.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 2048
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                StreamIngest: 2048,
                /**
                 * Manages passive authentication flows.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 4096
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                PassiveLogin: 4096,
                /**
                 * Controls Kusto RP.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 8192
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                ArmResourceProvider: 8192,
                /**
                 * A bitwise OR of all service types that provide control commands.
                 *
                 * @static
                 * @public
                 * @memberof Kusto.Data.Net.Common.RemoteServiceType
                 * @constant
                 * @default 57
                 * @type Kusto.Data.Net.Common.RemoteServiceType
                 */
                AllControlCommands: 57
            }
        },
        $flags: true
    });

    Bridge.define("Kusto.JavaScript.Client.App", {
        statics: {
            methods: {
                Test: function () {
                    // To confirm Bridge.NET is working: 
                    // 1. Build this project (Ctrl + Shift + B)
                    // 2. Browse to file /Bridge/www/demo.html
                    // 3. Right-click on file and select "View in Browser" (Ctrl + Shift + W)
                    // 4. File should open in a browser and the alert message above should popup
                    // 5. Success!

                    // TODO: find a better way to include this into a test regression suite
                    Kusto.UT.IntelliSenseRulesTests.InitializeTestClass();
                    var intellisenseTests = new Kusto.UT.IntelliSenseRulesTests();

                    // Entity resolution tests
                    intellisenseTests.IntelliSenseCommandEntitiesTest();
                    intellisenseTests.IntelliSenseCommandEntitiesForTablesTest();
                    intellisenseTests.IntelliSenseCommandEntitiesUsingFunctionsTest();
                    intellisenseTests.IntelliSenseCommandEntities_FindTest();
                    intellisenseTests.IntelliSenseCommandEntities_SearchTest();

                    // IntelliSense (completion) tests
                    intellisenseTests.IntelliSenseExtendTest();
                    intellisenseTests.IntelliSenseFilterTest();
                    intellisenseTests.IntelliSenseGetCommandContextTest();
                    intellisenseTests.IntelliSenseJoinTest();
                    intellisenseTests.IntelliSenseLimitTest();
                    intellisenseTests.IntelliSenseParseOperator();
                    intellisenseTests.IntelliSenseProjectAwayTest();
                    intellisenseTests.IntelliSenseProjectRenameTest();
                    intellisenseTests.IntelliSenseProjectTest();
                    intellisenseTests.IntelliSenseQueryParametersTest();
                    intellisenseTests.IntelliSenseRangeTest();
                    intellisenseTests.IntelliSenseReduceTest();
                    intellisenseTests.IntelliSenseRenderTest();
                    intellisenseTests.IntelliSenseSummarizeTest();
                    intellisenseTests.IntelliSenseTopTest();
                    intellisenseTests.IntelliSenseTopNestedTest();
                    intellisenseTests.IntelliSenseToScalarTest();
                    intellisenseTests.IntelliSenseTimeKeywordsTest();
                    intellisenseTests.IntelliSenseEvaluateTest();
                    intellisenseTests.IntelliSenseClusterTest();
                    intellisenseTests.IntelliSenseDatabaseTest();
                    intellisenseTests.IntelliSenseFindTest();
                    intellisenseTests.IntelliSenseSearchTest();
                    intellisenseTests.IntelliSenseSampleTest();
                    intellisenseTests.IntelliSenseSampleDistinctTest();
                    intellisenseTests.IntelliSenseMakeSeriesTest();

                    var parserTests = new Kusto.UT.IntelliSenseCslCommandParserTests();
                    parserTests.InitializeTestClass();
                    // TODO: re-enable after fixing new-lines difference issues between JS and .NET
                    //parserTests.TestClsCommandsPerttifier();
                    parserTests.TestCslCommandParserEntities();

                    Bridge.global.alert("Success");

                }
            }
        }
    });

    Bridge.define("Kusto.UT.AssertStub", {
        methods: {
            AreEqual: function (expected, actual) {
                var $t, $t1;
                if (!Bridge.referenceEquals(expected, actual)) {
                    throw new System.Exception(System.String.format("Values do not match: expected='{0}', actual='{1}'", ($t = expected, $t != null ? $t : "null"), ($t1 = actual, $t1 != null ? $t1 : "null")));
                }
            },
            AreEqual$1: function (expected, actual, errorMessage) {
                var $t, $t1;
                if (!Bridge.referenceEquals(expected, actual)) {
                    throw new System.Exception(System.String.format("Values do not match: expected='{0}', actual='{1}'\n{2}", ($t = expected, $t != null ? $t : "null"), ($t1 = actual, $t1 != null ? $t1 : "null"), errorMessage));
                }
            },
            Fail: function (message) {
                throw new System.Exception(message);
            },
            IsTrue: function (condition, message) {
                if (!condition) {
                    throw new System.Exception(message);
                }
            }
        }
    });

    Bridge.define("Kusto.UT.IntelliSenseCslCommandParserTests", {
        fields: {
            Assert: null,
            m_intelliSenseProvider: null
        },
        ctors: {
            init: function () {
                this.Assert = new Kusto.UT.AssertStub();
            }
        },
        methods: {
            InitializeTestClass: function () {
                var queryParameters = new (System.Collections.Generic.List$1(System.String)).ctor();
                var availableClusters = new (System.Collections.Generic.List$1(System.String)).ctor();
                var clusterSchema = Kusto.UT.IntelliSenseRulesTests.GenerateKustoEntities(queryParameters, availableClusters);
                var schema = new Kusto.Data.IntelliSense.KustoIntelliSenseQuerySchema(clusterSchema, System.Linq.Enumerable.from(clusterSchema.Databases).first());
                this.m_intelliSenseProvider = new Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.$ctor1(clusterSchema, schema, queryParameters, availableClusters, void 0, true, true);
            },
            TestClsCommandsPerttifier: function () {
                var $t;
                var queriesAndResults = System.Array.init([{ Item1: "let ErrorCounts = (message:string) {\r\nErrorCountsByBin(message, 1d)\r\n};\r\nErrorCounts(\"Can not perform requested operation on nested resource. Parent resource\") | extend error = \"parent not found\"", Item2: "let ErrorCounts = (message:string)\r\n{\r\n    ErrorCountsByBin(message, 1d)\r\n};\r\nErrorCounts(\"Can not perform requested operation on nested resource. Parent resource\")\r\n| extend error = \"parent not found\"" }, { Item1: "Table\r\n//| project ProjectKind, UserId, ProjectType\r\n//| join (activeTable) on UserId\r\n//| summarize dcount(UserId) by ProjectType\r\n//| sort by dcount_UserId asc\r\n| count", Item2: "Table\r\n//| project ProjectKind, UserId, ProjectType\r\n//| join (activeTable) on UserId\r\n//| summarize dcount(UserId) by ProjectType\r\n//| sort by dcount_UserId asc\r\n| count" }, { Item1: "Table\r\n| join (Table) on Key", Item2: "Table\r\n| join\r\n(\r\n    Table\r\n)\r\non Key" }, { Item1: "PerRequestTable | where MSODS contains \"}\" | take 1", Item2: "PerRequestTable\r\n| where MSODS contains \"}\"\r\n| take 1" }, { Item1: "let variable=1;Table | count", Item2: "let variable=1;\r\nTable\r\n| count" }, { Item1: "// comment\r\nKustoLogs | where Timestamp > ago(1d) and EventText contains \"[0]Kusto.DataNode.Exceptions.SemanticErrorException: Semantic error: Query 'Temp_MonRgLoad | project TIMESTAMP | consume' has the following semantic error: \" | summarize cnt() by Source", Item2: "// comment\r\nKustoLogs\r\n| where Timestamp > ago(1d) and EventText contains \"[0]Kusto.DataNode.Exceptions.SemanticErrorException: Semantic error: Query 'Temp_MonRgLoad | project TIMESTAMP | consume' has the following semantic error: \"\r\n| summarize cnt() by Source" }, { Item1: "Table |   join (Table | project x ) on x | count", Item2: "Table\r\n| join\r\n(\r\n    Table\r\n    | project x\r\n)\r\non x\r\n| count" }, { Item1: "Table | join kind=inner (Table | project x ) on x | count", Item2: "Table\r\n| join kind=inner\r\n(\r\n    Table\r\n    | project x\r\n)\r\non x\r\n| count" }, { Item1: "let foo = (i: long) { range x from 1 to 1 step 1 }; foo()", Item2: "let foo = (i: long)\r\n{\r\n    range x from 1 to 1 step 1\r\n};\r\nfoo()" }, { Item1: "let foo = (i: long) {range x from 1 to 1 step 1 | count }; foo()", Item2: "let foo = (i: long)\r\n{\r\n    range x from 1 to 1 step 1\r\n    | count\r\n};\r\nfoo()" }, { Item1: ".alter function with (docstring = @'List of UserIds that are WebSites only', folder =@'Filters') UsersWithWebSiteAppsOnly() { DimAppUsage() | join kind=leftouter DimApplications() on ApplicationId | where RequestSource in (\"unknown\", \"ibiza\",\"ibizaaiextensionauto\") | summarize by UserId = UserId }", Item2: ".alter function with (docstring = @'List of UserIds that are WebSites only', folder =@'Filters') UsersWithWebSiteAppsOnly()\r\n{\r\n    DimAppUsage()\r\n    | join kind=leftouter\r\n        DimApplications()\r\n    on ApplicationId\r\n    | where RequestSource in (\"unknown\", \"ibiza\",\"ibizaaiextensionauto\")\r\n    | summarize by UserId = UserId\r\n}" }, { Item1: ".alter function with (docstring = @'List of UserIds that are WebSites only', folder =@'Filters') UsersWithWebSiteAppsOnly()\r\n{\r\n    DimAppUsage()\r\n    | join kind=leftouter DimApplications() on ApplicationId\r\n    | where RequestSource in (\"unknown\", \"ibiza\",\"ibizaaiextensionauto\")\r\n    | summarize by UserId = UserId\r\n}", Item2: ".alter function with (docstring = @'List of UserIds that are WebSites only', folder =@'Filters') UsersWithWebSiteAppsOnly()\r\n{\r\n    DimAppUsage()\r\n    | join kind=leftouter\r\n        DimApplications()\r\n    on ApplicationId\r\n    | where RequestSource in (\"unknown\", \"ibiza\",\"ibizaaiextensionauto\")\r\n    | summarize by UserId = UserId\r\n}" }, { Item1: "KustoLogs | where Timestamp > ago(6d) | where ClientActivityId=='KE.RunQuery;e0944367-3fd6-4f83-b2e9-ff0724d55053'", Item2: "KustoLogs\r\n| where Timestamp > ago(6d)\r\n| where ClientActivityId=='KE.RunQuery;e0944367-3fd6-4f83-b2e9-ff0724d55053'" }, { Item1: "KustoLogs | make-series dusers=dcount(RequestSource) default=0 on Timestamp in range(ago(6d), now(), 1d) by userid | where stat(dusers).max>1000", Item2: "KustoLogs\r\n| make-series dusers=dcount(RequestSource) default=0 on Timestamp in range(ago(6d), now(), 1d) by userid\r\n| where stat(dusers).max>1000" }, { Item1: "let a = 1;//comment\r\nprint x = a * b * c//one more comment", Item2: "let a = 1;\r\n//comment\r\nprint x = a * b * c\r\n//one more comment" }, { Item1: "let a = 1;\r\n//comment\r\nprint x = a * b * c\r\n//one more comment", Item2: "let a = 1;\r\n//comment\r\nprint x = a * b * c\r\n//one more comment" }, { Item1: "Table | join kind = leftouter ( Table | join (Table //comment1\r\n)    on $left.i == $right.i//comment2\r\n) on i", Item2: "Table\r\n| join kind = leftouter\r\n(\r\n    Table\r\n    | join\r\n    (\r\n        Table\r\n        //comment1\r\n    )\r\n    on $left.i == $right.i\r\n    //comment2\r\n)\r\non i" }, { Item1: "Table | join kind = leftouter ( Table | join Table //comment1\r\non $left.i == $right.i//comment2\r\n) on i", Item2: "Table\r\n| join kind = leftouter\r\n(\r\n    Table\r\n    | join\r\n        Table\r\n        //comment1\r\n    on $left.i == $right.i\r\n    //comment2\r\n)\r\non i" }], System.Object);

                $t = Bridge.getEnumerator(queriesAndResults);
                try {
                    while ($t.moveNext()) {
                        var testCase = $t.Current;
                        var input = testCase.Item1;
                        input = System.String.replaceAll(input, "\n", "");
                        var actualResult = Kusto.Data.Common.CslQueryParser.PrettifyQuery(input, "");
                        var expectedResult = testCase.Item2;
                        expectedResult = System.String.replaceAll(expectedResult, "\r", "");
                        this.Assert.AreEqual(expectedResult, actualResult);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            TestCslCommandParserEntities: function () {
                var parser = new Kusto.Data.IntelliSense.CslCommandParser();

                this.ValidateTokens(parser, "Table1 \r\n                | parse Field1 with * Column1:string * Column2:int\r\n                | project", Kusto.Data.IntelliSense.CslCommandToken.Kind.CalculatedColumnToken, System.Array.init(["Column1", "Column2"], System.String));

                this.ValidateTokens(parser, "let s = now();\r\n                Table1 \r\n                | extend x = Field1 \r\n                | project", Kusto.Data.IntelliSense.CslCommandToken.Kind.TableColumnToken, System.Array.init(["Field1"], System.String));

                this.ValidateTokens(parser, "Table1 \r\n                | extend x = Field1 \r\n                | project", Kusto.Data.IntelliSense.CslCommandToken.Kind.TableColumnToken, System.Array.init(["Field1"], System.String));

            },
            ValidateTokens: function (parser, query, kind, expectedTokens) {
                var commands = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, query, Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).toList(Bridge.global.Kusto.Data.IntelliSense.CslCommand);
                var columns = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f1).where(function (t) {
                    return t.TokenKind === kind;
                }).select($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f2).toList(System.String);
                Kusto.UT.IntelliSenseRulesTests.ValidateEntities(query, expectedTokens, columns);
            },
            TestCslCommandParserReuse: function () {
                var $t;
                var parser = new Kusto.Data.IntelliSense.CslCommandParser();

                $t = Bridge.getEnumerator(System.Array.init(["let s = 1;\r\n                  let r = range x from s to 1 step 1;\r\n                  r | ", "Table1 | where Field1 == 'rrr' "], System.String));
                try {
                    while ($t.moveNext()) {
                        var query = $t.Current;
                        this.ValidateParserReuse(parser, query);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            ValidateParserReuse: function (parser, query) {
                var tokens = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, query, Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f1).where($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f3).ToArray(Kusto.Data.IntelliSense.CslCommandToken);

                // Add space to the query: same amount of tokens should remain
                {
                    var tokens_2 = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, (query || "") + " ", Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f1).where($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f3).ToArray(Kusto.Data.IntelliSense.CslCommandToken);
                    this.ComapreParseResultTokens(tokens, System.Linq.Enumerable.from(tokens_2).ToArray(), 0, false);
                }

                // Prepend query with a comment: all except comment token should be the same
                {
                    var tokens_21 = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, "// comment" + ("\n" || "") + (query || ""), Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f1).where($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f3).ToArray(Kusto.Data.IntelliSense.CslCommandToken);
                    this.Assert.AreEqual(Bridge.box(tokens.length, System.Int32), Bridge.box(((tokens_21.length - 1) | 0), System.Int32));
                    for (var i = 0; i < tokens.length; i = (i + 1) | 0) {
                        // Skip last token
                        if (i < ((tokens.length - 1) | 0)) {
                            this.Assert.AreEqual(tokens[System.Array.index(i, tokens)].Value, tokens_21[System.Array.index(((i + 1) | 0), tokens_21)].Value);
                            this.Assert.AreEqual(Bridge.box(tokens[System.Array.index(i, tokens)].TokenKind, Kusto.Data.IntelliSense.CslCommandToken.Kind, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommandToken.Kind)), Bridge.box(tokens_21[System.Array.index(((i + 1) | 0), tokens_21)].TokenKind, Kusto.Data.IntelliSense.CslCommandToken.Kind, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommandToken.Kind)));
                        }
                    }

                    var tokens_3 = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, "// comment " + ("\n" || "") + (query || ""), Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f1).where($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f3).ToArray(Kusto.Data.IntelliSense.CslCommandToken);
                    this.ComapreParseResultTokens(tokens_21, tokens_3, 1, false);
                }
            },
            ComapreParseResultTokens: function (tokens, other, startIndex, fullValidation) {
                for (var i = startIndex; i < tokens.length; i = (i + 1) | 0) {
                    // Skip last token
                    if (i < ((tokens.length - 1) | 0)) {
                        if (fullValidation) {
                            this.Assert.AreEqual(tokens[System.Array.index(i, tokens)], other[System.Array.index(i, other)]);
                        } else {
                            this.Assert.AreEqual(tokens[System.Array.index(i, tokens)].Value, other[System.Array.index(i, other)].Value);
                            this.Assert.AreEqual(Bridge.box(tokens[System.Array.index(i, tokens)].TokenKind, Kusto.Data.IntelliSense.CslCommandToken.Kind, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommandToken.Kind)), Bridge.box(other[System.Array.index(i, other)].TokenKind, Kusto.Data.IntelliSense.CslCommandToken.Kind, System.Enum.toStringFn(Kusto.Data.IntelliSense.CslCommandToken.Kind)));
                        }
                    }
                }

                this.Assert.AreEqual(Bridge.box(tokens.length, System.Int32), Bridge.box(other.length, System.Int32));

            },
            TestCslCommandParserBrackets: function () {
                var parser = new Kusto.Data.IntelliSense.CslCommandParser();

                this.ValidateBracketTokens(parser, "Table1 | extend x = floor(t, 1)", System.Array.init(["(t, 1)"], System.String));

                this.ValidateBracketTokens(parser, "Table1 | extend x = floor(t, bin(1, 1))", System.Array.init(["(t, bin(1, 1))", "(1, 1)"], System.String));

                this.ValidateBracketTokens(parser, "Table1 | extend x = floor(t[1], bin(1, 1))", System.Array.init(["(t[1], bin(1, 1))", "(1, 1)", "[1]"], System.String));


                this.ValidateBracketTokens(parser, "Table1 | extend x = floor(t[floor(100, 100)], bin(1, 1))", System.Array.init(["(t[floor(100, 100)], bin(1, 1))", "(1, 1)", "[floor(100, 100)]", "(100, 100)"], System.String));

                this.ValidateBracketTokens(parser, "Table1 | extend x = { floor(t[1], bin(1, 1)) }", System.Array.init(["(t[1], bin(1, 1))", "(1, 1)", "[1]", "{ floor(t[1], bin(1, 1)) }"], System.String));
            },
            ValidateBracketTokens: function (parser, query, expectedTokens) {
                var commands = System.Linq.Enumerable.from(parser.Parse(this.m_intelliSenseProvider, query, Kusto.Data.IntelliSense.ParseMode.TokenizeAllText)).toList(Bridge.global.Kusto.Data.IntelliSense.CslCommand);
                var columns = System.Linq.Enumerable.from(commands).selectMany($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f4).select($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests.f2).toList(System.String);
                Kusto.UT.IntelliSenseRulesTests.ValidateEntities(query, expectedTokens, columns);
            }
        }
    });

    Bridge.ns("Kusto.UT.IntelliSenseCslCommandParserTests", $asm.$);

    Bridge.apply($asm.$.Kusto.UT.IntelliSenseCslCommandParserTests, {
        f1: function (c) {
            return c.Tokens;
        },
        f2: function (t) {
            return t.Value;
        },
        f3: function (t) {
            return t.TokenKind !== Kusto.Data.IntelliSense.CslCommandToken.Kind.UnknownToken;
        },
        f4: function (c) {
            return c.BracketParts;
        }
    });

    Bridge.define("Kusto.UT.IntelliSenseRulesTests", {
        statics: {
            fields: {
                Assert: null,
                s_intelliSenseProvider: null,
                s_columnMappings: null
            },
            ctors: {
                init: function () {
                    this.Assert = new Kusto.UT.AssertStub();
                    this.s_columnMappings = new (System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.String)))();
                }
            },
            methods: {
                ValidateEntities: function (command, expectedFields, entititesList) {
                    var $t, $t1;
                    // Check if expectedFields against resolved entities
                    Kusto.UT.IntelliSenseRulesTests.Assert.IsTrue(System.Linq.Enumerable.from(expectedFields).count() === entititesList.Count, System.String.format("Counts of expected entities ('{0}') and actual command entities ('{1}') do not match.\nExpected entities: {2}\nActual entities:   {3}\nCommand: {4}", Bridge.box(System.Linq.Enumerable.from(expectedFields).count(), System.Int32), Bridge.box(entititesList.Count, System.Int32), expectedFields.join(","), Bridge.toArray(entititesList).join(","), command));

                    $t = Bridge.getEnumerator(entititesList);
                    try {
                        while ($t.moveNext()) {
                            var entity = $t.Current;
                            if (!System.Linq.Enumerable.from(expectedFields).contains(entity)) {
                                Kusto.UT.IntelliSenseRulesTests.Assert.Fail(System.String.format("Entity '{0}' is not appearing on the expected list. Command: {1}", entity, command));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    $t1 = Bridge.getEnumerator(expectedFields);
                    try {
                        while ($t1.moveNext()) {
                            var entity1 = $t1.Current;
                            if (!entititesList.contains(entity1)) {
                                Kusto.UT.IntelliSenseRulesTests.Assert.Fail(System.String.format("Entity '{0}' is not appearing on the resolved list. Command: {1}", entity1, command));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }},
                InitializeTestClass: function () {
                    var queryParameters = new (System.Collections.Generic.List$1(System.String)).ctor();
                    var availableClusters = new (System.Collections.Generic.List$1(System.String)).ctor();
                    var clusterSchema = Kusto.UT.IntelliSenseRulesTests.GenerateKustoEntities(queryParameters, availableClusters);
                    var schema = new Kusto.Data.IntelliSense.KustoIntelliSenseQuerySchema(clusterSchema, System.Linq.Enumerable.from(clusterSchema.Databases).first());
                    Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider = new Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.$ctor1(clusterSchema, schema, queryParameters, availableClusters, new Kusto.UT.IntelliSenseRulesTests.RemoteSchemaResolverMock(), true, true);
                },
                TestIntelliSensePatterns: function (intelliSenseProvider, testPatterns) {
                    var $t, $t1;

                    var patternsWithLet = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                    $t = Bridge.getEnumerator(testPatterns);
                    try {
                        while ($t.moveNext()) {
                            var testPattern = $t.Current;
                            if (!System.String.startsWith(System.String.trimStart(testPattern.Input), ".")) {
                                patternsWithLet.add(($t1 = new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.ctor("let variable = 1;\n" + (testPattern.Input || "")), $t1.ExpectedMatch = testPattern.ExpectedMatch, $t1.ExpectedRuleKind = testPattern.ExpectedRuleKind, $t1));
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }testPatterns.AddRange(patternsWithLet);

                    $t1 = Bridge.getEnumerator(testPatterns);
                    try {
                        while ($t1.moveNext()) {
                            var testPattern1 = $t1.Current;
                            var rule = { v : null };
                            var matchingSuccess = intelliSenseProvider.TryMatchAnyRule(testPattern1.Input, rule);
                            if (matchingSuccess !== testPattern1.ExpectedMatch) {
                                var failMessage = System.String.format("Input '{0}' was incorrectly intelli-sensed. Expected: {1} ({2}), actual: {3} ({4})", testPattern1.Input, (testPattern1.ExpectedMatch) ? "MATCH" : "NO-MATCH", Bridge.box(testPattern1.ExpectedRuleKind, System.Int32), (matchingSuccess) ? "MATCH" : "NO-MATCH", Bridge.box((rule.v != null) ? rule.v.Kind : 0, System.Int32));
                                Kusto.UT.IntelliSenseRulesTests.Assert.Fail(failMessage);
                            }

                            var expectedRule = Bridge.toString(testPattern1.ExpectedRuleKind);
                            if (testPattern1.ExpectedMatch && testPattern1.ExpectedRuleKind !== rule.v.Kind) {
                                var failMessage1 = System.String.format("Input '{0}' was incorrectly intelli-sensed. Expected rule: {1}, actual rule: {2}", testPattern1.Input, expectedRule, Bridge.box(rule.v.Kind, System.Int32));
                                Kusto.UT.IntelliSenseRulesTests.Assert.Fail(failMessage1);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }},
                GetColumnsOfTable: function (tableName) {
                    if (Kusto.UT.IntelliSenseRulesTests.s_columnMappings.containsKey(tableName)) {
                        return Kusto.UT.IntelliSenseRulesTests.s_columnMappings.get(tableName);
                    }

                    return null;
                },
                /**
                 * Creates an-IntelliSense view of the database schema
                 Database: "Database1"
                     Tables: "Table1", "Table.2", "Table3"
                         Table1 columns: Field[0..9] (string), NumField[0..9]:int, DateTimeField[0..4]:datetime, TimeSpanField[0..4]:timespan
                         Table2 columns: Field[0..9] (string), NumField[0..9]:int, DateTimeField[0..4]:datetime, TimeSpanField[0..4]:timespan
                         Table3 columns: Field[0..1] (string)
                    Functions: func, func[1..6]
                 *
                 * @static
                 * @this Kusto.UT.IntelliSenseRulesTests
                 * @memberof Kusto.UT.IntelliSenseRulesTests
                 * @param   {System.Collections.Generic.List$1}                         queryParameters      
                 * @param   {System.Collections.Generic.List$1}                         availableClusters
                 * @return  {Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity}
                 */
                GenerateKustoEntities: function (queryParameters, availableClusters) {
                    var $t, $t1;
                    if (availableClusters != null) {
                        availableClusters.add("other");
                    }

                    var result = new Kusto.Data.IntelliSense.KustoIntelliSenseClusterEntity();
                    result.Plugins = System.Array.init([($t = new Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity(), $t.Name = "test_plugin", $t)], Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity);
                    var databases = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity)).ctor();
                    result.Databases = databases;
                    var db = ($t = new Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity(), $t.Name = "Database1", $t);
                    var tables = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity)).ctor();
                    var functions = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity)).ctor();

                    db.Tables = tables;
                    db.Functions = functions;
                    databases.add(db);
                    $t = Bridge.getEnumerator(System.Array.init(["Table1", "['Table.2']"], System.String));
                    try {
                        while ($t.moveNext()) {
                            var tableName = $t.Current;
                            var table = ($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity(), $t1.Name = tableName, $t1.Columns = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity)).ctor(), $t1);
                            var columns = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity)).ctor();
                            table.Columns = columns;
                            tables.add(table);

                            for (var i = 0; i < 10; i = (i + 1) | 0) {
                                columns.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t1.Name = "Field" + (Bridge.toString(i) || ""), $t1.TypeCode = Kusto.Data.IntelliSense.EntityDataType.String, $t1));
                            }

                            for (var i1 = 0; i1 < 10; i1 = (i1 + 1) | 0) {
                                columns.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t1.Name = "NumField" + (Bridge.toString(i1) || ""), $t1.TypeCode = Kusto.Data.IntelliSense.EntityDataType.Int32, $t1));
                            }

                            for (var i2 = 0; i2 < 5; i2 = (i2 + 1) | 0) {
                                columns.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t1.Name = "DateTimeField" + (Bridge.toString(i2) || ""), $t1.TypeCode = Kusto.Data.IntelliSense.EntityDataType.DateTime, $t1));
                            }

                            for (var i3 = 0; i3 < 5; i3 = (i3 + 1) | 0) {
                                columns.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t1.Name = "TimeSpanField" + (Bridge.toString(i3) || ""), $t1.TypeCode = Kusto.Data.IntelliSense.EntityDataType.TimeSpan, $t1));
                            }

                            Kusto.UT.IntelliSenseRulesTests.RegisterTableEntitiesForTest(table, columns);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    {
                        // Add table with 2 columns
                        var table1 = ($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity(), $t1.Name = "Table3", $t1.Columns = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity)).ctor(), $t1);
                        var columns1 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity)).ctor();
                        table1.Columns = columns1;
                        tables.add(table1);
                        for (var i4 = 0; i4 < 2; i4 = (i4 + 1) | 0) {
                            columns1.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseColumnEntity(), $t1.Name = "Field" + (Bridge.toString(i4) || ""), $t1.TypeCode = Kusto.Data.IntelliSense.EntityDataType.String, $t1));
                        }

                        Kusto.UT.IntelliSenseRulesTests.RegisterTableEntitiesForTest(table1, columns1);
                    }


                    if (queryParameters != null) {
                        queryParameters.add("Parameter1");
                        queryParameters.add("Parameter2");
                    }

                    // Add some functions
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func", $t1.Expression = "let func = () { Table1 | project NumField1 };", $t1.CallName = "func", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func1", $t1.Expression = "let func1 = () { Table1 | project NumField1 };", $t1.CallName = "func1", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func2", $t1.Expression = "let func2 = () { func1 };", $t1.CallName = "func2", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func3", $t1.Expression = "let func3 = () { func1 | summarize count() by NumField2};", $t1.CallName = "func3", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func4", $t1.Expression = "let func4 = () { func | extend NumField3 = 1};", $t1.CallName = "func4", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func5", $t1.Expression = "let func5 = (x:datetime) { func | extend NumField3 = 1};", $t1.CallName = "func5", $t1));
                    functions.add(($t1 = new Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity(), $t1.Name = "func6", $t1.Expression = "let func6 = () { func5(1h) };", $t1.CallName = "func6", $t1));

                    return result;
                },
                RegisterTableEntitiesForTest: function (table, columns) {
                    Kusto.UT.IntelliSenseRulesTests.s_columnMappings.set(table.Name, System.Linq.Enumerable.from(columns).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f1).ToArray(System.String));
                    Kusto.UT.IntelliSenseRulesTests.s_columnMappings.set("database('db1')." + (table.Name || ""), System.Linq.Enumerable.from(columns).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f1).ToArray(System.String));
                    Kusto.UT.IntelliSenseRulesTests.s_columnMappings.set("cluster('other').database('db2')." + (table.Name || ""), System.Linq.Enumerable.from(columns).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f1).ToArray(System.String));
                }
            }
        },
        methods: {
            IntelliSenseCommandEntitiesTest: function () {
                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | project-away X |", System.Array.init(["Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | project-rename A=X |", System.Array.init(["A", "Y", "Z"], System.String));

                this.TestPrintOperatorEntities();

                this.TestParseOperatorEntities();

                // Entities are filled in GenerateKustoEntities()
                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 | \r\n            extend y = 1\r\n            | ", System.Array.init(["x", "y"], System.String));

                this.CheckProjectedAndExtendedProperties("\r\n\r\n            // comment\r\n            Table3\r\n            | where Field1 == 'value { value'\r\n            | ", System.Array.init(["Field0", "Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("Table3\r\n            | where Field1 == 'value { value'\r\n            | ", System.Array.init(["Field0", "Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("Table3\r\n            | ", System.Array.init(["Field0", "Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("Table3\r\n            | where Field1 == 'value{value'\r\n            | ", System.Array.init(["Field0", "Field1"], System.String));


                this.CheckProjectedAndExtendedProperties("T1 \r\n            | summarize by key1, key2\r\n            | ", System.Array.init(["key1", "key2"], System.String));

                this.TestSummarizeOperationsOverFunctions();

                this.CheckProjectedAndExtendedProperties("T1 \r\n            | project x1, x2, key\r\n            | join \r\n              (T2 | project y1, y2, key) on key \r\n            | extend e1 = 1\r\n            | ", System.Array.init(["x1", "x2", "y1", "y2", "key", "e1"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoSources | project Source, Data | join (KustoLogs | summarize max(ActivityID) by Source, Timestamp ) on Source |", System.Array.init(["Source", "Data", "max_ActivityID", "Timestamp"], System.String));


                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1\r\n            | extend y = x + 1, z = x + 2\r\n            | summarize val1 = sum(x)/sum(z), sumOfY=sum(y), sumOfZ =sum(z) |", System.Array.init(["val1", "sumOfY", "sumOfZ"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 | ", System.Array.init(["x"], System.String));

                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx |", System.Array.init(["Field1", "Field2", "Field3", "Duration", "Field4"], System.String));

                this.TestArgMinMaxEntities();

                this.TestProjectAssignmentEntities();

                this.TestProjectedAwayEntities();

                this.TestProjectedRenameEntities();

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | reduce by X |", System.Array.init(["Pattern", "Count"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | mvexpand myCount=range(1, 2, 3) |", System.Array.init(["myCount", "X", "Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize myCount=count(X), mySum= sum(Y), myCount2 = count() by bin(Z, 10min), X |", System.Array.init(["myCount", "mySum", "myCount2", "Z", "X"], System.String));
                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(), makelist(ClusterName), makeset(SubscriptionId) by LogicalServerName | ", System.Array.init(["count_", "list_ClusterName", "set_SubscriptionId", "LogicalServerName"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(), any(ClusterName), any(SubscriptionId) by LogicalServerName, AppName, database_id, bin(TIMESTAMP, time(10m)) | ", System.Array.init(["count_", "any_ClusterName", "any_SubscriptionId", "LogicalServerName", "AppName", "database_id", "TIMESTAMP"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) by bin(Z, 10min), X |", System.Array.init(["count_X", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) by bin (Z, 10min), X |", System.Array.init(["count_X", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize A=countif(X), countif(Y) by bin (Z, 10min), X |", System.Array.init(["A", "countif_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize A=sumif(X, pred1), sumif(Y, pred2) by bin (Z, 10min), X |", System.Array.init(["A", "sumif_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize percentile(X, 10), percentiles(Y, 10, 20, 99.9, 1E-8) |", System.Array.init(["percentile_X_10", "percentile_Y_10", "percentile_Y_20", "percentile_Y_99_9", "percentile_Y_1E_8"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize percentile(X / 99, 10), percentiles(Y * 1000, 10, 20, 99.9, 1E-8) |", System.Array.init(["percentile_X_10", "percentile_Y_10", "percentile_Y_20", "percentile_Y_99_9", "percentile_Y_1E_8"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | join (Table2 | extend FieldA=1, FieldB=22 |", System.Array.init(["FieldA", "FieldB"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | join (Table2 | extend FieldA=1, FieldB=22 | project FieldA | filter X", System.Array.init(["FieldA"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project Field1, Field2, Field3\r\n            | join (\r\n            Table2 | project Field1, Field2, Field3 ) on ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | extend Y=5 | project Field1, Field2, Field3, Y\r\n            | join (\r\n            Table2 | extend Y=4 | project Field1, Field2, Field3, Y  ) on ", System.Array.init(["Field1", "Field2", "Field3", "Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | extend X=5 | project X, timestamp, Field1\r\n                        | join (\r\n                        Table2 | make-series X=sum(Y) on timestamp in range(datetime(3000-01-01),datetime(3000-01-02),1h) by Field1) on ", System.Array.init(["X", "timestamp", "Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | make-series X=sum(Y) on timestamp in range(datetime(3000-01-01),datetime(3000-01-02),1h) by Field1\r\n                        | join (\r\n                        Table2 | extend X=5 | project X, timestamp, Field1) on ", System.Array.init(["X", "timestamp", "Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y | summarize count(X), sum(Y)", System.Array.init(["X", "Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(X), sum(Y) |", System.Array.init(["count_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(X), sum(Y) | project count_Z", System.Array.init(["count_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(X), sum(Y) | project count_Z |", System.Array.init(["count_Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | top-nested 5 of P by count(X) asc, top-nested 6 of Q by sum(Y) desc, top-nested 6 of W by avg(I)|", System.Array.init(["aggregated_P", "aggregated_Q", "aggregated_W", "P", "Q", "W"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | top-nested 5 of P by count(X) asc, top-nested 6 of Q by AggregatedSumY = sum(Y) desc, top-nested 6 of W by AggregatedAvgI = avg(I)|", System.Array.init(["aggregated_P", "AggregatedSumY", "AggregatedAvgI", "P", "Q", "W"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | top-nested 5 of P by count(X) asc, top-nested 6 of Q by AggregatedSumY = sum(Y) desc, top-nested 6 of W by AggregatedAvgI = avg(I) asc, top-nested 5 of M by count(C)|", System.Array.init(["aggregated_P", "AggregatedSumY", "AggregatedAvgI", "aggregated_M", "P", "Q", "W", "M"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | top-nested 5 of A by count() | ", System.Array.init(["aggregated_A", "A"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) | ", System.Array.init(["count_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) by Z | ", System.Array.init(["count_X", "sum_Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) by Z, X | ", System.Array.init(["count_X", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(), sum(Y) by Z, X | ", System.Array.init(["count_", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize count(X), sum(Y) | extend FieldA = x | ", System.Array.init(["count_X", "sum_Y", "FieldA"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(X), dcount(Y) | project dcount_Y |", System.Array.init(["dcount_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y | summarize countif(X), sum(Y)", System.Array.init(["X", "Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize countif(X), sum(Y) |", System.Array.init(["countif_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize countif(X), sum(Y) | project count_Z", System.Array.init(["countif_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize sumif(X,Y), sum(Y) | project count_Z", System.Array.init(["sumif_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize countif(X), sum(Y) | project count_Z |", System.Array.init(["count_Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize countif(X), sum(Y) | ", System.Array.init(["countif_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize sumif(X,Y), sum(Y) | ", System.Array.init(["sumif_X", "sum_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize countif(X), sum(Y) by Z | ", System.Array.init(["countif_X", "sum_Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize sumif(X, Y), sum(Y) by Z | ", System.Array.init(["sumif_X", "sum_Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize countif(X), sum(Y) by Z, X | ", System.Array.init(["countif_X", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize sumif(X, Y), sum(Y) by Z, X | ", System.Array.init(["sumif_X", "sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize countif(X), sum(Y) | extend FieldA = x | ", System.Array.init(["countif_X", "sum_Y", "FieldA"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize sumif(X, Y), sum(Y) | extend FieldA = x | ", System.Array.init(["sumif_X", "sum_Y", "FieldA"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize countif(X), dcount(Y) | project dcount_Y |", System.Array.init(["dcount_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize any(X), any(Y) | project any_Y |", System.Array.init(["any_Y"], System.String));


                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | project Duration, Field4  ", System.Array.init(["Field1", "Field2", "Field3", "Duration", "Field4"], System.String));

                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | project Duration, Field4 | ", System.Array.init(["Duration", "Field4"], System.String));


                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 | extend Duration=Field2 - Field3, Field1=xxxx | \r\n            join ( xxxx | project X | extend Y=X, Z=X) on XXX \r\n            join ( yyyy | project Field1, Field2, Field3 | extend Duration=Field2 - Field3, FieldX=xxxx |", System.Array.init(["Field1", "Field2", "Field3", "Duration", "FieldX"], System.String));

                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 | extend Duration=Field2 - Field3, Field1=xxxx | \r\n            join ( xxxx | project X | extend Y=X, Z=X) on XXX \r\n            join ( yyyy | project Field1, Field2, Field3 | extend Duration=Field2 - Field3, FieldX=xxxx ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | filter EventText like 'Gateway.ExecuteQuery'\r\n            | filter Source like 'KUSKUS' or Source like 'ONESI-PROD' or Source like 'IPEPROD'\r\n            | extend op=extract('Gateway.ExecuteQuery:.*(join|summarize|filter)', 1, EventText) , is_Join=extract('Gateway.ExecuteQuery:.*(join)', 1, EventText) \r\n            | extend is_Filter=extract('Gateway.ExecuteQuery:.*(filter)', 1, EventText) \r\n            | filter ", System.Array.init(["op", "is_Join", "is_Filter"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=Field1 - ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=Field1 + ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=Field1 / ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=Field1 * ", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, Field2, Field3\r\n            | extend op=Field1 + Field2, op2=", System.Array.init(["Field1", "Field2", "Field3"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | filter EventText like 'Gateway.ExecuteQuery'\r\n\r\n            | extend op=extract('Gateway.ExecuteQuery:.*(join|summarize|filter)', 1, EventText) \r\n            | extend is_Join=extract('Gateway.ExecuteQuery:.*(join)', 1, EventText) \r\n            | extend is_Filter=extract('Gateway.ExecuteQuery:.*(filter)', 1, EventText) \r\n            | filter ", System.Array.init(["op", "is_Join", "is_Filter"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | filter EventText like 'Gateway.ExecuteQuery'\r\n\r\n            | extend op=extract('Gateway.ExecuteQuery:.*(join|summarize|filter)', 1, EventText) \r\n            | extend is_Join=extract('Gateway.ExecuteQuery:.*(join)', 1, EventText) \r\n            | extend is_Filter=extract('Gateway.ExecuteQuery:.*(filter)', 1, EventText) \r\n            | filter ", System.Array.init(["op", "is_Join", "is_Filter"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | make-series sum(Y) default=0 on Z in range(datetime(3000-01-01),datetime(3000-01-02),1h) by X |", System.Array.init(["sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | make-series sum_of_y=sum(Y) default= 0 on Z in range(datetime(3000-01-01),datetime(3000-01-02),1h) by X |", System.Array.init(["sum_of_y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | make-series sum_of_y=sum(Y) on Z in range(datetime(3000-01-01),datetime(3000-01-02),1h) |", System.Array.init(["sum_of_y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | make-series sum(Y) on Z in range(datetime(3000-01-01),datetime(3000-01-02),1h) by X |", System.Array.init(["sum_Y", "Z", "X"], System.String));

                this.CheckProjectedAndExtendedProperties(" Table1\r\n                | sample-distinct 10 of Field1 |\r\n                ", System.Array.init(["Field1"], System.String));

                this.CheckProjectedAndExtendedProperties(" Table1\r\n                | sample-distinct 10 of log2(Field1) |\r\n                ", System.Array.init(["Field1"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, series_stats(Field2), (rs, s)=series_fit_line(Field3) |\r\n                ", System.Array.init(["Field1", "series_stats_Field2_min", "series_stats_Field2_min_idx", "series_stats_Field2_max", "series_stats_Field2_max_idx", "series_stats_Field2_avg", "series_stats_Field2_stdev", "series_stats_Field2_variance", "rs", "s"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, series_stats(Field2), (a,b,c)=series_fit_line(Field3) |\r\n                ", System.Array.init(["Field1", "series_stats_Field2_min", "series_stats_Field2_min_idx", "series_stats_Field2_max", "series_stats_Field2_max_idx", "series_stats_Field2_avg", "series_stats_Field2_stdev", "series_stats_Field2_variance", "a", "b", "c"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | extend Field1, (min, min_idx)=series_stats(Field2), (rs, s)=series_fit_line(Field3), mundane=sqrt(Field3) |\r\n                ", System.Array.init(["Field1", "min", "min_idx", "rs", "s", "mundane"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | extend Field1, series_stats(Field2), series_fit_line(Field3), mundane=sqrt(Field3) |\r\n            ", System.Array.init(["Field1", "series_stats_Field2_min", "series_stats_Field2_min_idx", "series_stats_Field2_max", "series_stats_Field2_max_idx", "series_stats_Field2_avg", "series_stats_Field2_stdev", "series_stats_Field2_variance", "series_fit_line_Field3_rsquare", "series_fit_line_Field3_slope", "series_fit_line_Field3_variance", "series_fit_line_Field3_rvariance", "series_fit_line_Field3_interception", "series_fit_line_Field3_line_fit", "mundane"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, series_fit_2lines(Field2), mundane=sqrt(Field3) |\r\n                ", System.Array.init(["Field1", "series_fit_2lines_Field2_rsquare", "series_fit_2lines_Field2_split_idx", "series_fit_2lines_Field2_variance", "series_fit_2lines_Field2_rvariance", "series_fit_2lines_Field2_line_fit", "series_fit_2lines_Field2_right_rsquare", "series_fit_2lines_Field2_right_slope", "series_fit_2lines_Field2_right_interception", "series_fit_2lines_Field2_right_variance", "series_fit_2lines_Field2_right_rvariance", "series_fit_2lines_Field2_left_rsquare", "series_fit_2lines_Field2_left_slope", "series_fit_2lines_Field2_left_interception", "series_fit_2lines_Field2_left_variance", "series_fit_2lines_Field2_left_rvariance", "mundane"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | project Field1, series_stats(Field2), (min, min_idx)=series_stats(Field2) |\r\n                ", System.Array.init(["Field1", "series_stats_Field2_min", "series_stats_Field2_min_idx", "series_stats_Field2_max", "series_stats_Field2_max_idx", "series_stats_Field2_avg", "series_stats_Field2_stdev", "series_stats_Field2_variance", "min", "min_idx"], System.String));
            },
            IntelliSenseCommandEntities_EscapedNamesTest: function () {
                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 \r\n| project a.b, a.[c], a.[c][d], a.[c].[e] |", System.Array.init(["a_b", "a_c", "a_c_d", "a_c_e"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 \r\n| project a.['b'], a.['c'], a.[\"c\"][d], a.['c'].[\"e\"] |", System.Array.init(["a_b", "a_c", "a_c_d", "a_c_e"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 \r\n| project a.['[b]'], a.['[c]'], a.[\"[c]\"][d], a.['[c]'].[\"[e]\"] |", System.Array.init(["['a_[b]']", "['a_[c]']", "['a_[c]_d']", "['a_[c]_[e]']"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 \r\n| project a.['b c'] |", System.Array.init(["a_b_c"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize percentile(X / 99, 10), percentiles(Y * 1000, 10, 20, 99.9, 1E-8) |", System.Array.init(["percentile_X_10", "percentile_Y_10", "percentile_Y_20", "percentile_Y_99_9", "percentile_Y_1E_8"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 \r\n| extend ['abc def'] = 1\r\n| summarize min(['abc def']), max(['abc def']), avg(['abc def']) |", System.Array.init(["['min_abc def']", "['max_abc def']", "['avg_abc def']"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 | extend ['abc def'] = 1 | ", System.Array.init(["x", "['abc def']"], System.String));
                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1 | project ['abc def'] = 1 | ", System.Array.init(["['abc def']"], System.String));
            },
            IntelliSenseCommandEntities_FindTest: function () {
                this.TestEntitiesForFindFilterAndProjection("find where ", System.Array.init(["Field0", "Field1", "*"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (*) where ", System.Array.init(["Field0", "Field1", "*"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1) where ", System.Array.init(["*"], System.String), true);

                this.TestEntitiesForFindFilterAndProjection("find in (['Table.2']) where ", System.Array.init(["*"], System.String), true);

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, ['Table.2']) where ", System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).intersect(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("['Table.2']")).concat(System.Array.init(["*"], System.String)).ToArray(System.String));

                //TODO: Added AsEnumerable() to avoid the following error: 'Array' does not contain a definition for 'ToArray' and no extension method 'ToArray' accepting a first argument of type 'Array' could be found
                //TODO: Upgrade Bridge.NET compiler to a newer version to resolve this issue
                this.TestEntitiesForFindFilterAndProjection("find in (database('*').Table1) where ", System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).concat(System.Array.init(["*"], System.String)).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (database('*').*1, *1) where ", System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).concat(System.Array.init(["*"], System.String)).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, Table2) where ", System.Array.init(["*"], System.String));


                this.TestEntitiesForFindFilterAndProjection("find where 'abc' project ", System.Array.init(["Field0", "Field1", "pack(*)"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (*) where Field0 == \"abc\" project ", System.Array.init(["Field0", "Field1", "pack(*)"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1) where Field0 == \"abc\" project ", System.Array.init(["pack(*)"], System.String), true);

                this.TestEntitiesForFindFilterAndProjection("find in (['Table.2']) where Field0 == \"abc\" project ", System.Array.init(["pack(*)"], System.String), true);

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, ['Table.2']) where Field0 == \"abc\" project ", System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).intersect(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("['Table.2']")).concat(System.Array.init(["pack(*)"], System.String)).ToArray(System.String));

                //TODO: Added AsEnumerable() to avoid the following error: 'Array' does not contain a definition for 'ToArray' and no extension method 'ToArray' accepting a first argument of type 'Array' could be found
                //TODO: Upgrade Bridge.NET compiler to a newer version to resolve this issue
                this.TestEntitiesForFindFilterAndProjection("find in (database('*').Table1) where Field0 == \"abc\" project ", System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).concat(System.Array.init(["pack(*)"], System.String)).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, Table2) where Field0 == \"abc\" project ", System.Array.init(["pack(*)"], System.String));


                this.TestEntitiesForFindFilterAndProjection("find 'abc' project Field0, Field1\r\n            | ", System.Array.init(["source_", "Field0", "Field1"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find 'abc' project Field0, Field1, pack(*)\r\n            | ", System.Array.init(["source_", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find 'abc' project Field0, pack(*)\r\n            | ", System.Array.init(["source_", "Field0", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find 'abc' project pack(*)\r\n            | ", System.Array.init(["source_", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find where 'abc' project Field0, Field1\r\n            | ", System.Array.init(["source_", "Field0", "Field1"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find where 'abc' project Field0, Field1, pack(*)\r\n            | ", System.Array.init(["source_", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find where 'abc' project pack(*)\r\n            | ", System.Array.init(["source_", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find withsource=Source where 'abc' project Field0, Field1\r\n            | ", System.Array.init(["Source", "Field0", "Field1"], System.String));


                this.TestEntitiesForFindFilterAndProjection("find withsource=SourceName in (*) where 'abc' \r\n| ", System.Array.init(["SourceName", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find withsource=SourceName in (database('db1').*, *) where 'abc'\r\n| ", System.Array.init(["SourceName", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find withsource=SourceName in (database('db1').*) where 'abc'\r\n| ", System.Array.init(["SourceName", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find withsource=SourceName in (Table1) where 'abc'\r\n| ", System.Linq.Enumerable.from(System.Array.init(["SourceName", "pack_"], System.String)).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find 'abc'\r\n| ", System.Array.init(["source_", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1) where 'abc'\r\n| ", System.Linq.Enumerable.from(System.Array.init(["source_", "pack_"], System.String)).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, ['Table.2']) where 'abc'\r\n| ", System.Linq.Enumerable.from(System.Array.init(["source_", "pack_"], System.String)).union(System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).intersect(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("['Table.2']"))).ToArray(System.String));

                this.TestEntitiesForFindFilterAndProjection("find withsource=SourceName where 'abc'\r\n| ", System.Array.init(["SourceName", "Field0", "Field1", "pack_"], System.String));

                this.TestEntitiesForFindFilterAndProjection("find in (Table1, database('db1').Table1) where 'abc'\r\n| ", System.Linq.Enumerable.from(System.Array.init(["source_", "pack_"], System.String)).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).ToArray(System.String));
            },
            IntelliSenseCommandEntities_SearchTest: function () {
                var expectedOptions;
                var unionOfAllColumns = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("['Table.2']")).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3"));
                var additionalOptions = System.Linq.Enumerable.from((System.Array.init(["\"\"", "*"], System.String))).union(Kusto.Data.IntelliSense.CslCommandParser.SortedExtendFunctions);
                var additionalOptionsIncludingIn = additionalOptions.concat(System.Array.init(["in"], System.String));
                var additionalOptionsIncludingKind = additionalOptionsIncludingIn.concat(System.Array.init(["kind="], System.String));

                expectedOptions = unionOfAllColumns.union(additionalOptionsIncludingKind).ToArray(System.String);
                this.TestOptionsForSearch("search ", expectedOptions);

                expectedOptions = unionOfAllColumns.union(additionalOptionsIncludingIn).ToArray(System.String);
                this.TestOptionsForSearch("search kind=case_sensitive ", expectedOptions);

                expectedOptions = unionOfAllColumns.union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("Table3 | search 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (Table3) 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("['Table.2']")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (Table3,['Table.2']) 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table1")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (T*) 'abc' and ", expectedOptions);

                expectedOptions = unionOfAllColumns.union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (*) 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (database('db1').Table3) 'abc' and ", expectedOptions);

                expectedOptions = System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable("Table3")).union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (database('db1').T*3) 'abc' and ", expectedOptions);

                expectedOptions = unionOfAllColumns.union(additionalOptions).ToArray(System.String);
                this.TestOptionsForSearch("search in (database('db1').T*) 'abc' and ", expectedOptions);
            },
            TestOptionsForSearch: function (command, expectedOptions) {
                var context = this.GetQueryContext(command);
                this.ValidateSearchRules(command, context, expectedOptions);
            },
            ValidateSearchRules: function (command, tableContext, expectedOptions) {
                var rule = { };

                if (!Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule(command, tableContext, Kusto.Data.IntelliSense.RuleKind.YieldPostSearchOptions, rule) && !Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule(command, tableContext, Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions, rule) && !Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule(command, tableContext, Kusto.Data.IntelliSense.RuleKind.YieldPostSearchKindOptions, rule)) {
                    Kusto.UT.IntelliSenseRulesTests.Assert.Fail(System.String.format("No matching search rule for query '{0}'", [command]));
                }

                var actualOptions = System.Linq.Enumerable.from(rule.v.GetOptions(tableContext)).toList(System.String);
                Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command, expectedOptions, actualOptions);
            },
            TestProjectAssignmentEntities: function () {
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | project x=1 |\r\n                ", System.Array.init(["x"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | project y=xxxx+1, z= 33, x=xxxx/2 |\r\n                ", System.Array.init(["x", "y", "z"], System.String));
            },
            TestProjectedAwayEntities: function () {
                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | project-away X |", System.Array.init(["Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | mvexpand myCount=range(1, 2, 3) | project-away Y |", System.Array.init(["myCount", "X", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project X, Y, Z | summarize myCount=count(X), mySum= sum(Y), myCount2 = count() by bin(Z, 10min), X | project-away Z |", System.Array.init(["myCount", "mySum", "myCount2", "X"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project-away ClusterName |summarize count(), any(SubscriptionId) by LogicalServerName, AppName, database_id, bin(TIMESTAMP, time(10m)) | ", System.Array.init(["count_", "any_SubscriptionId", "LogicalServerName", "AppName", "database_id", "TIMESTAMP"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project-away X | summarize sum(Y) by bin(Z, 10min)|", System.Array.init(["sum_Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | join (Table2 | extend FieldA=1, FieldB=22 | project-away FieldB | filter X", System.Array.init(["FieldA"], System.String));


                this.CheckProjectedAndExtendedProperties("Table1 | summarize count(X), dcount(Y) | project-away count_X |", System.Array.init(["dcount_Y"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 | summarize any(X), any(Y) | project-away any_Y |", System.Array.init(["any_X"], System.String));


                this.CheckProjectedAndExtendedProperties("| project Field1, Field2, Field3 \r\n            | extend Duration=Field2 - Field3, Field4=xxxx \r\n            | project-away Duration, Field4 | ", System.Array.init(["Field1", "Field2", "Field3"], System.String));


                this.CheckProjectedAndExtendedProperties("KustoLogs \r\n            | filter EventText like 'Gateway.ExecuteQuery'\r\n            | extend fake=1\r\n            | extend op=extract('Gateway.ExecuteQuery:.*(join|summarize|filter)', 1, EventText) \r\n            | extend is_Join=extract('Gateway.ExecuteQuery:.*(join)', 1, EventText) \r\n            | extend is_Filter=extract('Gateway.ExecuteQuery:.*(filter)', 1, EventText) \r\n            | project-away fake |", System.Array.init(["op", "is_Join", "is_Filter"], System.String));
            },
            TestProjectedRenameEntities: function () {
                this.CheckProjectedAndExtendedProperties("Table1 \r\n| project X, Y, Z \r\n| project-rename A=X \r\n| ", System.Array.init(["A", "Y", "Z"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1 \r\n| project X, Y, Z \r\n| project-rename B=Z, A=X \r\n| ", System.Array.init(["A", "Y", "B"], System.String));
            },
            TestPrintOperatorEntities: function () {
                this.CheckProjectedAndExtendedProperties("print Message = 'xyz' |", System.Array.init(["Message"], System.String));
            },
            TestParseOperatorEntities: function () {
                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1\r\n                | extend str = ''string''\r\n                | parse str with * \"s\" substr * |", System.Array.init(["x", "str", "substr"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1\r\n                | extend str = ''string''\r\n                | parse str with * \"s\" substr 'abdc' substr2:string * |", System.Array.init(["x", "str", "substr", "substr2"], System.String));

                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1\r\n                | extend str = ''string''\r\n                | parse str with * \"s\" substr 'abdc' substr2:string * num1:int |", System.Array.init(["x", "str", "substr", "substr2", "num1"], System.String));
            },
            TestArgMinMaxEntities: function () {
                // argmin tests
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmin(c0, c1, c2) |\r\n                ", System.Array.init(["min_c0", "min_c0_c1", "min_c0_c2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmin(c0+1d, c1/c2, c2+c3) |\r\n                ", System.Array.init(["min_", "min__arg1", "min__arg2"], System.String));

                // argmax tests
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmax(c0, c1, c2) by group1, group2 |\r\n                ", System.Array.init(["max_c0", "max_c0_c1", "max_c0_c2", "group1", "group2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmax(c0+1d, c1/c2, c2+c3) |\r\n                ", System.Array.init(["max_", "max__arg1", "max__arg2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | project column1, column2, column3, xyz\r\n                | summarize argmin(column1, *) by column3, column2 |\r\n                ", System.Array.init(["min_column1", "min_column1_xyz", "column3", "column2"], System.String), System.Array.init(["column1", "column2", "column3", "xyz"], System.String));


                this.CheckProjectedAndExtendedProperties("Table1 \r\n                | project column1, column2, column3, xyz\r\n                | summarize argmin(column1, [*col*]) by column3 |\r\n                ", System.Array.init(["min_column1", "min_column1_column2", "column3"], System.String), System.Array.init(["column1", "column2", "column3", "xyz"], System.String));

                // arg_min tests
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_min(c0, c1, c2) |\r\n                ", System.Array.init(["c0", "c1", "c2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_min(c0+1d, c1/c2, c2+c3) |\r\n                ", System.Array.init(["min_", "min__arg1", "min__arg2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_min(c0+1d, c1/c2, c2) |\r\n                ", System.Array.init(["min_", "min__arg1", "c2"], System.String));

                // arg_max tests
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_max(c0, c1, c2) by group1, group2 |\r\n                ", System.Array.init(["c0", "c1", "c2", "group1", "group2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_max(c0+1d, c1/c2, c2+c3) |\r\n                ", System.Array.init(["max_", "max__arg1", "max__arg2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize arg_max(c0, c1/c2, c2+c3, c2) |\r\n                ", System.Array.init(["c0", "max_c0_arg1", "max_c0_arg2", "c2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | project column1, column2, column3, xyz\r\n                | summarize arg_min(column1, *) by column3, column2 |\r\n                ", System.Array.init(["column1", "xyz", "column3", "column2"], System.String), System.Array.init(["column1", "column2", "column3", "xyz"], System.String));


                this.CheckProjectedAndExtendedProperties("Table1 \r\n                | project column1, column2, column3, xyz\r\n                | summarize arg_min(column1, [*col*]) by column3 |\r\n                ", System.Array.init(["column1", "column2", "column3"], System.String), System.Array.init(["column1", "column2", "column3", "xyz"], System.String));
            },
            TestSummarizeOperationsOverFunctions: function () {
                this.CheckProjectedAndExtendedProperties("range x from 1 to 1 step 1\r\n| extend y = x + 1, z = x + 2\r\n| summarize val1 = sum(x)/sum(z), sumOfY=sum(y), sumOfZ =sum(z) |", System.Array.init(["val1", "sumOfY", "sumOfZ"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | project column1, column2, column3, xyz\r\n                | summarize argmin(column1, *) by column3, column2 |\r\n                ", System.Array.init(["min_column1", "min_column1_xyz", "column3", "column2"], System.String), System.Array.init(["column1", "column2", "column3", "xyz"], System.String));

                // argmax tests
                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmax(c0, c1, c2) by group1, group2 |\r\n                ", System.Array.init(["max_c0", "max_c0_c1", "max_c0_c2", "group1", "group2"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoSources | project Source, Data | join (KustoLogs | summarize max(ActivityID) by Source, Timestamp ) on Source |", System.Array.init(["Source", "Data", "max_ActivityID", "Timestamp"], System.String));

                this.CheckProjectedAndExtendedProperties("KustoSources | project Source, Data | join (KustoLogs | summarize max(strlen(ActivityID)) by Source, Timestamp ) on Source |", System.Array.init(["Source", "Data", "max_", "Timestamp"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmin(c0, c1, c2) |\r\n                ", System.Array.init(["min_c0", "min_c0_c1", "min_c0_c2"], System.String));


                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmin(strlen(c0), c1, c2) |\r\n                ", System.Array.init(["min_", "min__c1", "min__c2"], System.String));

                this.CheckProjectedAndExtendedProperties("Table1\r\n                | summarize argmax(strlen(c0), c1, c2) |\r\n                ", System.Array.init(["max_", "max__c1", "max__c2"], System.String));
            },
            IntelliSenseCommandEntitiesForTablesTest: function () {
                this.TestTableEntities("Table1");
                this.TestTableEntities("['Table.2']");
                this.TestTableEntities("database('db1').Table1");
                this.TestTableEntities("database('db1').['Table.2']");
                this.TestTableEntities("cluster('other').database('db2').Table1");
                this.TestTableEntities("cluster('other').database('db2').['Table.2']");
            },
            TestTableEntities: function (tableName) {
                var tableContext = Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.AnalyzeCommand$1(tableName, null).Context;

                this.CheckQueryProperties(tableName, tableContext, Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable(tableName));
            },
            IntelliSenseCommandEntitiesForClusters: function () {
                this.CheckDatabases("cluster('other').database(", System.Array.init(["'db2'"], System.String));
                this.CheckDatabases("find in (cluster('other').database(", System.Array.init(["'db2'"], System.String));
                this.CheckDatabases("find in (cluster('other').database('db2').Table1, cluster('other').database(", System.Array.init(["'db2'"], System.String));

                this.CheckDatabases("#connect cluster('other').database(", System.Array.init(["'db2'"], System.String));
            },
            IntelliSenseCommandEntitiesForGetSchemaOperator: function () {
                var expected = System.Array.init(["ColumnName", "ColumnOrdinal", "DataType", "ColumnType"], System.String);

                this.CheckProjectedAndExtendedProperties("Table1 | summarize count() by Source | getschema | project ", expected);
                this.CheckProjectedAndExtendedProperties("Table1 | union (Table2) | getschema | sort by ", expected);
                this.CheckProjectedAndExtendedProperties("Table1 | join (Table2) on ActivityId | getschema | project ", expected);
            },
            CheckDatabases: function (command, expectedFields) {
                var tableContext = this.GetQueryContext(command);
                var rule = { };
                if (!Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule(command, tableContext, Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions, rule)) {
                    Kusto.UT.IntelliSenseRulesTests.Assert.Fail(System.String.format("Couldn't derive 'databases' rule for the query '{0}'", [command]));
                }

                var existingFields = System.Linq.Enumerable.from(rule.v.GetOptions(tableContext)).toList(System.String);
                Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command, expectedFields, existingFields);
            },
            IntelliSenseCommandEntitiesUsingFunctionsTest: function () {
                // Functions are defined in IntelliSenseRulesTests.GenerateKustoEntities
                this.CheckProjectedAndExtendedProperties("func6 | ", System.Array.init(["NumField1", "NumField3"], System.String));

                this.CheckProjectedAndExtendedProperties("func4 | ", System.Array.init(["NumField1", "NumField3"], System.String));

                this.CheckProjectedAndExtendedProperties("func2 | ", System.Array.init(["NumField1"], System.String));

                this.CheckProjectedAndExtendedProperties("func1 | ", System.Array.init(["NumField1"], System.String));

                this.CheckProjectedAndExtendedProperties("func3 | extend y = 111 | ", System.Array.init(["count_", "NumField2", "y"], System.String));

            },
            IntelliSenseEntityParserTest: function () {
                {
                    var command = "argmax(PreciseTimeStamp, IsHealthy), max(iff(IsHealthy == 1, PreciseTimeStamp, datetime(\"2000-01\")))";
                    var entities = System.Array.init(["argmax:PreciseTimeStamp", "max:iff(IsHealthy == 1, PreciseTimeStamp, datetime(\"2000-01\"))"], System.String);

                    var resolvedEntities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(command);
                    var result = System.Linq.Enumerable.from(resolvedEntities).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f2).toList(System.String);
                    Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command, entities, result);
                }

                {
                    var command1 = "(Timestamp, EventText)= argmin(Timestamp, EventText), RootActivityId";
                    var entities1 = System.Array.init([":Timestamp", ":EventText", ":RootActivityId"], System.String);

                    var resolvedEntities1 = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(command1);
                    var result1 = System.Linq.Enumerable.from(resolvedEntities1).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f2).toList(System.String);
                    Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command1, entities1, result1);
                }

                {
                    var command2 = "makeset(ReportIndex), makeset(AlertId), File_Sha256)";
                    var entities2 = System.Array.init(["makeset:ReportIndex", "makeset:AlertId", ":File_Sha256"], System.String);

                    var resolvedEntities2 = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(command2);
                    var result2 = System.Linq.Enumerable.from(resolvedEntities2).select($asm.$.Kusto.UT.IntelliSenseRulesTests.f2).toList(System.String);
                    Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command2, entities2, result2);
                }
            },
            GetQueryContext: function (command) {
                return Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.AnalyzeCommand$1(command, null).Context;
            },
            CheckQueryProperties: function (command, tableContext, expectedFields) {
                var rule = { };

                if (!Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule(command, tableContext, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind, rule) && !Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule((command || "") + " project ", tableContext, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind, rule) && !Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.TryMatchSpecificRule((command || "") + " | project ", tableContext, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject, rule)) {
                    Kusto.UT.IntelliSenseRulesTests.Assert.Fail(System.String.format("Couldn't derive 'find .. where', 'find .. where .. project' and 'project' rules for the query '{0}'", [command]));
                }

                var existingFields = System.Linq.Enumerable.from(rule.v.GetOptions(tableContext)).toList(System.String);
                Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command, expectedFields, existingFields);
            },
            CheckProjectedAndExtendedProperties: function (command, expectedFields, existingFields) {
                var $t;
                if (existingFields === void 0) { existingFields = null; }
                $t = Bridge.getEnumerator(System.Array.init([true, false], System.Boolean));
                try {
                    while ($t.moveNext()) {
                        var flatten = $t.Current;
                        if (!System.String.contains(command,"//")) {
                            if (flatten) {
                                command = System.String.replaceAll(System.String.replaceAll(command, String.fromCharCode(13), String.fromCharCode(32)), String.fromCharCode(10), String.fromCharCode(32));
                            } else {
                                command = System.String.replaceAll(System.String.replaceAll(command, String.fromCharCode(13), String.fromCharCode(32)), String.fromCharCode(10), String.fromCharCode(32));
                            }
                        }

                        if (existingFields == null) {
                            var analyzedCommand = Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.AnalyzeCommand$1(command, null);
                            existingFields = Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable(analyzedCommand.Context.Context);
                        }

                        var entititesList = new (System.Collections.Generic.List$1(System.String)).ctor();
                        var finalEntitiesList = new (System.Collections.Generic.List$1(System.String)).ctor();
                        var entitiesResolveResult = Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.ResolveEntitiesFromCommand(command, entititesList, existingFields);
                        switch (entitiesResolveResult) {
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities: 
                                finalEntitiesList.AddRange(entititesList);
                                break;
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None: 
                                if (existingFields != null) {
                                    finalEntitiesList.AddRange(existingFields);
                                }
                                break;
                            case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities: 
                                if (existingFields != null) {
                                    finalEntitiesList.AddRange(existingFields);
                                }
                                finalEntitiesList.AddRange(entititesList);
                                break;
                        }

                        Kusto.UT.IntelliSenseRulesTests.ValidateEntities(command, expectedFields, finalEntitiesList);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }},
            TestEntitiesForFindFilterAndProjection: function (command, columns, isAdditionalColumns) {
                if (columns === void 0) { columns = null; }
                if (isAdditionalColumns === void 0) { isAdditionalColumns = false; }
                var tableContext = this.GetQueryContext(command);

                //TODO: Added AsEnumerable() to avoid the following error: 'Array' does not contain a definition for 'ToArray' and no extension method 'ToArray' accepting a first argument of type 'Array' could be found
                //TODO: Upgrade Bridge.NET compiler to a newer version to resolve this issue
                this.CheckQueryProperties(command, tableContext, isAdditionalColumns ? (columns == null ? Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable(tableContext.Context) : System.Linq.Enumerable.from(Kusto.UT.IntelliSenseRulesTests.GetColumnsOfTable(tableContext.Context)).concat(columns).ToArray(System.String)) : columns);
            },
            IntelliSenseFilterTest: function () {
                this.TestFilter("filter", "like");
                this.TestFilter("filter", "contains");
                this.TestFilter("filter", "notcontains");
                this.TestFilter("where", "like");
                this.TestFilter("where", "contains");
                this.TestFilter("where", "notcontains");
                this.TestFilter("where", "==");
                this.TestFilter("where", "!=");
            },
            TestFilter: function (filterKeyword, containsKeyword) {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0}", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0}    ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldStringComparisonOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} FieldX ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1}", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' and ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' and Field2 ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldStringComparisonOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' or ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' or Field2 ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldStringComparisonOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' |", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1 {1} 'xxx' | ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldNumericComparisonOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 ==", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 == 10 and ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 == 10 and NumField1 ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldNumericComparisonOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 == 10 or ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} NumField1 == 10 or NumField1 ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldNumericComparisonOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | xxx Field1, Field2 | {0} ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | xxx Field1, Field2 {0} ", [filterKeyword]), Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | {0} Field1\r\n    {1}               \r\n    'dddd'  ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Table1 | filter {0}\r\n    {1}               \r\n    'dddd'  \r\n    ", [filterKeyword, containsKeyword]), Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseRangeTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv ", Kusto.Data.IntelliSense.RuleKind.YieldRangeFromOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) ", Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to datetime(2013-01-01)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to datetime(2013-01-01) ", Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToStepOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to datetime(2013-01-01) st", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to datetime(2013-01-01) step 123", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from datetime(2012-01-01) to datetime(2013-01-01) step 123 ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 ", Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to 456", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to 456 ", Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToStepOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to 456 st", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to 456 step 123", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("range ziv from 123.4 to 456 step 123 ", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDatabaseTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("database", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(" database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("database('xyz').", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForRemoteQueryOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').database", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').database('xyz').", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForRemoteQueryOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').database('xyz').xx", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (cluster('foo').database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (cluster('foo').database('db1').Table1, database(", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseClusterTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster(", Kusto.Data.IntelliSense.RuleKind.YieldClusterNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(" cluster(", Kusto.Data.IntelliSense.RuleKind.YieldClusterNamesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').cluster", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').cluster(", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').database('some')", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("cluster('foo').", Kusto.Data.IntelliSense.RuleKind.YieldDatabaseFunctionOption));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSummarizeTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize res", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize res=", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize res =", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize res= ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize res=count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize countif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize dcount(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize dcountif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize max(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize min(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize avg(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize stdev(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize variance(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum( ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sumif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) +", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) + ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) / ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) - ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) * ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+max(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+min(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+avg(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+any(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+sum(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+sum( ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+sum(Filed1)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1)+", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) +", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) + ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) / ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) - ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) * ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) - ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1 ,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1 , ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | count by ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by Feild1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by Feild1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by Feild1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by iff(1==0, Feild1, Field2),", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize by iff(1==0, Feild1, Field2), ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize count() by bin(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize count() by bin( ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize count() by bin(Field1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize count() by bin(Field1, ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize sum(Filed1), count(Filed2) by Field1, Filed2 | summarize count() by bin(Field1, 1), ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentile(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentile(Field1,", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentiles(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentiles(Field1,", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentilew(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentilew(Field1,", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentilesw(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize percentilesw(Field1,", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize arg_min(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize arg_max(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize arg_min(Field1,", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | summarize arg_max(Field1,", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | xxx Field1, Field2 | summarize ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | xxx Field1, Field2 summarize ", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseMakeSeriesTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));

                // aggregation options
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series res", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series res=", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series res =", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series res= ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series 100*", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= 100*", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions));

                // column options
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series res=count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series count(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series countif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series dcount(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series dcountif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series max(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series min(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series avg(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series stdev(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series variance(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum( ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sumif(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1)", Kusto.Data.IntelliSense.RuleKind.None));

                // Both 'on' and 'default=' options
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x = sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=100*sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= sum(Filed1) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1), avg(field2) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1), x=avg(field2) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1), avg(field2) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= sum(Filed1)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1), avg(field2)", Kusto.Data.IntelliSense.RuleKind.None));

                // only 'on' option
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=10 ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default=10 ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x = sum(Filed1) default=10 ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x = sum(Filed1) default=10,y=sum(field2) default=10 ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x = sum(Filed1), y=sum(field2) default=10 ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x = sum(Filed1) default=10,y=sum(field2) default=10", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=10", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default=", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default= ", Kusto.Data.IntelliSense.RuleKind.None));

                // column options
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default=0, y=count() on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default=0, y=count() default=0 on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on", Kusto.Data.IntelliSense.RuleKind.None));

                // 'in range' option
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default= 0 on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= sum(Filed1) default=0 on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= sum(Filed1) on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x= sum(Filed1),y=avg(duration) default=0 on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1),y=avg(duration) default=0 on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0, y=count() on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) default=0 on timestamp", Kusto.Data.IntelliSense.RuleKind.None));

                // range function
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) on timestamp in range(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) on timestamp in range(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions));

                // 'by' option
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForBy));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) on timestamp in range(ago(1d), now(),1h) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForBy));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) on timestamp in range(ago(1d), now(),1h) ", Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForBy));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series x=sum(Filed1) on timestamp in range(ago(1d), now(),1h)", Kusto.Data.IntelliSense.RuleKind.None));

                // column options
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) by field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0, y=count() on timestamp in range(ago(1d), now(),1h) by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1), y=count() default=0 on timestamp in range(ago(1d), now(),1h) by field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | make-series sum(Filed1) default=0 on timestamp in range(ago(1d), now(),1h) by field1,", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDistinctTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1 ,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1 , ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1, Field2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1, Field2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1, Field2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct Field1, Field2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct sum(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | distinct sum(Filed1), count(Field2)", Kusto.Data.IntelliSense.RuleKind.None));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseTopNestedTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOthersOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1 + ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1+ ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1+", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1 * ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by 1 - ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A) ", Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1 ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A) asc, top-nested 1 of", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1 of ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A) desc, top-nested 1 of A", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1 of A ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOthersOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1 of A by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of A by avg(A), top-nested 1 of A by ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) by ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) with others = 12 by ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) by avg(A) ", Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) with others = 15 by avg(A) ", Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) by avg(A) asc", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) by avg(A), ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-nested 1 of bin(A,1m) with others = 12 ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));

                // TODO: uncomment after fixing top-nested to support nulls first and nulls last
                //testPatterns.Add(new IntelliSenseTestPattern("Table1 | top-nested 1 of bin(A,1m) by avg(A) asc ", RuleKind.YieldNullsFirstNullsLastOptions));
                //testPatterns.Add(new IntelliSenseTestPattern("Table1 | top-nested 1 of bin(A,1m) by avg(A) asc nulls first ", RuleKind.None));
                //testPatterns.Add(new IntelliSenseTestPattern("Table1 | top-nested 1 of bin(A,1m) by avg(A) desc nulls last, ", RuleKind.YieldTopNestedKeywordOption));


                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseTopHittersTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1 + ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1+ ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1+", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1 * ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by 1 - ", Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by avg(A)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top-hitters 1 of A by avg(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseProjectTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Fiel", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, Field2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, Field2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, Field2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, Field2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project Field1, Field2 | , ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | xxx Field1, Field2 | project ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | xxx Field1, Field2 project ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= Fiel", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= Field1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= Field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= Field1, y", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project x= Field1, y=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseProjectAwayTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectAway));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Fiel", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectAway));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, Field2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, Field2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, Field2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, Field2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectAway));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-away Field1, Field2 | , ", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseProjectRenameTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Fiel", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 =", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectRename));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 = ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectRename));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 = z,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 = z, ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 = z, Feild2=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectRename));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | project-rename Field1 = z, Feild2= ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectRename));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseLimitTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | limit", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | limit ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | limit 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | limit 2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | limit 1 ", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | take", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | take ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | take 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | take 2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | take 1 ", Kusto.Data.IntelliSense.RuleKind.None));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSampleTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample 2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample 1 ", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSampleDistinctTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct 1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct 1 ", Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct 1 of", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct 1 of ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sample-distinct 1 of A", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1("\n.show ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(" .show ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show xxx | .show ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show principal ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowPrincipalCommandOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter policies ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMultiplePoliciesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete policies ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteMultiplePoliciesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseClientDirectivesTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("#", Kusto.Data.IntelliSense.RuleKind.YieldClientDirectivesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("#connect", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("#connect ", Kusto.Data.IntelliSense.RuleKind.YieldClientDirective_ConnectOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAppendCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".append", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".append ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set-or-append", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set-or-append ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseReplaceCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set-or-replace", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set-or-replace ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseExtendTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx ,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx-", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx/", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx*", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx +", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx -", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx /", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx *", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+ ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx- ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx/ ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx* ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx + ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx / ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx * ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=strlen(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=tostring(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=strcat(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=toupper(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy,newop1=iff(", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend newop=xx+yy | summarize count(newop) by newop bin=", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseParseOperator: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind", Kusto.Data.IntelliSense.RuleKind.YieldParseKeywordKindsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = regex ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed flags = iU ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple column ", Kusto.Data.IntelliSense.RuleKind.YieldWithKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple flags = iU column ", Kusto.Data.IntelliSense.RuleKind.YieldWithKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = regex column ", Kusto.Data.IntelliSense.RuleKind.YieldWithKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed column ", Kusto.Data.IntelliSense.RuleKind.YieldWithKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple column with ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = regex column with ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed column with ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple column with extendedCol1:", Kusto.Data.IntelliSense.RuleKind.YieldParseTypesKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = regex column with extendedCol1:", Kusto.Data.IntelliSense.RuleKind.YieldParseTypesKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed column with extendedCol1:", Kusto.Data.IntelliSense.RuleKind.YieldParseTypesKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse  column with extendedCol1:long ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = simple column with extendedCol1:long \"someDelemiter\" ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = relaxed column with extendedCol1:long | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse kind = regex column with extendedCol1:long | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with extendedCol1:long | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with * 'someDelemiter' * 'someDelemiter2' * 'SomeDelemiter3' SomeStringColumn | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with * s:", Kusto.Data.IntelliSense.RuleKind.YieldParseTypesKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with * s:int ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | parse column with * s:int 'someDelimiter' ", Kusto.Data.IntelliSense.RuleKind.YieldStarOption));


                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowTableCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowTableEntitiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents where", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents where tags", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents where tags ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityWithTagsFiltersOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents hot", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx extents hot ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx principals", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx policy", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show table xxx policy ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTablePoliciesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".show table xxx | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents where", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents where tags", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents where tags ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityWithTagsFiltersOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents hot", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show tables (xxx,yyy) extents hot ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAlterTableCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTableEntitiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTableEntitiesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDeleteTableCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteTableEntitiesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDropTableCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropTableEntitiesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAlterFunctionCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter function", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter function xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter function ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldFunctionNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter function xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterFunctionEntitiesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowDatabaseCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowDatabasePrincipalsPoliciesAndSchemaOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx principals", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx policy ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabasePoliciesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx policy", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".show database xxx principals | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx schema", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".show database xxx schema | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx extents where", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx extents where tags", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show database xxx extents where tags ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityWithTagsFiltersOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowDatabasesCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show databases", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show databases ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowDatabasesOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowClusterCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowClusterPrincipalsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster extents hot", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster extents hot ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster principals", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster policy ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldClusterPoliciesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show cluster policy", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".show cluster principals | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseShowBasicAuthUsersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show basicauth", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show basicauth ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowBasicAuthOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".show basicauth users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseIngestionDuplicateCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldIngestionDuplicationOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest into", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest into ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest into ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-ingest into ttt to h@'container'", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldIngestionDuplicationOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest into", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest into ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest into ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".dup-next-failed-ingest into ttt to h@'container'", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseColumnCommandTest: function () {
                var $t;
                var policiesCommands = System.Array.init(["show", "alter", "alter-merge", "delete"], System.String);
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                $t = Bridge.getEnumerator(policiesCommands);
                try {
                    while ($t.moveNext()) {
                        var policyCommand = $t.Current;
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} column", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} column xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} column xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPoliciesOptions));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} column xxx policy", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} column xxx policy ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldColumnPoliciesOptions));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDatabasePoliciesCommandTest: function () {
                var $t;
                var policiesCommands = System.Array.init(["alter", "alter-merge", "delete"], System.String);
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                $t = Bridge.getEnumerator(policiesCommands);
                try {
                    while ($t.moveNext()) {
                        var policyCommand = $t.Current;
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        var expectedMatchingRule = System.String.equals(policyCommand, "alter") ? Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterDatabaseCommandOptions : Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPoliciesOptions;
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx ", [policyCommand]), expectedMatchingRule));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabasePoliciesOptions));
                        if (System.String.equals(policyCommand, "alter-merge")) {
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention softdelete = ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTimeSpanPolicyOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention harddelete = ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTimeSpanPolicyOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention softdelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention softdelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionSoftDeleteDefinedOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention harddelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention harddelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention softdelete = xxx harddelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} database xxx policy retention softdelete = xxx harddelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseTablePoliciesCommandTest: function () {
                var $t;
                var policiesCommands = System.Array.init(["alter", "alter-merge", "delete"], System.String);
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                $t = Bridge.getEnumerator(policiesCommands);
                try {
                    while ($t.moveNext()) {
                        var policyCommand = $t.Current;
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTablePoliciesOptions));
                        if (System.String.equals(policyCommand, "alter-merge")) {
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention softdelete = ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTimeSpanPolicyOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention harddelete = ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTimeSpanPolicyOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention softdelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention softdelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionSoftDeleteDefinedOptions));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention harddelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention harddelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention softdelete = xxx harddelete = xxx", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                            testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} table xxx policy retention softdelete = xxx harddelete = xxx ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseClusterPoliciesCommandTest: function () {
                var $t;
                var policiesCommands = System.Array.init(["alter", "alter-merge", "delete"], System.String);
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                $t = Bridge.getEnumerator(policiesCommands);
                try {
                    while ($t.moveNext()) {
                        var policyCommand = $t.Current;
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} cluster", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} cluster ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPoliciesOptions));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} cluster policy", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                        testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(System.String.format(".{0} cluster policy ", [policyCommand]), Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldClusterPoliciesOptions));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSetDatabaseUsersAdminsViewersPrettyNameCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseAdminsUsersViewersPrettyNameOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx ingestors", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx prettyname", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx users ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseUsersNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx admins ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseAdminsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx viewers ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseViewersNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx ingestors ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseIngestorsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set database xxx prettyname", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set database xxx users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set database xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set database xxx viewers| ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set database xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set database xxx prettyname | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSetClusterUsersAdminsViewersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterAdminsUsersViewersDatabaseCreatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster databasecreators", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster users ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterUsersNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster admins ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterAdminsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster viewers ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterViewersNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set cluster databasecreators ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterDatabaseCreatorsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set cluster users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set cluster admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set cluster viewers| ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set cluster databasecreators| ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSetTableAdminsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableAdminsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx ingestors", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx admins ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableAdminsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".set table xxx ingestors ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableIngestorsNoneOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set table xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".set table xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAddDatabaseUsersAdminsViewersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddDatabaseAdminsUsersViewersOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add database xxx ingestors", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add database xxx users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add database xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add database xxx viewers | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add database xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAddClusterUsersAdminsViewersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add cluster databasecreators", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add cluster users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add cluster admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add cluster viewers | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add cluster databasecreators | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAddTableAdminsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddTableAdminsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add table xxx admins", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add table xxx ingestors", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add table xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".add table xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDropDatabaseUsersAdminsViewersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropDatabaseOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx ingestors", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop database xxx prettyname", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop database xxx users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop database xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop database xxx viewers | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop database xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDropTableAdminsColumnsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropTableEntitiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop table xxx admins", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop table xxx ingestors", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop table xxx admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop table xxx ingestors | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop table xxx columns ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropTableColumnsSyntaxOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDropExtentTagsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent tags ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropExtentTagsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent tags from ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent tags from table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent tags from table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop extent tags from table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAlterExtentTagsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter extent", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter extent ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter extent tags ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterExtentTagsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter extent tags xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseExtentsAttachCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsIntoTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt by", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt by ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt by metadata", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt by metadata ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach extents into table ttt by metadata <|", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsIntoTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt by", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt by ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt by metadata", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt by metadata ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".attach async extents into table ttt by metadata <|", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseExtentsMoveCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents (00000000-0000-0000-0000-000000000000,00000000-0000-0000-0000-000000000000)", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents (00000000-0000-0000-0000-000000000000,00000000-0000-0000-0000-000000000000) ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveSpecifiedExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents to table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents to table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents to table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents to table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveSpecifiedExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsToTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to table abc", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move extents all from table ttt to table abc ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents (00000000-0000-0000-0000-000000000000,00000000-0000-0000-0000-000000000000)", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents (00000000-0000-0000-0000-000000000000,00000000-0000-0000-0000-000000000000) ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveSpecifiedExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents to table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents to table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents to table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents to table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveSpecifiedExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsToTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to table abc", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".move async extents all from table ttt to table abc ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseExtentsReplaceCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents in table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents in table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents in table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace extents in table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceExtentsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents in table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents in table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents in table ttt", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".replace async extents in table ttt ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseCreateDatabaseAdminCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseCreatePersistencyOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName volatile", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName volatile ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateIfNotExistsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName volatile  ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName persist", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName persist ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName persist (h@'', h@'')", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create database SomeName persist (h@'', h@'') ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateIfNotExistsOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseAlterDatabaseMetadataAdminCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterDatabaseCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx persist", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx persist ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx persist metadata", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx persist metadata ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter database xxx persist metadata h@''", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseCreateAddAlterDropAdminsCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".alter-merge ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergeCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".add ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".delete ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create-or-alter ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateOrAlterOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseDropClusterUsersAdminsViewersCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster users", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster admins", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster viewers", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".drop cluster databasecreators", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop cluster users | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop cluster admins | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop cluster viewers| ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(".drop cluster databasecreators| ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseQueryParametersTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("[", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("{", Kusto.Data.IntelliSense.RuleKind.YieldQueryParameters));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("\"{", Kusto.Data.IntelliSense.RuleKind.YieldQueryParameters));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("\"{q", Kusto.Data.IntelliSense.RuleKind.YieldQueryParameters));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("\"{q}", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("\"{q}{", Kusto.Data.IntelliSense.RuleKind.YieldQueryParameters));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("\"{q}{ ", Kusto.Data.IntelliSense.RuleKind.None));
                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseJoinTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join ", Kusto.Data.IntelliSense.RuleKind.YieldPostJoinOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join Table2 ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join Table2 on ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join (", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join ( ", Kusto.Data.IntelliSense.RuleKind.YieldTableNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join (Table2) on", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join (Table2) on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForJoin));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join (Table2 | limit 10 ) on ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForJoin));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join (Table2) on  ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForJoin));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind=", Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForJoin));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind= ", Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForJoin));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind=xxx", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind=xxx ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1| join kind=xxx kind=", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseRenderTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("render", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("|render", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("|render ", Kusto.Data.IntelliSense.RuleKind.YieldRenderOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render ", Kusto.Data.IntelliSense.RuleKind.YieldRenderOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timechart", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timechart ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render areachart", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render areachart ", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render barchart ", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render columnchart ", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindKeywordOption));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render areachart kind", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render areachart kind=", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render barchart kind=", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render columnchart kind=", Kusto.Data.IntelliSense.RuleKind.YieldRenderKindOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForRender));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForRender));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1, Column2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1, Column2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("| render timepivot by Column1, Column2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForRender));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseTopTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top ", Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top by ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top x by ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 ", Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 asc", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 asc ", Kusto.Data.IntelliSense.RuleKind.YieldNullsFirstNullsLastOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 asc\r\n", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 asc nulls first", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | top 10 by Column1 ,", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort ", Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 ", Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 asc", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 asc ", Kusto.Data.IntelliSense.RuleKind.YieldNullsFirstNullsLastOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 asc\r\n", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 asc nulls first", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | sort by Column1 ,", Kusto.Data.IntelliSense.RuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseReduceTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce by ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce by (Table2)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce kind", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce kind=", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce by Column kind=", Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForReduceBy));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce by Column kind =", Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForReduceBy));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | reduce by Column kind = ", Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForReduceBy));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseToScalarTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar(", Kusto.Data.IntelliSense.RuleKind.YieldTableNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar( ", Kusto.Data.IntelliSense.RuleKind.YieldTableNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar(Table", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar(Table ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar(Table | ", Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("toscalar(Table | count)", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("rand x from 1 to toscalar(", Kusto.Data.IntelliSense.RuleKind.YieldTableNames));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("rand x from 1 to toscalar(1) step toscalar(", Kusto.Data.IntelliSense.RuleKind.YieldTableNames));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseTimeKeywordsTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 >", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 > ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 < ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 == ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 != ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 >= ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where DateTimeField1 <= ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where Field1 == 'ff' and DateTimeField1 > ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | where Field1 == 'ff' or DateTimeField1 > ", Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("aago(", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("ago(", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("ago( ", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(" ago(", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("nnow(", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("now(", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("now( ", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2(" now( ", Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseEvaluateTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | evaluate ", Kusto.Data.IntelliSense.RuleKind.YieldEvaluateOperatorOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | evaluate diffpatterns(\"split= ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForDiffPatternsPluginSplitParameter));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | evaluate diffpatterns(\"bsplit= ", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("Table1 | extend split=", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseExportCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export  ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export compressed", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async compressed", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export compressed async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export compressed ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async compressed ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export compressed async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandNoModifiersAndOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandWithModifiersAndOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export compressed to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandWithModifiersAndOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async compressed to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandWithModifiersAndOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async to ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandWithModifiersAndOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export to", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".export async compressed to", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSensePurgeCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWhatIfOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge maxRecords = 111 table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge whatif = info maxRecords = 111 table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWhatIfOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async maxRecords = 111 table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 table ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 table TTT", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 table TTT ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 table TTT records", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge async whatif = info maxRecords = 111 table TTT records ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSensePurgeCleanupCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge-cleanup", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge-cleanup ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeCleanupOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge-cleanup async", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".purge-cleanup async ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeCleanupOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseCreateRowstoreAdminCommandTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName ", Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldRowStoreCreatePersistencyOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName volatile", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName writeaheadlog", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName writeaheadlog ", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor1(".create rowstore SomeName writeaheadlog (h@'', h@'')", Kusto.Data.IntelliSense.AdminEngineRuleKind.None));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseSearchTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search ", Kusto.Data.IntelliSense.RuleKind.YieldPostSearchOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=", Kusto.Data.IntelliSense.RuleKind.YieldSearchKindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind= ", Kusto.Data.IntelliSense.RuleKind.YieldSearchKindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind = ", Kusto.Data.IntelliSense.RuleKind.YieldSearchKindOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=case_sensitive", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=case_sensitive ", Kusto.Data.IntelliSense.RuleKind.YieldPostSearchKindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=case_insensitive ", Kusto.Data.IntelliSense.RuleKind.YieldPostSearchKindOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search \"ff\" or", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search \"ff\" or ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search \"ff\" and ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1) \"ff\" and ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1, ['Table.2']) \"ff\" or ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=case_sensitive  \"ff\" and ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1) ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search kind=case_sensitive in (Table1) ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1, ['Table.2'])", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1, ['Table.2']) ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1, database('*').*)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("search in (Table1, database('*').*) ", Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions));

                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseFindTest: function () {
                var testPatterns = new (System.Collections.Generic.List$1(Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern)).ctor();
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindOptions));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource = SourceTable ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForFindIn));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForFindIn));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, Table2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, Table2, ", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForFindIn));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2, ", Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForFindIn));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2'] ", Kusto.Data.IntelliSense.RuleKind.YieldEndOrContinueFindInOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2 ", Kusto.Data.IntelliSense.RuleKind.YieldEndOrContinueFindInOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2'])", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInListOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, Table2) ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInListOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, database('*').*)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, database('*').*) ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInListOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, database('*').*)", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, database('*').*) ", Kusto.Data.IntelliSense.RuleKind.YieldPostFindInListOptions));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));


                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field1 == 'abc' and", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field1 == 'abc' and ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (*, database('*').*) where * has 'abc' and", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (*, database('*').*) where * has 'abc' and ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (*, database('*').*) where 'abc' and", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (*, database('*').*) where 'abc' and ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field1 == 'abc' and", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field1 == 'abc' and ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind));

                /* testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1", RuleKind.None));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1 ", RuleKind.YieldStringComparisonInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1 like 'xxx' and Field2 ", RuleKind.YieldStringComparisonInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1 like 'xxx' or Field2 ", RuleKind.YieldStringComparisonInFindOptions));

                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 >", RuleKind.None));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 > ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 > ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 < ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 == ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 != ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 >= ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where DateTimeField1 <= ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1 == 'ff' and DateTimeField1 > ", RuleKind.YieldDateTimeOperatorsInFindOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, ['Table.2']) where Field1 == 'ff' or DateTimeField1 > ", RuleKind.YieldDateTimeOperatorsInFindOptions));

                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, database('Other').Table1) where NumField1 ", RuleKind.YieldNumericComparisonOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, database('Other').Table1) where NumField1 == 10 and NumField1 ", RuleKind.YieldNumericComparisonOptions));
                testPatterns.Add(new IntelliSenseTestPattern("find in (Table1, database('Other').*) where NumField1 == 10 or NumField1 ", RuleKind.YieldNumericComparisonOptions));*/

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field3 == 'abc' project", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field3 == 'abc' project ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field0 == 'abc' and DateTimeField1 > ago(1h) project", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field0 == 'abc' and DateTimeField1 > ago(1h) project ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field0 == 'abc' project DateTimeField1", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field0 == 'abc' and DateTimeField1 > ago(1h) project NumField1", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project NumField2,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project NumField2, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field3 == 'abc' and DateTimeField0 > ago(1h) project Field0,", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find withsource=SourceTable in (Table1, ['Table.2']) where Field3 == 'abc' and DateTimeField0 > ago(1h) project Field0, ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind));


                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project-smart", Kusto.Data.IntelliSense.RuleKind.None));
                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project-smart ", Kusto.Data.IntelliSense.RuleKind.YieldFindProjectSmartOptions));


                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project NumField2 | where", Kusto.Data.IntelliSense.RuleKind.None));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project NumField2 | where ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter));

                testPatterns.add(new Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern.$ctor2("find in (Table1, ['Table.2']) where Field8 == 'abc' project NumField2 | project ", Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject));


                Kusto.UT.IntelliSenseRulesTests.TestIntelliSensePatterns(Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider, testPatterns);
            },
            IntelliSenseGetCommandContextTest: function () {
                var $t, $t1;
                var commands = $asm.$.Kusto.UT.IntelliSenseRulesTests.f3(new (System.Collections.Generic.Dictionary$2(System.String,System.String))());

                $t = Bridge.getEnumerator(System.Array.init([false, true], System.Boolean));
                try {
                    while ($t.moveNext()) {
                        var flatten = $t.Current;
                        $t1 = Bridge.getEnumerator(commands);
                        try {
                            while ($t1.moveNext()) {
                                var kvp = $t1.Current;
                                var command = kvp.key;
                                if (flatten) {
                                    command = System.String.replaceAll(System.String.replaceAll(command, String.fromCharCode(10), String.fromCharCode(32)), String.fromCharCode(13), String.fromCharCode(32));
                                } else {
                                    command = System.String.replaceAll(System.String.replaceAll(command, String.fromCharCode(10), String.fromCharCode(32)), String.fromCharCode(13), String.fromCharCode(32));
                                }
                                var context = Kusto.UT.IntelliSenseRulesTests.s_intelliSenseProvider.AnalyzeCommand$1(command, null).Context;
                                Kusto.UT.IntelliSenseRulesTests.Assert.AreEqual$1(kvp.value, context.Context, Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("Command context was not resolved correctly for command '{0}'", [command]));
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        }
    });

    Bridge.ns("Kusto.UT.IntelliSenseRulesTests", $asm.$);

    Bridge.apply($asm.$.Kusto.UT.IntelliSenseRulesTests, {
        f1: function (c) {
            return c.Name;
        },
        f2: function (e) {
            return (e.Operator || "") + ":" + (e.Name || "");
        },
        f3: function (_o1) {
            _o1.add("database('", "database('");
            _o1.add("database('someDB')", "database('someDB')");
            _o1.add("database('someDB').", "database('someDB').");
            _o1.add("database('someDB').Table", "database('someDB').Table");
            _o1.add("database('someDB with space')", "database('someDB with space')");
            _o1.add("database('someDB with space').", "database('someDB with space').");
            _o1.add("database('someDB with space').Table", "database('someDB with space').Table");
            _o1.add("database(\"someDB with space\")", "database(\"someDB with space\")");
            _o1.add("database(\"someDB with space\").", "database(\"someDB with space\").");
            _o1.add("database(\"someDB with space\").Table", "database(\"someDB with space\").Table");
            _o1.add("cluster('abc').database('", "cluster('abc').database('");
            _o1.add("cluster('abc').database('someDB')", "cluster('abc').database('someDB')");
            _o1.add("cluster('abc').database('someDB').", "cluster('abc').database('someDB').");
            _o1.add("cluster('abc').database('someDB').Table", "cluster('abc').database('someDB').Table");
            _o1.add("cluster('https://abc.kusto.windows.net').database('", "cluster('https://abc.kusto.windows.net').database('");
            _o1.add("cluster('https://abc.kusto.windows.net').database('someDB')", "cluster('https://abc.kusto.windows.net').database('someDB')");
            _o1.add("cluster('https://abc.kusto.windows.net').database('someDB').", "cluster('https://abc.kusto.windows.net').database('someDB').");
            _o1.add("cluster('https://abc.kusto.windows.net').database('someDB').Table", "cluster('https://abc.kusto.windows.net').database('someDB').Table");
            _o1.add("cluster(\"https://abc.kusto.windows.net\").database('", "cluster(\"https://abc.kusto.windows.net\").database('");
            _o1.add("cluster(\"https://abc.kusto.windows.net\").database('someDB')", "cluster(\"https://abc.kusto.windows.net\").database('someDB')");
            _o1.add("cluster(\"https://abc.kusto.windows.net\").database('someDB').", "cluster(\"https://abc.kusto.windows.net\").database('someDB').");
            _o1.add("cluster(\"https://abc.kusto.windows.net\").database('someDB').Table", "cluster(\"https://abc.kusto.windows.net\").database('someDB').Table");
            _o1.add("let x = toscalar(Table1 | ", "Table1");
            _o1.add("range x from toscalar(Table1 | count) to toscalar(Table2 | ", "Table2");
            _o1.add("set querytrace;\r\n Table2 | ", "Table2");
            _o1.add("union\r\n(Table1 | where body has keyword and body has \"Google\" | summarize posts=dcount(link_id) | extend context = \"Google\"),\r\n(Table2 | where  ", "Table2");
            _o1.add("union (Table1), (Table2  ", "Table2");
            _o1.add("union\n (Table ", "Table");
            _o1.add("union (Table ", "Table");
            _o1.add("let x = () {request};\n let y = x;\n y ", "request");
            _o1.add("let x = request;\n x ", "request");
            _o1.add("let x = request | count;\n x ", "request");
            _o1.add("let x = request;\n x | count ", "request");
            _o1.add("let x = request;\n let y = x;\n y ", "request");
            _o1.add("let x = () {request | limit 100};\n let y = x;\n y ", "request");
            _o1.add(".show database XYZ ", ".show database XYZ");
            _o1.add("Table1 | count", "Table1");
            _o1.add("Table1 | join (Table2 | ", "Table2");
            _o1.add("let x = 1;\n Table2 | ", "Table2");
            _o1.add("range xyz from 1 to 1 step 1| ", "range");
            _o1.add("let x = () { request | where ", "request");
            _o1.add("let x = request | where ", "request");
            _o1.add("cluster('lxprdscu02').database('Analytics Billing').ApplicationHourlyEntryCount\r\n| where StartTime >= ago(rangeInDaysForBililngData)\r\n| where DataSource == 'AI'\r\n| where Database in (longtailDatabases)\r\n| summarize totalGB=1.0*sum(SizeInBytes)/1024/1024/1024 by bin(StartTime, 1d), ApplicationName , InstrumentationKey , ClusterName, DatabasePrettyName, Database, ProfileId\r\n| top-nested  of ClusterName by count(), top-nested  of DatabasePrettyName by count(), top-nested  of Database by count(),top-nested topAppCountByData of ProfileId by avg_totalGB = avg(totalGB) desc, top-nested of ApplicationName by count(), top-nested of InstrumentationKey by count()\r\n| project ClusterName, DatabasePrettyName , Database, ProfileId , ApplicationName ,InstrumentationKey, avg_totalGB\r\n| order by ClusterName , avg_totalGB desc ", "cluster('lxprdscu02').database('Analytics Billing').ApplicationHourlyEntryCount");
            _o1.add("database('Analytics Billing').ApplicationHourlyEntryCount\r\n| where StartTime >= ago(rangeInDaysForBililngData)\r\n| where DataSource == 'AI'\r\n| where Database in (longtailDatabases)\r\n| summarize totalGB=1.0*sum(SizeInBytes)/1024/1024/1024 by bin(StartTime, 1d), ApplicationName , InstrumentationKey , ClusterName, DatabasePrettyName, Database, ProfileId\r\n| top-nested  of ClusterName by count(), top-nested  of DatabasePrettyName by count(), top-nested  of Database by count(),top-nested topAppCountByData of ProfileId by avg_totalGB = avg(totalGB) desc, top-nested of ApplicationName by count(), top-nested of InstrumentationKey by count()\r\n| project ClusterName, DatabasePrettyName , Database, ProfileId , ApplicationName ,InstrumentationKey, avg_totalGB\r\n| order by ClusterName , avg_totalGB desc ", "database('Analytics Billing').ApplicationHourlyEntryCount");
            _o1.add("find 'abc'", "*");
            _o1.add("find in (database('*').*) 'abc'", "database('*').*");
            _o1.add("find in (database(\"*\").*) 'abc'", "database(\"*\").*");
            _o1.add("find in (Table) where", "Table");
            _o1.add("find in (['Table']) where", "['Table']");
            _o1.add("find in (database('Office*').*, T*, cluster('somecluster').database('x').T*) 'abc'", "database('Office*').*, T*, cluster('somecluster').database('x').T*");
            _o1.add("find withsource=X 'abc'", "*");
            _o1.add("find withsource=X in (database('*').*) 'abc'", "database('*').*");
            _o1.add("find withsource=X in (database(\"*\").*) 'abc'", "database(\"*\").*");
            _o1.add("find withsource=X in (Table) where", "Table");
            _o1.add("find withsource=X in (['Table']) where", "['Table']");
            _o1.add("find withsource=X in (database('Office*').*, T*, cluster('somecluster').database('x').T*) 'abc'", "database('Office*').*, T*, cluster('somecluster').database('x').T*");
            _o1.add("search 'abc'", "*");
            _o1.add("Table1 | search 'abc'", "Table1");
            _o1.add("search in (database('*').*) 'abc'", "database('*').*");
            _o1.add("search in (database(\"*\").*) 'abc'", "database(\"*\").*");
            _o1.add("search in (Table) where", "Table");
            _o1.add("search in (Table1, Table2) where", "Table1, Table2");
            _o1.add("search in (['Table']) where", "['Table']");
            _o1.add("search in (database('Office*').*, T*, cluster('somecluster').database('x').T*) 'abc'", "database('Office*').*, T*, cluster('somecluster').database('x').T*");
            return _o1;
        }
    });

    Bridge.define("Kusto.UT.IntelliSenseRulesTests.IntelliSenseTestPattern", {
        $kind: "nested class",
        props: {
            Input: null,
            ExpectedMatch: false,
            ExpectedRuleKind: 0
        },
        ctors: {
            ctor: function (input) {
                this.$initialize();
                this.Input = input;
                this.ExpectedRuleKind = Kusto.Data.IntelliSense.RuleKind.None;
                this.ExpectedMatch = false;
            },
            $ctor2: function (input, matchingRule) {
                this.$initialize();
                this.Input = input;
                this.ExpectedRuleKind = matchingRule;
                this.ExpectedMatch = matchingRule !== Kusto.Data.IntelliSense.RuleKind.None;
            },
            $ctor1: function (input, matchingRule) {
                this.$initialize();
                this.Input = input;
                this.ExpectedRuleKind = matchingRule;
                this.ExpectedMatch = matchingRule !== Kusto.Data.IntelliSense.AdminEngineRuleKind.None;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase],
        statics: {
            fields: {
                s_lineWithDotBeginningRegex: null,
                s_showCommandRegex: null,
                s_retryCommandRegex: null,
                s_retryPurgeCommandRegex: null,
                s_retryPurgeOperationsInServiceCommandRegex: null,
                s_retryPurgeOperationsInServiceServiceNameCommandRegex: null,
                s_retryPurgeOperationsInServiceServiceNameFromCommandRegex: null,
                s_afterPipeRegex: null,
                s_alterCommandRegex: null,
                s_removeCommandRegex: null,
                s_setCommandRegex: null,
                s_createCommandRegex: null,
                s_deleteCommandRegex: null,
                s_detachCommandRegex: null,
                s_checkCommandRegex: null,
                s_addCommandRegex: null,
                s_dropCommandRegex: null,
                s_moveCommandRegex: null,
                s_activationCommandRegex: null,
                s_serviceCommandRegex: null,
                s_storageLogsIntoCommandRegex: null,
                s_principalsCommandRegex: null,
                s_operationsCommandRegex: null,
                s_showAccountCommandRegex: null,
                s_moveAccountCommandRegex: null,
                s_moveDatabaseCommandRegex: null,
                s_moveDatabaseFromServiceCommandRegex: null,
                s_moveAccountSubscriptionCommandRegex: null,
                s_showTargetServiceCommandRegex: null,
                s_storageAccountsKeywordRegex: null,
                s_fromServiceKeywordRegex: null,
                s_fromAccountKeywordRegex: null,
                s_showAuditLogCommandRegex: null,
                s_showAuditLogFromCommandRegex: null,
                s_showPurgesCommandRegex: null,
                s_showPurgesFromCommandRegex: null,
                s_configurationKeywordRegex: null,
                s_showPrincipalRolesCommandRegex: null,
                s_showAccountsKeywordRegex: null,
                s_dmServiceAddKeywordRegex: null,
                s_dmServiceAlterKeywordRegex: null,
                s_dmServiceDropKeywordRegex: null,
                s_configurationPropertySetKeywordRegex: null,
                s_toKeywordRegex: null,
                s_configurationPropertyWithConsentKeywordRegex: null,
                s_addKeywordRegex: null,
                s_configurationPropertyDropKeywordRegex: null,
                s_accountRenameOperationsKeywordRegex: null,
                s_accountAlterOperationsKeywordRegex: null,
                s_accountSubscriptionAlterKeywordRegex: null,
                s_accountAddOperationsKeywordRegex: null,
                s_accountRemoveOperationsKeywordRegex: null,
                s_accountSetOperationsKeywordRegex: null,
                s_serviceAlterOperationsKeywordRegex: null,
                s_inServiceKeywordRegex: null,
                s_createDatabaseCommandRegex: null,
                s_createServiceAndClusterCommandRegex: null,
                s_accountNamesCommandRegex: null,
                s_servicesNamesToAppendOptionsCommandRegex: null,
                s_servicesNamesCommandRegex: null,
                s_withPropertiesSuffixRegex: null,
                s_withEventHubPropertiesSuffixRegex: null,
                s_addServiceServiceNameRegex: null,
                s_databaseNameMetadataKeywordRegex: null,
                s_metadataKeywordRegex: null,
                s_serviceInstallCommandRegex: null,
                s_serviceReinstallCommandRegex: null,
                s_serviceUninstallCommandRegex: null,
                s_serviceMigrateCommandRegex: null,
                s_addClusterPrincipalsCommandRegex: null,
                s_setClusterPrincipalsCommandRegex: null,
                s_dropClusterPrincipalsCommandRegex: null,
                s_setClusterPrincipalsNoneCommandRegex: null,
                s_dropAccountPrincipalsCommandRegex: null,
                s_alterServiceConfigurationDetailsKeywordRegex: null,
                s_alterServiceConfigurationPropertiesKeywordRegex: null,
                s_purgeRegex: null,
                s_purgeRecordsRegex: null,
                s_purgeInDatabaseRegex: null,
                s_purgeDatabaseRegex: null,
                s_purgeInServiceRegex: null,
                s_purgeServiceRegex: null,
                s_purgeServiceNameRegex: null,
                s_loadBalancerKeywordRegex: null,
                s_yieldPipeOptionRegex: null,
                s_cancelServiceOperationRegex: null,
                s_adminOperationOptions: null,
                s_operatorOptions: null,
                s_showCommandOptions: null,
                s_retryCommandOptions: null,
                s_retryPurgeCommandOptions: null,
                s_alterCommandOptions: null,
                s_addCommandOptions: null,
                s_removeCommandOptions: null,
                s_dropCommandOptions: null,
                s_setCommandOptions: null,
                s_createCommandOptions: null,
                s_deleteCommandOptions: null,
                s_moveCommandOptions: null,
                s_accountKeywordOptions: null,
                s_pccodeKeywordOptions: null,
                s_checkCommandOptions: null,
                s_serviceKeywordOptions: null,
                s_serviceOrClusterKeywordOptions: null,
                s_storageLogsIntoCommandOptions: null,
                s_principalsKeywordOptions: null,
                s_operationsKeywordOptions: null,
                s_showPrincipalRolesKeywordOptions: null,
                s_showServiceCommandOptions: null,
                s_showAccountCommandOptions: null,
                s_moveAccountCommandOptions: null,
                s_moveAccountSubscriptionCommandOptions: null,
                s_showTargetServiceCommandOptions: null,
                s_fromKeywordOptions: null,
                s_alterServiceConfigurationKeywordOptions: null,
                s_toKeywordOptions: null,
                s_addSetDropPrincipalsKeywordOptions: null,
                s_dropAccountPrincipalsKeywordOptions: null,
                s_setNoneKeywordOptions: null,
                s_configurationKeywordOptions: null,
                s_showAccountsKeywordOptions: null,
                s_dmServiceAddKeywordOptions: null,
                s_dmServiceAlterKeywordOptions: null,
                s_dmServiceDropKeywordOptions: null,
                s_serviceConfigurationPropertyDropKeywordOptions: null,
                s_serviceConfigurationPropertySetKeywordOptions: null,
                s_withConsentKeywordOptions: null,
                s_storageAccountsKeywordOptions: null,
                s_accountAlterOperationsOptions: null,
                s_accountRenameOperationsOptions: null,
                s_accountAddOperationsOptions: null,
                s_accountRemoveOperationsOptions: null,
                s_accountSetOperationsOptions: null,
                s_serviceAlterOperationsOptions: null,
                s_inServiceKeywordOptions: null,
                s_addServiceServicenameOptions: null,
                s_databaseKeywordOptions: null,
                s_metadataKeywordOptions: null,
                s_withPropertiesSuffixOptions: null,
                s_withEventHubProperties: null,
                s_withEventHubAlterProperties: null,
                s_installCommandOptions: null,
                s_uninstallCommandOptions: null,
                s_migrateServiceCommandOptions: null,
                s_fromServiceKeywordOptions: null,
                s_toServiceKeywordOptions: null,
                s_createDatabaseCommandOptions: null,
                s_createServiceAndClusterCommandOptions: null,
                s_addKeywordOptions: null,
                s_alterServiceConfigurationPropertiesOptions: null,
                s_alterServiceConfigurationCommandOptions: null,
                s_tableKeywordOptions: null,
                s_recordsKeywordOptions: null,
                s_inKeywordOptions: null,
                s_loadBalancerKeywordOptions: null,
                s_operationKeywordOptions: null
            },
            ctors: {
                init: function () {
                    this.s_lineWithDotBeginningRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_retryCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.retry\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_retryPurgeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.retry\\s+purge\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_retryPurgeOperationsInServiceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.retry\\s+purge\\s+operations\\s+in\\s+service\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_retryPurgeOperationsInServiceServiceNameCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.retry\\s+purge\\s+operations\\s+in\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_retryPurgeOperationsInServiceServiceNameFromCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.retry\\s+purge\\s+operations\\s+in\\s+service\\s+\\S+\\s+from\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_afterPipeRegex = new System.Text.RegularExpressions.Regex.ctor("\\|\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_removeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.remove\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_deleteCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_detachCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.detach\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_checkCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.check\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_activationCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(resume|suspend)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(restart|reimage|rebuild|stop|uninstall|install|reinstall|recycle|ingest|migrate|cancel)\\s+$|^\\s*\\.ingest\\s+service\\s+\\S+\\s+storage\\s+logs\\s+into\\s$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_storageLogsIntoCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.ingest\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_principalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operationsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+(running|completed|failed)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showAccountCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+account\\s+\\[.*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveAccountCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+account\\s+\\[[^\\]]*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveDatabaseFromServiceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+database\\s+\\S+\\s+from\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveAccountSubscriptionCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+account\\s+(\\S+|\\[.*?\\])\\s+subscription\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showTargetServiceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s(?!versions|model|(packages configuration)\\b)\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_storageAccountsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.recycle\\s+service\\s+\\S+\\s+$|^\\s*\\.add\\s+service\\s+\\S+\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_fromServiceKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+service\\s+(\\S+|\\[.*?\\])\\s+configuration\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_fromAccountKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+account\\s+(\\S+|\\[.*?\\])\\s+configuration\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showAuditLogCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+(service|account)\\s+\\S+\\s+audit\\s+log\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showAuditLogFromCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+(service|account)\\s+\\S+\\s+audit\\s+log\\s+from\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showPurgesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s+\\S+\\s+purges\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showPurgesFromCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s+\\S+\\s+purges\\s+from\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_configurationKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+services\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showPrincipalRolesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+principal\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showAccountsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+accounts\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dmServiceAddKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+dm\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dmServiceAlterKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+dm\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dmServiceDropKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+dm\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_configurationPropertySetKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_toKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+service\\s+\\S+\\s+\\S+\\s+$|^\\s*\\.set\\s+account\\s+\\[.*?\\]\\s+(division|servicetree)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_configurationPropertyWithConsentKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+service\\s+\\S+\\s+(?i)InstancesCount\\s+(auto|to\\s+\\S+)\\s+$|^\\s*\\.set\\s+service\\s+\\S+\\s+(?i)VmSize\\s+to\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+service\\s+\\S+\\s+NumberOfDatabaseStorageAccounts\\s+to\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_configurationPropertyDropKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountRenameOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.rename\\s+account\\s+(\\S+|\\[.*?\\])\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountAlterOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+account\\s+\\[.*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountSubscriptionAlterKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+account\\s+\\[.*?\\]\\s+subscription\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountAddOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+account\\s+\\[.*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountRemoveOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.remove\\s+account\\s+\\[.*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountSetOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+account\\s+\\[.*?\\]\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceAlterOperationsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_inServiceKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+database\\s+\\S+\\s+$|^\\s*\\.create\\s+database\\s+\\S+\\s+ifNotExists\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createServiceAndClusterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+service\\s+\\S+\\s+$|^\\s*\\.create\\s+cluster\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_accountNamesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(add|remove|alter|rename|show|detach|move|set|drop)\\s+account\\s+$|^\\s*\\.move\\s+account\\s+(\\S+|\\[.*?\\])\\s+subscription\\s+\\S+\\s+to\\s+account\\s+$|^\\s*\\.rename\\s+account\\s+(\\S+|\\[.*?\\])\\s+to\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_servicesNamesToAppendOptionsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_servicesNamesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+database\\s+\\S+\\s+in\\s+service\\s+$|^\\s*\\.create\\s+database\\s+\\S+\\s+(ifNotExists\\s+)?in\\s+service\\s+$|^\\s*\\.(alter|delete|restart|reimage|rebuild|stop|uninstall|install|reinstall|recycle|set|add|ingest|drop|migrate|cancel)\\s+service\\s+$|^\\s*\\.(resume|suspend)\\s+(service|cluster)\\s+$|^\\s*\\.(add|drop|alter)\\s+dm\\s+service\\s+$|^\\s*\\.ingest\\s+service\\s+\\S+\\s+storage\\s+logs\\s+into\\s+service\\s+$|^\\s*\\.move\\s+database\\s+\\S+\\s+from\\s+service\\s+$|^\\s*\\.move\\s+database\\s+\\S+\\s+from\\s+service\\s+\\S+\\s+to\\s+service\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_withPropertiesSuffixRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+database\\s+\\S+\\s+in\\s+service\\s+\\S+\\s+$|^\\s*\\.create\\s+database\\s+\\S+\\s+(ifNotExists\\s+)?in\\s+service\\s+\\S+\\s+$|^\\s*\\.(delete|restart|rebuild|reimage|reinstall)\\s+service\\s+\\S+\\s+$|^\\s*\\.create\\s+(service|cluster)\\s+\\S+\\s+ifNotExists\\s+$|^\\s*\\.delete\\s+cluster\\s+\\S+\\s+$|^\\s*\\.(add|drop)\\s+dm\\s+service\\s+\\S+\\s+(data obtainer|storage accounts)\\s+$|^\\s*\\.alter\\s+dm\\s+service\\s+\\S+\\s+storage\\s+account\\s+\\S+\\s+$|^\\s*\\.alter\\s+dm\\s+service\\s+\\S+\\s+eventhub\\s+ingestion\\s+source\\s+\\S+\\s+$|^\\s*\\.alter\\s+service\\s+packages\\s+configuration\\s+$|^\\s*\\.add\\s+account\\s\\[.*?\\]\\s+contact\\s+$|^\\s*\\.add\\s+service\\s+\\S+\\s+database\\s+\\S+\\s+storage\\s+accounts\\s+$|^\\s*\\.alter\\s+service\\s+\\S+\\s+storage\\s+accounts\\s+$|^\\s*\\.alter\\s+service\\s+\\S+\\s+storage\\s+account\\s+\\S+\\s+$|^\\s*\\.ingest\\s+service\\s+\\S+\\s+storage\\s+logs\\s+into\\s+service\\s+\\S+\\s+$|^\\s*\\.install\\s+service\\s+\\S+\\s+runners\\s+$|^\\s*\\.migrate\\s+service\\s+\\S+\\s+to\\s+(AzurePaas1|AzureVMSS)\\s+$|^\\s*\\.move\\s+database\\s+\\S+\\s+from\\s+service\\s+\\S+\\s+to\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_withEventHubPropertiesSuffixRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+dm\\s+service\\s+\\S+\\s+eventhub\\s+(obtainer|ingestion source)\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addServiceServiceNameRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_databaseNameMetadataKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s+\\S+\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_metadataKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+service\\s+\\S+\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceInstallCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.install\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceReinstallCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.reinstall\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceUninstallCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.uninstall\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_serviceMigrateCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.migrate\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addClusterPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropClusterPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterPrincipalsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+(admins|viewers)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropAccountPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+account\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterServiceConfigurationDetailsKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+service\\s+(\\S+|\\[.*?\\])\\s+configuration\\s+(details\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterServiceConfigurationPropertiesKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+service\\s+(\\S+|\\[.*?\\])\\s+configuration\\s+(details\\s+)?\\((\\s*\\S+\\s*=\\s*['\"].*?['\"]\\s*)?\\s*(,(\\s*\\S+\\s*=\\s*['\"].*?['\"]\\s*))*\\)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeRecordsRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeInDatabaseRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+records\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeDatabaseRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+records\\s+in\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeInServiceRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+records\\s+in\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeServiceRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+records\\s+in\\s+database\\s+\\S+\\s+in\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeServiceNameRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+table\\s+\\S+\\s+records\\s+in\\s+database\\s+\\S+\\s+in\\s+service\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_loadBalancerKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+service\\s+\\S+\\s+to\\s+$|^\\s*\\.drop\\s+service\\s+\\S+\\s+from\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_yieldPipeOptionRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+((ame|corp)\\s+)?resources\\s+$|^\\s*\\.show\\s+account\\s+\\S+\\s+((ame|corp)\\s+)?resources\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_cancelServiceOperationRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.cancel\\s+service\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_adminOperationOptions = System.Array.init([
                        "show", 
                        "set", 
                        "restart", 
                        "reimage", 
                        "rebuild", 
                        "create", 
                        "alter", 
                        "install", 
                        "reinstall", 
                        "add", 
                        "remove", 
                        "check", 
                        "recycle", 
                        "stop", 
                        "uninstall", 
                        "detach", 
                        "delete", 
                        "ingest", 
                        "drop", 
                        "move", 
                        "migrate", 
                        "purge", 
                        "suspend", 
                        "resume", 
                        "cancel", 
                        "retry"
                    ], System.String);
                    this.s_operatorOptions = System.Array.init([
                        "where", 
                        "count", 
                        "extend", 
                        "limit", 
                        "order", 
                        "project", 
                        "project-away", 
                        "project-rename", 
                        "sort", 
                        "summarize", 
                        "take", 
                        "top", 
                        "mvexpand"
                    ], System.String);
                    this.s_showCommandOptions = System.Array.init([
                        "service", 
                        "services", 
                        "account", 
                        "accounts", 
                        "operations", 
                        "running", 
                        "completed", 
                        "failed", 
                        "version", 
                        "diagnostics", 
                        "cluster", 
                        "unallocated subscriptions", 
                        "subscription", 
                        "principal", 
                        "resources", 
                        "ame resources", 
                        "corp resources"
                    ], System.String);
                    this.s_retryCommandOptions = System.Array.init(["purge"], System.String);
                    this.s_retryPurgeCommandOptions = System.Array.init(["operations in service"], System.String);
                    this.s_alterCommandOptions = System.Array.init([
                        "service", 
                        "dm service", 
                        "account"
                    ], System.String);
                    this.s_addCommandOptions = System.Array.init([
                        "account", 
                        "service", 
                        "dm service", 
                        "unallocated subscription", 
                        "cluster"
                    ], System.String);
                    this.s_removeCommandOptions = System.Array.init(["account", "unallocated subscription"], System.String);
                    this.s_dropCommandOptions = System.Array.init([
                        "dm service", 
                        "service", 
                        "cluster", 
                        "account"
                    ], System.String);
                    this.s_setCommandOptions = System.Array.init([
                        "service", 
                        "account", 
                        "cluster"
                    ], System.String);
                    this.s_createCommandOptions = System.Array.init([
                        "database", 
                        "service", 
                        "account", 
                        "cluster"
                    ], System.String);
                    this.s_deleteCommandOptions = System.Array.init([
                        "cluster", 
                        "database", 
                        "service"
                    ], System.String);
                    this.s_moveCommandOptions = System.Array.init(["account", "database"], System.String);
                    this.s_accountKeywordOptions = System.Array.init(["account"], System.String);
                    this.s_pccodeKeywordOptions = System.Array.init(["pccode"], System.String);
                    this.s_checkCommandOptions = System.Array.init(["service name availability"], System.String);
                    this.s_serviceKeywordOptions = System.Array.init(["service"], System.String);
                    this.s_serviceOrClusterKeywordOptions = System.Array.init(["service", "cluster"], System.String);
                    this.s_storageLogsIntoCommandOptions = System.Array.init(["storage logs into"], System.String);
                    this.s_principalsKeywordOptions = System.Array.init(["principals"], System.String);
                    this.s_operationsKeywordOptions = System.Array.init(["operations"], System.String);
                    this.s_showPrincipalRolesKeywordOptions = System.Array.init(["roles", "@'principal' roles"], System.String);
                    this.s_showServiceCommandOptions = System.Array.init([
                        "versions", 
                        "model", 
                        "packages configuration"
                    ], System.String);
                    this.s_showAccountCommandOptions = System.Array.init([
                        "configuration", 
                        "services", 
                        "service configurations", 
                        "subscriptions", 
                        "principals", 
                        "contacts", 
                        "audit log", 
                        "resources", 
                        "ame resources", 
                        "corp resources"
                    ], System.String);
                    this.s_moveAccountCommandOptions = System.Array.init(["subscription"], System.String);
                    this.s_moveAccountSubscriptionCommandOptions = System.Array.init(["to account"], System.String);
                    this.s_showTargetServiceCommandOptions = System.Array.init([
                        "configuration", 
                        "fabriclocks", 
                        "storage objects", 
                        "storage account", 
                        "storage accounts", 
                        "database", 
                        "metadata", 
                        "audit log", 
                        "purges"
                    ], System.String);
                    this.s_fromKeywordOptions = System.Array.init(["from"], System.String);
                    this.s_alterServiceConfigurationKeywordOptions = System.Array.init(["details", "(KEY='VALUE')"], System.String);
                    this.s_toKeywordOptions = System.Array.init(["to"], System.String);
                    this.s_addSetDropPrincipalsKeywordOptions = System.Array.init(["admins", "viewers"], System.String);
                    this.s_dropAccountPrincipalsKeywordOptions = System.Array.init(["admins"], System.String);
                    this.s_setNoneKeywordOptions = System.Array.init(["none"], System.String);
                    this.s_configurationKeywordOptions = System.Array.init(["configuration"], System.String);
                    this.s_showAccountsKeywordOptions = System.Array.init(["configuration", "subscriptions"], System.String);
                    this.s_dmServiceAddKeywordOptions = System.Array.init([
                        "data obtainer", 
                        "storage accounts", 
                        "eventhub ingestion source"
                    ], System.String);
                    this.s_dmServiceAlterKeywordOptions = System.Array.init(["storage account", "eventhub ingestion source"], System.String);
                    this.s_dmServiceDropKeywordOptions = System.Array.init(["data obtainer"], System.String);
                    this.s_serviceConfigurationPropertyDropKeywordOptions = System.Array.init([
                        "AutoscaleSetting", 
                        "FeatureFlags", 
                        "from", 
                        "TableFreshnessTestSettings", 
                        "uncommitted changes"
                    ], System.String);
                    this.s_serviceConfigurationPropertySetKeywordOptions = System.Array.init([
                        "InstancesCount", 
                        "InstancesCount auto", 
                        "VmSize", 
                        "AutoscaleSetting", 
                        "DeploymentRing", 
                        "DeploymentFreezeEnabled", 
                        "DeploymentFreezeExpiresOn", 
                        "FeatureFlags", 
                        "MonitoringAccount", 
                        "TableFreshnessTestSettings", 
                        "Environment", 
                        "CustomerType", 
                        "Certificates", 
                        "DoNotCreateIcmIncidents", 
                        "DoNotDeploy", 
                        "DoNotDeployRunners", 
                        "AdditonalSubscriptions", 
                        "AriaBridgeConfiguration", 
                        "AutomaticallyDetachCorruptDatabases", 
                        "CmSettings", 
                        "DmSettings", 
                        "EnableTracePush", 
                        "EnableUnauthenticatedAccess", 
                        "EnforceMfa", 
                        "GenevaBridgeConfiguration", 
                        "JitStorageAccountName", 
                        "KustoExplorerDownloadUri", 
                        "KustoServiceSettings", 
                        "ManagementCertificate", 
                        "ScaleChangesRequireCustomerConsent", 
                        "EnableSSE", 
                        "NumberOfDatabaseStorageAccounts"
                    ], System.String);
                    this.s_withConsentKeywordOptions = System.Array.init(["with consent"], System.String);
                    this.s_storageAccountsKeywordOptions = System.Array.init(["storage accounts"], System.String);
                    this.s_accountAlterOperationsOptions = System.Array.init(["configuration", "subscription"], System.String);
                    this.s_accountRenameOperationsOptions = System.Array.init(["to"], System.String);
                    this.s_accountAddOperationsOptions = System.Array.init(["contact", "admins"], System.String);
                    this.s_accountRemoveOperationsOptions = System.Array.init(["contact"], System.String);
                    this.s_accountSetOperationsOptions = System.Array.init([
                        "division", 
                        "admins", 
                        "servicetree"
                    ], System.String);
                    this.s_serviceAlterOperationsOptions = System.Array.init([
                        "configuration", 
                        "storage account", 
                        "storage accounts", 
                        "configuration details"
                    ], System.String);
                    this.s_inServiceKeywordOptions = System.Array.init(["in service"], System.String);
                    this.s_addServiceServicenameOptions = System.Array.init(["database", "to"], System.String);
                    this.s_databaseKeywordOptions = System.Array.init(["database"], System.String);
                    this.s_metadataKeywordOptions = System.Array.init(["metadata"], System.String);
                    this.s_withPropertiesSuffixOptions = System.Array.init(["with(KEY='VALUE')"], System.String);
                    this.s_withEventHubProperties = System.Array.init([
                        "with(CreateEventHub='true', PartitionCount='VALUE', TargetDatabase='VALUE')", 
                        "with(EventHubName='VALUE', EventHubNamespaceConnectionString='VALUE', EventHubConsumerGroupName='VALUE', TargetDatabase='VALUE')", 
                        "with(IngestionSourceType='IotHub', EventHubName='VALUE', EventHubNamespaceConnectionString='VALUE', EventHubConsumerGroupName='VALUE', PartitionCount='VALUE', TargetDatabase='VALUE')"
                    ], System.String);
                    this.s_withEventHubAlterProperties = System.Array.init(["with(EventHubName='VALUE', EventHubNamespaceConnectionString='VALUE', EventHubConsumerGroupName='VALUE')"], System.String);
                    this.s_installCommandOptions = System.Array.init(["with(KEY='VALUE')", "runners"], System.String);
                    this.s_uninstallCommandOptions = System.Array.init(["runners"], System.String);
                    this.s_migrateServiceCommandOptions = System.Array.init(["to AzurePaas1", "to AzureVMSS"], System.String);
                    this.s_fromServiceKeywordOptions = System.Array.init(["from service"], System.String);
                    this.s_toServiceKeywordOptions = System.Array.init(["to service"], System.String);
                    this.s_createDatabaseCommandOptions = System.Array.init(["in service", "ifNotExists"], System.String);
                    this.s_createServiceAndClusterCommandOptions = System.Array.init(["with(KEY='VALUE')", "ifNotExists"], System.String);
                    this.s_addKeywordOptions = System.Array.init(["add"], System.String);
                    this.s_alterServiceConfigurationPropertiesOptions = System.Array.init(["(PropertyPath='PropertyValue')"], System.String);
                    this.s_alterServiceConfigurationCommandOptions = System.Array.init(["with(KEY='VALUE')", "applynow"], System.String);
                    this.s_tableKeywordOptions = System.Array.init(["table"], System.String);
                    this.s_recordsKeywordOptions = System.Array.init(["records"], System.String);
                    this.s_inKeywordOptions = System.Array.init(["in"], System.String);
                    this.s_loadBalancerKeywordOptions = System.Array.init(["load balancer"], System.String);
                    this.s_operationKeywordOptions = System.Array.init(["operation"], System.String);
                }
            }
        },
        ctors: {
            $ctor1: function (accounts, services, connectionContext) {
                if (connectionContext === void 0) { connectionContext = null; }
                var $t;

                this.$initialize();
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ctor.call(this);
                this.Locker;
                {
                    if (this.CommandRules == null || this.GeneralRules == null) {
                        this.LoadRulesUnderLock(accounts, services);
                    }
                }
                if (this.CommandToolTips == null) {
                    this.LoadCommandToolTips();
                }

                this.ContextConnection = ($t = connectionContext, $t != null ? $t : "");
            },
            ctor: function (other) {
                this.$initialize();
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ctor.call(this);
                this.ContextConnection = other.ContextConnection;
                this.Initialize();
                other.Locker;
                {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.IntelliSenseRule, other.CommandRules)) {
                        this.CommandRules.AddRange(other.CommandRules);
                    }
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.IntelliSenseRule, other.GeneralRules)) {
                        this.GeneralRules.AddRange(other.GeneralRules);
                    }
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.IntelliSenseCommandTip, other.CommandToolTips)) {
                        this.CommandToolTips = System.Linq.Enumerable.from(other.CommandToolTips).toList(Bridge.global.Kusto.Data.IntelliSense.IntelliSenseCommandTip);
                    }
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(Bridge.global.Kusto.Data.IntelliSense.IntelliSenseRule, other.QueryParametersRules)) {
                        this.QueryParametersRules.AddRange(other.QueryParametersRules);
                    }
                }
            }
        },
        methods: {
            ResetState: function () { },
            AnalyzeCommand$1: function (statement, cachedReference) {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.AnalyzedCommand(), $t.Command = statement, $t.Context = Kusto.Data.IntelliSense.KustoCommandContext.Empty, $t);
            },
            AnalyzeCommand: function (command, appendingPart) {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.AnalyzedCommand(), $t.Command = (command.Command || "") + (appendingPart || ""), $t.Context = Kusto.Data.IntelliSense.KustoCommandContext.Empty, $t);
            },
            UpdateProviderAvailableEntities: function (command, commandContext) { },
            Clone: function () {
                return new Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.ctor(this);
            },
            LoadRulesUnderLock: function (accounts, services) {
                var $t, $t1;
                this.CommandRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.GeneralRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.QueryParametersRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                var accountNames = System.Linq.Enumerable.from(accounts).select($asm.$.Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.f1).toList(System.String);
                accountNames.Sort();
                var servicesNames = System.Linq.Enumerable.from(services).select($asm.$.Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.f2).toList(System.String);
                servicesNames.Sort();

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAdminCommandsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_lineWithDotBeginningRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Command, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_adminOperationOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldOperatorsAfterPipe, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_afterPipeRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Operator, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_operatorOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRetryCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRetryPurgeCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryPurgeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryPurgeCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRetryPurgeOperationsInServiceCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryPurgeOperationsInServiceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Service, servicesNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRetryPurgeOperationsInServiceServiceNameCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryPurgeOperationsInServiceServiceNameCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRetryPurgeOperationsInServiceServiceNameFromCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_retryPurgeOperationsInServiceServiceNameFromCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAlterCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldSetCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_setCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_setCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRemoveCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_removeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_removeCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAddServiceServiceNameOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addServiceServiceNameRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addServiceServicenameOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMetadataKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_metadataKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_metadataKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMetadataKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_databaseNameMetadataKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_metadataKeywordOptions), $t.DefaultBeforeApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = "[] ", $t1), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDatabaseMoveCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromServiceKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDatabaseMoveFromServiceCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveDatabaseFromServiceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toServiceKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDatabaseCreateCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createDatabaseCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServiceAndClusterCreateCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createServiceAndClusterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createServiceAndClusterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAddCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDropCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dropCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dropCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMoveCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldOperationKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_cancelServiceOperationRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_operationKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldStorageLogsIntoKeywordsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_storageLogsIntoCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_storageLogsIntoCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldCreateCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_createCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDeleteCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_deleteCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_deleteCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDetachCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_detachCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldCheckCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_checkCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_checkCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServiceKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServiceOrClusterKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_activationCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceOrClusterKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldPrincipalsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_principalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_principalsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_operationsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_operationsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowAccountCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAccountCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAccountCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMoveAccountCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveAccountCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveAccountCommandOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMoveAccountSubscriptionCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveAccountSubscriptionCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_moveAccountSubscriptionCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldFromServiceKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromServiceKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterServiceConfigurationKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAlterServiceConfigurationPropertiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterServiceConfigurationDetailsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterServiceConfigurationPropertiesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAlterServiceConfigurationCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterServiceConfigurationPropertiesKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_alterServiceConfigurationCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));


                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldFromAccountKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromAccountKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowAuditLogCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAuditLogCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowAuditLogFromCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAuditLogFromCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowPurgesCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showPurgesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_fromKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowPurgesFromCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showPurgesFromCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = System.String.format(" @'{0}'", [System.DateTime.format(System.DateTime.getUtcNow(), "yyyy-MM-dd")]), $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldConfigurationKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_configurationKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_configurationKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowAccountsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAccountsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showAccountsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDmServiceAddKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceAddKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceAddKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDmServiceDropKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceDropKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceDropKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDmServiceAlterKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceAlterKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dmServiceAlterKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldConfigurationPropertySetKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_configurationPropertySetKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceConfigurationPropertySetKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldToKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_toKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldConfigurationPropertyWithConsentKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_configurationPropertyWithConsentKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withConsentKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAddKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldConfigurationPropertyDropKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_configurationPropertyDropKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceConfigurationPropertyDropKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountAlterOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountAlterOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountAlterOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountRenameOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountRenameOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountRenameOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountAddOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountAddOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountAddOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountRemoveOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountRemoveOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountRemoveOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountSetOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountSetOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountSetOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldPcCodeKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountSubscriptionAlterKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_pccodeKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServiceAlterOperationsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceAlterOperationsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceAlterOperationsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldInServiceKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_inServiceKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_inServiceKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldStorageAccountsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_storageAccountsKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_storageAccountsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAccountNames, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_accountNamesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, accountNames), $t.DefaultBeforeApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = "[", $t1), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = "] ", $t1), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServicesNames, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_servicesNamesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Service, servicesNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldWithPropertiesSuffix, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withPropertiesSuffixRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withPropertiesSuffixOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldWithEventHubPropertiesSuffix, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withEventHubPropertiesSuffixRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withEventHubProperties), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldShowPrincipalRolesCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showPrincipalRolesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showPrincipalRolesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                var servicesAndOptionsTokens = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showServiceCommandOptions).union(servicesNames);
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServicesNamesCombinedWithOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_servicesNamesToAppendOptionsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, servicesAndOptionsTokens), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldTargetServiceOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showTargetServiceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_showTargetServiceCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldInstallCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceInstallCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_installCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //TODO: REMOVE?
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldReinstallCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceReinstallCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_withPropertiesSuffixOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldUninstallCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceUninstallCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_uninstallCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldMigrateServiceCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceMigrateCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_migrateServiceCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldSetClusterPrincipalsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_setClusterPrincipalsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldSetClusterPrincipalsCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_setClusterPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addSetDropPrincipalsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAddClusterPrincipalsCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addClusterPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addSetDropPrincipalsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDropClusterPrincipalsCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dropClusterPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addSetDropPrincipalsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDropAccountPrincipalsCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dropAccountPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_dropAccountPrincipalsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldTableKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_tableKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldRecordsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeRecordsRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_recordsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldInKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeInDatabaseRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_inKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldDatabaseKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeDatabaseRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_databaseKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldInKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeInServiceRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_inKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServiceKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeServiceRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_serviceKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldServicesNames, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_purgeServiceNameRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Service, servicesNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldAddServiceServiceNameOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addServiceServiceNameRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_addServiceServicenameOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldLoadBalancerKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_loadBalancerKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_loadBalancerKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.CMRuleKind.YieldPipeOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider.s_yieldPipeOptionRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, System.Array.init(["|"], System.String)), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            LoadCommandToolTips: function () {
                var $t;
                var toolTipCommands = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTip)).ctor();
                this.CommandToolTips = toolTipCommands;

                var internalCmDocumentationRoot = "https://kusto.azurewebsites.net/internaldocs/controlCommands/controlcommands_CM_internal.html";
                var externalCmDocumentationRoot = "https://kusto.azurewebsites.net/docs/controlCommands/cm.html";

                {
                    var command = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".restart", $t.NameSuffix = " service", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#restart-service>Click to see documentation</a>", $t.Usage = "<i>.restart service</i> Engine-KustoDev" + ("\n" || "") + "<i>.restart service</i> Engine-KustoDev with(instancename='Kusto.Azure.Svc_IN_11')", $t);
                    toolTipCommands.add(command);
                }

                {
                    var command1 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".reimage", $t.NameSuffix = " service", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#reimage-service>Click to see documentation</a>", $t.Usage = "<i>.reimage service</i> Engine-KustoDev" + ("\n" || "") + "<i>.reimage service</i> Engine-KustoDev with(instancename='Kusto.Azure.Svc_IN_11')", $t);
                    toolTipCommands.add(command1);
                }

                {
                    var command2 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".rebuild", $t.NameSuffix = " service", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#rebuild-service>Click to see documentation</a>", $t.Usage = "<i>.rebuild service</i> Engine-KustoDev" + ("\n" || "") + "<i>.rebuild service</i> Engine-KustoDev with(instancename='Kusto.Azure.Svc_IN_11')", $t);
                    toolTipCommands.add(command2);
                }

                {
                    var command3 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".uninstall", $t.NameSuffix = " service | service runners", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#uninstall-service>.uninstall service</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#uninstall-service-runners>.uninstall service runners</a>", $t);
                    toolTipCommands.add(command3);
                }

                {
                    var command4 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".stop", $t.NameSuffix = " service", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#stop-service>Click to see documentation</a>", $t.Usage = "<i>.stop service</i> Engine-KustoDev", $t);
                    toolTipCommands.add(command4);
                }

                {
                    var command5 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".install", $t.NameSuffix = " service | service runners", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#install-service>.install service</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#install-service-runners>.install service runners</a>", $t);
                    toolTipCommands.add(command5);
                }

                {
                    var command6 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".delete", $t.NameSuffix = " cluster | service | database", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#delete-cluster>Click to see documentation</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#delete-service>Click to see documentation</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#delete-database>.delete database</a>", $t);
                    toolTipCommands.add(command6);
                }

                {
                    var command7 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".check", $t.NameSuffix = " service name availability", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#check-service-name-availability>Click to see documentation</a>", $t.Usage = "<i>.check service name availability</i> MyCoolName", $t);
                    toolTipCommands.add(command7);
                }

                {
                    var command8 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".create", $t.NameSuffix = " service | database | account", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#create-database>.create database</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#create-service>.create service</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#create-account>.create account</a>", $t);
                    toolTipCommands.add(command8);
                }

                {
                    var command9 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".detach", $t.NameSuffix = " account", $t.Summary = "<a href=https://kusto.azurewebsites.net/internaldocs/controlCommands/controlcommands_CM_internal.html#detach-account>Click to see documentation</a>", $t.Usage = "<i>.detach account</i> [Kusto Test]", $t);
                    toolTipCommands.add(command9);
                }

                {
                    var command10 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".alter", $t.NameSuffix = " service | account", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#alter-service-configuration>.alter service configuration</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#alter-account-configuration>.alter account configuration</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#alter-account-admins>.alter account admins</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#alter-account-subscription-pccode>.alter account subscription pccode</a>", $t);
                    toolTipCommands.add(command10);
                }

                {
                    var command11 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".add", $t.NameSuffix = " account | service | database storage accounts | unallocated subscription", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#add-account-contact>.add account contact</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#add-dm-service-storage-accounts>.add dm service storage accounts</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#add-database-storage-accounts>.add database storage accounts</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#add-unallocated-subscription>.add unallocated subscription</a>", $t);
                    toolTipCommands.add(command11);
                }

                {
                    var command12 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".remove", $t.NameSuffix = " account contact | unalloacted subscription", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#remove-account-contact>.remove account contact</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#remove-unallocated-subscription>.remove unallocated subscription</a>", $t);
                    toolTipCommands.add(command12);
                }

                {
                    var command13 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".set service", $t.NameSuffix = " property to value", $t.Summary = "<a href=https://kusto.azurewebsites.net/docs/controlCommands/cm.html#set-service-configuration-property>Click to see documentation</href>", $t.Usage = "<i>.set</i> service Engine-KustoDev InstancesCount to '10'", $t);
                    toolTipCommands.add(command13);
                }

                {
                    var command14 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".recycle", $t.NameSuffix = " service storage accounts", $t.Summary = "<a href=https://kusto.azurewebsites.net/internaldocs/controlCommands/controlcommands_CM_internal.html#recycle-service-storage-accounts>Click to see documentation</href>", $t.Usage = "<i>.recycle</i> service Engine-Aria storage accounts (kuariadb0,kuariadb1) with(storageaccountbasename='kuariadbnew')" + ("\n" || "") + ("\n" || "") + "<i>.recycle</i> service Engine-Aria storage accounts (kuariadb0,kuariadb1) with(storageaccountbasename='kuariadbnew',startindex='1')", $t);
                    toolTipCommands.add(command14);
                }

                {
                    var command15 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".ingest", $t.NameSuffix = " service storage logs", $t.Summary = "<a href=https://kusto.azurewebsites.net/internaldocs/controlCommands/controlcommands_CM_internal.html#ingest-service-storage-logs>Click to see documentation</href>", $t.Usage = "<i>.ingest service</i> Engine-Aria storage logs into service Engine-KustoDev with(starttime='2016-02-02', storageservice='queue')" + ("\n" || "") + ("\n" || "") + "<i>.ingest service</i> Mgmt-Aria storage logs into service Engine-KustoDev with(starttime='2016-1-1 11:05:00.0', endtime='2016-1-1 23:59:59.9', storageservice='blob')", $t);
                    toolTipCommands.add(command15);
                }

                {
                    var command16 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".show", $t.NameSuffix = " service [ServiceName] (configuration | fabriclocks | storage objects | database [DatabaseName] metadata | audit log | purges)", $t.Summary = "Click to see documentation for:" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#show-service>.show service [ServiceName] configuration</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#show-service-fabricklocks>.show service [ServiceName] fabriclocks</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#show-service-storage-objects>.show service [ServiceName] storage objects</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#show-service-metadata>.show service [ServiceName] database [DatabaseName] metadata</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#show-service-audit-log>.show service [ServiceName] audit log from '<StartDate>' to '<EndDate>'</a>" + ("\n" || "") + "<a href=" + (externalCmDocumentationRoot || "") + "#show-service-purges>.show service [ServiceName] purges from '<StartDate>' to '<EndDate>'</a>" + ("\n" || "") + "<a href=" + (internalCmDocumentationRoot || "") + "#show-unallocated-subscriptions>.show unallocated subscriptions</a>", $t.Usage = "<i>.show</i> service Engine-Aria configuration" + ("\n" || "") + "<i>.show</i> service Engine-Aria fabriclocks" + ("\n" || "") + "<i>.show</i> service Engine-Aria storage objects" + ("\n" || "") + "<i>.show</i> service Engine-Aria database aria metadata" + ("\n" || "") + "<i>.show</i> service Engine-Aria audit log from '2017-01-15T12:00' to '2017-01-30T12:30'" + ("\n" || "") + "<i>.show</i> service Engine-Aria purges from '2017-01-15T12:00' to '2017-01-30T12:30'", $t);
                    toolTipCommands.add(command16);
                }

                {
                    var command17 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = ".drop", $t.NameSuffix = " dm service [ServiceName] data obtainer [DataObtainerName]", $t.Summary = "<a href=https://kusto.azurewebsites.net/internaldocs/controlCommands/controlcommands_CM_internal.html#drop-dm-service-data-obtainer>Click to see documentation</href>", $t.Usage = "<i>.drop</i> dm service Ingest-Playground data obtainer SomeObtainerName", $t);
                    toolTipCommands.add(command17);
                }
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.ClusterManagerIntelliSenseRulesProvider, {
        f1: function (account) {
            return account.Name;
        },
        f2: function (service) {
            return service.Name;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRule],
        props: {
            MatchingRegex: null,
            AdditionalOptions: null,
            ContextualOptions: null,
            OverrideOptions: null,
            OptionsKind: 0,
            RequiresFullCommand: {
                get: function () {
                    return true;
                }
            },
            IsContextual: {
                get: function () {
                    return true;
                }
            }
        },
        methods: {
            IsMatch: function (context, input) {
                return this.MatchingRegex.isMatch(input);
            },
            GetOptions: function (context) {
                if (this.AdditionalOptions == null || Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CompletionOptionCollection, this.AdditionalOptions)) {
                    return this.GetContextOptions(context);
                }

                // There are some auto-added options - we will create a new list and return it
                var result = new (System.Collections.Generic.List$1(System.String)).$ctor1(this.GetContextOptions(context));
                return System.Linq.Enumerable.from(result).union(System.Linq.Enumerable.from(this.AdditionalOptions).selectMany($asm.$.Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule.f1));
            },
            GetContextOptions: function (context) {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), this.OverrideOptions) && this.OverrideOptions.containsKey(context)) {
                    return this.OverrideOptions.get(context);
                } else {
                    var contextWithoutOpertaion = new Kusto.Data.IntelliSense.KustoCommandContext(context.Context);
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), this.ContextualOptions) && this.ContextualOptions.containsKey(contextWithoutOpertaion)) {
                        return this.ContextualOptions.get(contextWithoutOpertaion);
                    }
                }

                return System.Array.init([], System.String);
            },
            GetCompletionOptions: function (context) {
                if (this.AdditionalOptions == null || Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CompletionOptionCollection, this.AdditionalOptions)) {
                    var result = System.Linq.Enumerable.from(this.GetContextOptions(context)).select(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule.f2)).ToArray(Kusto.Data.IntelliSense.CompletionOption);
                    return result;
                }

                // There are some auto-added options
                var contextualOptionsCollection = new Kusto.Data.IntelliSense.CompletionOptionCollection(this.OptionsKind, this.GetContextOptions(context));

                // Order the completion option collections by their priority
                var sortedCollections = System.Linq.Enumerable.from(function (_o1) {
                            _o1.add(contextualOptionsCollection);
                            return _o1;
                        }(new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CompletionOptionCollection)).ctor())).concat(this.AdditionalOptions).orderByDescending($asm.$.Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule.f3);

                return sortedCollections.selectMany($asm.$.Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule.f4);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule, {
        f1: function (o) {
            return o.Values;
        },
        f2: function (o) {
            return new Kusto.Data.IntelliSense.CompletionOption(this.OptionsKind, o);
        },
        f3: function (o) {
            return o.Priority;
        },
        f4: function (c) {
            return c.GetCompletionOptions();
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRule],
        statics: {
            methods: {
                GetHashStringForContextAndToken: function (context, token) {
                    return (context || "") + ";" + (token || "");
                }
            }
        },
        props: {
            MatchingRegex: null,
            MatchingTokens: null,
            GroupNameToUseAfterMatch: null,
            Options: null,
            RequiresFullCommand: {
                get: function () {
                    return true;
                }
            },
            IsContextual: {
                get: function () {
                    return true;
                }
            }
        },
        methods: {
            IsMatch: function (context, input) {
                if (this.MatchingTokens == null || !System.Linq.Enumerable.from(this.MatchingTokens).any() || System.String.isNullOrEmpty(this.GroupNameToUseAfterMatch)) {
                    return false;
                }

                var m = this.MatchingRegex.match(input);
                if (!m.getSuccess() || m.getGroups().getCount() < 1) {
                    return false;
                }

                var matchedString = Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule.GetHashStringForContextAndToken(context.Context, m.getGroups().getByName(this.GroupNameToUseAfterMatch).toString());
                return this.MatchingTokens.contains(matchedString);
            },
            GetOptions: function (context) {
                return this.Options.Values;
            },
            GetCompletionOptions: function (context) {
                return this.Options.GetCompletionOptions();
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase],
        statics: {
            fields: {
                /**
                 * Matches pipe and one-or-more spaces after it
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_afterPipeRegex: null,
                /**
                 * Matches 'render' operator
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_renderRegex: null,
                /**
                 * Matches specific charts (areachart, barchart, columncharts) that may have kind= specifications
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_renderMultiChartsRegex: null,
                /**
                 * Matches specific charts (areachart, barchart, columncharts) that may have kind= specifications
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_renderKindOptionsRegex: null,
                /**
                 * Matches 'evaluate' operator
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_evaluateRegex: null,
                /**
                 * Matches 'make-series' operator (similar to summarize regex but minding also 'on'/'in range' and 'default')
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesRequestingAggregatorsRegex: null,
                /**
                 * Matches 'make-series' operator right after aggregation function before 'default' keyword
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesBeforeDefaultOrOnRegex: null,
                /**
                 * Matches 'make-series' operator right after aggregation function before 'on' keyword
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesBeforeOnRegex: null,
                /**
                 * Matches 'make-series' operator right after aggregation function before 'range' keyword
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesBeforeRangeRegex: null,
                /**
                 * Matches 'make-series' operator right after aggregation function before 'by' keyword
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesBeforeByRegex: null,
                /**
                 * Matches 'join' operator
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_joinRegex: null,
                /**
                 * Matches 'split=' diffpatterns plugin required parameter
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_diffPatternsPluginSplitParameterRegex: null,
                s_startOfLineWithSpaceOrAfterJoinRegex: null,
                s_startOfCommandWithClusterRegex: null,
                s_tablesScopeRegex: null,
                s_startOfCommandWithDatabaseRegex: null,
                s_clusterFunctionRegex: null,
                s_databaseFunctionInFindRegex: null,
                s_databaseFunctionRegex: null,
                /**
                 * It's a time for the Column options. Matches one of next:
                 1) 'filter' or 'where' followed by one-or-more spaces
                 2) 'filter' followed by text without '|' THEN 'and' keyword THEN one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForFilterColumnRegex: null,
                /**
                 * 1) 'project' followed by one-or-more spaces
                 2) 'project' followed by text without '|' and then ',' with one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForProject: null,
                /**
                 * 1) 'project-away' followed by one-or-more spaces
                 2) 'project-away' followed by text without '|' and then ',' with one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForProjectAway: null,
                /**
                 * 1) 'project-rename' followed by assignment operator: '='
                 2) 'project-rename' followed by text without '|' and then ',' with one-or-more spaces, and then followed by assignement operator '='
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForProjectRename: null,
                /**
                 * Matches one of the next and suggests column options: 
                 1) 'find' ... 'where' followed by one-or-more spaces
                 2) 'find' followed by text without '|' THEN 'and' keyword THEN one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForFilterColumnInFindRegex: null,
                /**
                 * Matches
                 1) 'find' ... 'project' followed by one-or-more spaces
                 2) 'find' ... 'project' followed by text without '|' and then ',' with one-or-more spaces
                 Should suggest column names
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForFindProject: null,
                s_singleParamFunctions: null,
                /**
                 * Matches expressions that would receive functions or columns as input
                 1) count(, max(, min(, strlen( ...
                 2) 'summarize' followed by 'by' THEN one-or-more spaces
                 3) 'summarize' followed by 'by' THEN ',' THEN ) and ','
                 4) 'summarize' followed by 'by' THEN ',' THEN one-or-more spaces (without 'bin' afterwards)
                 5) 'distinct' followed by one-or-more column-separated column names
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_singleParamFunctionsColumnContextRegex: null,
                s_twoParamFunctions: null,
                /**
                 * Matches 2 parameter operators [e.g. percentile(]
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_twoParamFunctionsColumnContextRegex: null,
                s_threeParamFunctions: null,
                /**
                 * Matches 3 parameter operators [e.g. iff(]
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_threeParamFunctionsColumnContextRegex: null,
                s_manyParamFunctions: null,
                /**
                 * Matches N parameter operators [e.g. strcat(]
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_manyParamFunctionsColumnContextRegex: null,
                /**
                 * 1) 'extend' followed by arithmetic operator: '=', '-', '+', '/', '*'
                 2) 'project' followed by assignment operator: '='
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForExtend_ColumnAndFunctionRegex: null,
                /**
                 * 'join' followed by 'on'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_entitiesForJoin_ColumnsRegex: null,
                /**
                 * 'join' followed by 'kind'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_joinFlavorsForJoin_Regex: null,
                /**
                 * 'parse' followed by 'kind' then followed by requested kind :  = simple or = regex or = relaxed
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_parseKindChoose_Regex: null,
                /**
                 * 'parse' followed by 'kind' followed by regex or simple followed by with
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_parseWith_Regex: null,
                /**
                 * suggesting supported types in parse
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_parseTypesSuggest_Regex: null,
                /**
                 * suggests adding '*' in the pattern (after stringLiteral or columnType or at the beginning).
                 'parse' (kind = simple|regex|relaxed)? Expr with * StringColumn "... * ....
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_parseStarOption_Regex: null,
                /**
                 * Matches cases when aggregation operators should be shown. The next matches one of next cases:
                 1) 'summarize' THEN (one-or-more spaces or variable with '=')
                 2) 'summarize' THEN text without '|' and without 'by' ENDING with ',' and (one-or-more spaces or variable with '=')
                 3) 'summarize' THEN text without '|' and without 'by' ENDING with '[+-/*]' and zero-or-more spaces
                 4) 'top-nested'/'top-hitters' N of Column by renamingColumn = Aggregator 
                 5) 'top-nested'/'top-hitters' N of Column by Aggregator with [+/-*]
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                m_commandsRequestingAggregators: null,
                s_lineWithDotBeginningRegex: null,
                /**
                 * Matches 'top' or 'limit' or 'take' or 'top-nested' or 'top-hitters' or 'sample' or 'sample-distinct'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topOrLimitOrTakeOrSampleRegex: null,
                /**
                 * Matches 'ago('
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_agoContextRegex: null,
                /**
                 * Matches 'now('
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_nowContextRegex: null,
                /**
                 * 'top-nested' / 'top-hitters' followed by topCount and then one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForTopNestedAndTopHitters: null,
                /**
                 * 'sample-distinct' followed by count and then one-or-more spaces
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_operatorContextForSampleDistinct: null,
                /**
                 * allows multiple levels of top-nested:
                 top-nested N1 of Col1 by Agg1 , top-nested ...
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topNestedKeywordPrefixRegex: null,
                /**
                 * allows multiple levels of top-nested:
                 top-nested N1 of Col1 by Agg1 , top-nested ...
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topNestedWithOthersOption: null,
                /**
                 * top-hitters N1 of Col1 by Agg1
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topHittersKeywordPrefixRegex: null,
                /**
                 * Matches 'top', 'sort', 'order', 'reduce', 'top-nested', 'top-hitters'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_yieldByKeywordRegex: null,
                /**
                 * Matches columns for parse  operator
                 'parse (kind = (simple|regex))? [column]'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_parseColumnContextRegex: null,
                /**
                 * Matches columns for parse  operator
                 'parse (kind = (simple|regex))? [column]'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_renderTimePivotColumnContextRegex: null,
                /**
                 * Matches columns for top operator
                 'top', 'sort', 'order', 'reduce' THEN [number] by ...
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topSortOrderReduceByRegex: null,
                /**
                 * Matches 'top', 'top-nested', 'sort', 'order' THEN [number] by [Column] THEN 'asc','desc'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topTopNestedSortOrderByAscDescRegex: null,
                /**
                 * Matches
                 'find' 
                 'find' withsource=[columnName]
                 Should suggest 'in' and 'where'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_findContextRegex: null,
                /**
                 * Matches
                 'find' 'in' ...
                 'find' withsource=[columnName] 'in' ...
                 Should suggest brackets () where
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_findInRegex: null,
                /**
                 * Matches
                 'find' ... 'in' '(' zero-or-more spaces
                 'find' ... 'in' '(' THEN text without '|' THEN ',' with one-or-more spaces
                 Should suggest a table name
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_findInStartOrContinueListRegex: null,
                /**
                 * Matches 'find' THEN 'in' THEN '('[Table], [Table] ...
                 Matches 'find' THEN withsource=[columnName] THEN 'in' THEN '('[Table], [Table]...
                 Should suggest a comma and a closing bracket
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_FindInEndOrContinueListRegex: null,
                /**
                 * Matches 'find' ... 'in' '(' ... ')'...
                 Should suggest the 'where' keyword
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_findWhereRegex: null,
                /**
                 * Matches 'find' ... 'project-smart'...
                 Should suggest '|'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_findProjectSmartRegex: null,
                /**
                 * Matches columns for reduce by operator
                 'reduce by [column]' and offers kind
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_reduceByColumnContextRegex: null,
                /**
                 * Matches columns for 'top-nested' operator
                 'top-nested' topCount THEN of ...
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topNestedSuggestingColumnsRegex: null,
                /**
                 * Matches columns for 'top-hitters' operator
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topHittersSuggestingColumnsRegex: null,
                /**
                 * Matches columns for 'sample-distinct' operator
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_sampleDistinctSuggestingColumnsRegex: null,
                /**
                 * Matches columns for top operator
                 'top' THEN [number] by ...
                 'sort' 'by' Column
                 'order' 'by' Column
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topOrOrderAscendingDescendingRegex: null,
                /**
                 * Matches optional asc or desc (optional)
                 for 'top-nested'.
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_topNestedAscendingDescendingRegex: null,
                s_rangeFromRegex: null,
                s_rangeFromToRegex: null,
                s_rangeFromToStepRegex: null,
                s_filteredColumnString: null,
                /**
                 * Matches column name for filtering
                 '| where [column_name] '
                 '| where [predicate] and [column_name] '
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_filteredColumnRegex: null,
                /**
                 * Matches column name for filtering and comparison operator
                 '| where [column_name] == '
                 '| where [predicate] and [column_name] &gt; '
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_filterPredicateRightValueRegex: null,
                /**
                 * Matches columns for make-series operator. It should be:
                 'make-series' [aggregations] on [column choosing here] in range([expression], [expression], [expression]) by [column choosing here], [column choosing here]...
                 We use more lax requirement here, not realy checking for proper expressions, just excluding '|' from match
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_makeSeriesByRegex: null,
                /**
                 * Matches kind=case_sensitive / kind=case_insensitive
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @default "(^|;|\\|)\\s*search\\s+"
                 * @type string
                 */
                s_searchPrefixRegex: null,
                /**
                 * Matches
                 'search' followed by one-or-more spaces
                 Suggests "", *, in, columns, scalar functions, kind
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_searchContextRegex: null,
                /**
                 * Matches kind=case_sensitive / kind=case_insensitive
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @default "(kind\\s*=\\s*(case_sensitive|case_insensitive)\\s+)"
                 * @type string
                 */
                s_searchKindRegex: null,
                /**
                 * Matches
                 'search kind=case_sensitive ' / 'search kind=case_insensitive '
                 Suggests "", *, in, columns, scalar functions (no 'kind')
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_searchAfterKindContextRegex: null,
                /**
                 * Matches
                 1. 'search ... and' or 'search ... or'
                 2. 'search ... in () '
                 Suggests "", *, columns, scalar functions (no 'kind', no 'in')
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_searchMoreContextRegex: null,
                /**
                 * 'search' followed by 'kind'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_searchKind_Regex: null,
                /**
                 * client directives start with '#'
                 *
                 * @static
                 * @private
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @type System.Text.RegularExpressions.Regex
                 */
                s_clientDirective_Regex: null,
                s_clientDirectiveConnect_Regex: null,
                s_operatorOptions: null,
                s_renderOptions: null,
                s_renderKindOptions: null,
                s_aggregateOperationOptions: null,
                s_makeSeriesAggregateOperationOptions: null,
                s_extendOperationOptions: null,
                s_databaseFunctionOptions: null,
                s_stringOperatorOptions: null,
                s_numericOperatorOptions: null,
                s_numericScalarsOptions: null,
                s_byKeywordOptions: null,
                s_kindChooseKeywordOptions: null,
                s_withOthersKeywordOptions: null,
                s_ofKeywordOptions: null,
                s_withKeywordOptions: null,
                s_parseSuggestedTypesKeywordOptions: null,
                s_parseStarOption: null,
                s_ascDescKeywordOptions: null,
                s_nullsLastFirstKeywordOptions: null,
                s_ascDescOrNullsLastNullsFirstKeywordOptions: null,
                s_rangeFromOptions: null,
                s_rangeFromToOptions: null,
                s_rangeFromToStepOptions: null,
                s_joinFlavorsOptions: null,
                s_postJoinOptions: null,
                s_kindKeywordOptions: null,
                s_searchInKeywordOptions: null,
                s_searchLiteralsOptions: null,
                s_reduceByFlavorsOptions: null,
                s_datetimeOptions: null,
                s_timespanOptions: null,
                s_negativeTimespanOptions: null,
                s_postFindInOptions: null,
                s_findInEndOrContinueOptions: null,
                s_findWhereInOptions: null,
                s_findInPostListOptions: null,
                s_makeSeriesDefaultOrOnOptions: null,
                s_makeSeriesOnOptions: null,
                s_makeSeriesInRangeOptions: null,
                s_searchKindOptions: null,
                s_clientDirectivesOptions: null,
                MultiColumnFunctionResultSuffixes: null,
                s_afterFunctionsApplyPolicies: null,
                s_filterKeywords: null,
                s_projectKeywords: null,
                s_projectAwayKeywords: null,
                s_projectRenameKeywords: null,
                s_projectExtendKeywords: null,
                s_joinKeywords: null,
                s_topSortOrderReduceKeywords: null,
                s_operatorsUsingByKeywordKeywords: null,
                s_topSortOrderKeywords: null,
                s_topTopNestedSortOrderKeywords: null,
                s_reduceKeywords: null,
                s_parseKeywords: null,
                s_renderKeywords: null,
                s_topLimitTakeSampleKeywords: null,
                s_evaluateKeywords: null,
                s_summarizeKeywords: null,
                s_distinctKeywords: null,
                s_topNestedKeywords: null,
                s_topHittersKeywords: null,
                s_sampleDistinctKeywords: null,
                s_operatorsRequestingAggregators: null,
                s_databaseKeywords: null,
                s_findKeywords: null,
                s_searchKeywords: null,
                s_makeSeriesKeywords: null,
                s_remoteContextRegex: null,
                s_queryParametersRegex: null,
                s_joinClosureRegex: null,
                s_joinWithMakeSeriesClosureRegex: null,
                s_makeSeriesStartRegex: null,
                s_findSubClausesRegex: null,
                s_searchSubClausesRegex: null,
                s_rangeEntitiesRegex: null,
                s_parsedEntitiesRegex: null,
                s_removeStringLiteralsRegex: null,
                s_removeStringLiteralsSurroundedBySpacesRegex: null,
                s_removeCommentsRegex: null,
                s_fieldInvalidCharacters: null,
                s_fieldQuotableCharacters: null,
                s_aggregateOperatorToColumnPrefixMapping: null,
                s_lastCommandSegmentRegex: null,
                s_incompleteJoinRegex: null,
                s_commandClausesRegex: null,
                s_operatorsReplacingEntities: null,
                s_withsourceExtractRegex: null,
                s_findProjectionRegex: null,
                s_packRgx: null,
                s_topNestedLevelExtractRegex: null,
                s_sampleDistinctEntityExtractRegex: null,
                s_aggregateOperatorsHash: null,
                s_byKeywordRegex: null,
                s_byAndOnKeywordRegex: null,
                s_makeSeriesDropNonFieldsRegex: null,
                s_fieldMatchingRegex: null,
                s_numericSuffixRegex: null,
                s_defaultContextPattern: null,
                s_commandContext_Join: null,
                s_commandContext_Union: null,
                s_commandContext_ToScalar: null,
                s_commandContext_Show: null,
                s_commandContext_Range: null,
                s_commandContext_Callable: null,
                s_commandContext_Let: null,
                s_commandContext_ConnectDirective: null,
                s_commandContext_Find: null,
                s_commandContext_Search: null,
                s_commandDefaultContext: null,
                s_twoOrMoreSpacesRegex: null,
                s_showCommandFixRegex: null,
                s_commandContextRegexes: null,
                s_nonDefaultContextKeywordsRegex: null,
                s_letVariableRegex: null,
                s_letStatementRegexList: null
            },
            props: {
                Operators: {
                    get: function () {
                        return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorOptions;
                    }
                }
            },
            ctors: {
                init: function () {
                    this.s_afterPipeRegex = new System.Text.RegularExpressions.Regex.ctor("\\|\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_renderRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)render\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_renderMultiChartsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)render\\s+(areachart|barchart|columnchart)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_renderKindOptionsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)render\\s+(areachart|barchart|columnchart)\\s+kind\\s*=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_evaluateRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)evaluate\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesRequestingAggregatorsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)make-series\\s+(\\w+\\s*?=\\s*?)?$|(^|\\|\\s*?)make-series\\s+(?!.*\\b(by|on|range|in)\\b).*?,\\s+(\\w+\\s*?=\\s*?)?$|(^|\\|\\s*?)make-series\\s+(?!.*\\b(by|on|range|in)\\b).*[+*/\\-]\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesBeforeDefaultOrOnRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)make-series(?!.*\\b(by|on|range|in).*)(.*\\))\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesBeforeOnRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)make-series\\s+(?!.*\\b(range|on).*)(.*\\bdefault\\b\\s*\\=\\s*\\w+)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesBeforeRangeRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)make-series(?!.*\\b(range).*)(.*\\bon\\b\\s+.*)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesBeforeByRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)make-series(?!.*\\b(by).*)(.*\\bin\\s+range\\b\\s*\\(.*,.*,.*\\))\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_joinRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)join\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_diffPatternsPluginSplitParameterRegex = new System.Text.RegularExpressions.Regex.ctor("diffpatterns\\(\"split=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_startOfLineWithSpaceOrAfterJoinRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*$|join\\s+.*?\\(\\s+$|^\\s*let\\s+\\w+\\s*=\\s+$|toscalar\\(\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_startOfCommandWithClusterRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*|join\\s+.*?\\(\\s+|^\\s*let\\s+\\w+\\s*=\\s+|toscalar\\(\\s*|;\\s+)cluster\\($", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_tablesScopeRegex = "(((cluster\\([^\\)]+\\)\\.)?(database\\([^\\)]+\\)\\.)?(\\[.+?\\]|[\\w\\d\\*]+),\\s*)*((cluster\\([^\\)]+\\)\\.)?(database\\([^\\)]+\\)\\.)?(\\[.+?\\]|[\\w\\d\\*]+)))";
                    this.s_startOfCommandWithDatabaseRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*|join\\s+.*?\\(\\s+|find\\s+in\\s*\\(|find\\s+in\\s*\\(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + ",\\s*|" + "^\\s*let\\s+\\w+\\s*=\\s+|" + "toscalar\\(\\s*|" + ";\\s+|" + "cluster\\([^\\)]+?\\)\\." + ")" + "database\\($", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_clusterFunctionRegex = new System.Text.RegularExpressions.Regex.ctor("cluster\\([^\\)]+\\)\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_databaseFunctionInFindRegex = new System.Text.RegularExpressions.Regex.ctor("find\\s+in\\s*\\([^\\|]*database\\([^\\)]+\\)\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_databaseFunctionRegex = new System.Text.RegularExpressions.Regex.ctor("database\\([^\\)]+\\)\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForFilterColumnRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(filter|where)\\s+$|(^|\\|\\s*?)(filter|where)\\s+[^\\|]+(and|or)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForProject = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)project\\s+$|(^|\\|\\s*?)project\\s+[^\\|]*,\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForProjectAway = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)project-away\\s+$|(^|\\|\\s*?)project-away\\s+[^\\|]*,\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForProjectRename = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)project-rename\\s+[^\\|]*?\\=\\s*$|(^|\\|\\s*?)project-rename\\s+[^\\|]*,\\s+[^\\|]*?\\=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForFilterColumnInFindRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+[^\\|]*where\\s+$|(^|\\s*)find\\s+[^\\|]+(and|or)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForFindProject = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+[^\\|]+project\\s+$|(^|\\s*)find\\s+[^\\|]+project\\s+[^\\|]*,\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_singleParamFunctions = Bridge.toArray(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SingleParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationSingleParameterTokens)).join("\\(|");
                    this.s_singleParamFunctionsColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("\\b(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_singleParamFunctions || "") + "\\()\\s*$|" + "(^|\\|\\s*?)summarize\\s+[^\\|]*?by\\s+$|" + "(^|\\|\\s*?)summarize\\s+[^\\|]*\\)\\s*,\\s+$|" + "(^|\\|\\s*?)summarize\\s+[^\\|]*?by\\s+(?!bin)[^\\|]+,\\s+$|" + "(^|\\|\\s*?)distinct\\s+([^\\|]+,\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_twoParamFunctions = Bridge.toArray(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.TwoParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationTwoParametersTokens)).join("\\(|");
                    this.s_twoParamFunctionsColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_twoParamFunctions || "") + "\\()\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_threeParamFunctions = Bridge.toArray(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ThreeParameterFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationThreeParametersTokens)).join("\\(|");
                    this.s_threeParamFunctionsColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_threeParamFunctions || "") + "\\()\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_manyParamFunctions = Bridge.toArray(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.ManyParametersFunctionsTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationManyParametersTokens)).join("(\\(|[^\\)]+,)|");
                    this.s_manyParamFunctionsColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_manyParamFunctions || "") + "\\()\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForExtend_ColumnAndFunctionRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)extend\\s+[^\\|]*?[\\=\\-\\+\\/\\*]\\s*$|(^|\\|\\s*?)project\\s+[^\\|]*?\\=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_entitiesForJoin_ColumnsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)join\\s+.*\\(.+\\)\\s+on\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_joinFlavorsForJoin_Regex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)join\\s+kind\\s*=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parseKindChoose_Regex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)parse\\s+kind\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parseWith_Regex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)parse\\s*(kind\\s*=\\s*\\w+(\\s*flags\\s*=\\s*\\w+)?\\s*)?\\s*(\\w+|\".*?\")\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parseTypesSuggest_Regex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)parse\\s+.*\\swith\\s+.*\\s*:\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parseStarOption_Regex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)parse(.+?)with(.+?[^\\*\\s])?\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.m_commandsRequestingAggregators = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)summarize\\s+(\\w+\\s*?=\\s*?)?$|(^|\\|\\s*?)summarize\\s+(?!.*\\bby\\b).*,\\s+(\\w+\\s*?=\\s*?)?$|(^|\\|\\s*?)summarize\\s+(?!.*\\bby\\b).*[+*/\\-]\\s*$|(^|\\|\\s*?).*top-(nested|hitters).*\\s+by\\s+(\\w+\\s*?=\\s*\\s*?)?$|(^|\\|\\s*?).*top-(nested|hitters).*\\s+by\\s+.*?[+*/\\-]\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_lineWithDotBeginningRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topOrLimitOrTakeOrSampleRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(top|.*top-hitters|limit|take|.*top-nested|sample|sample-distinct)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_agoContextRegex = new System.Text.RegularExpressions.Regex.ctor("\\bago\\(\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_nowContextRegex = new System.Text.RegularExpressions.Regex.ctor("\\bnow\\(\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForTopNestedAndTopHitters = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*top-(nested|hitters)\\s+\\d+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorContextForSampleDistinct = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*sample-distinct\\s+\\d+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topNestedKeywordPrefixRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)top-nested.*by.*(\\d|\\)|asc|desc)\\s*,\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topNestedWithOthersOption = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)top-nested.*?of\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topHittersKeywordPrefixRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)top-hitters.*by.*(\\d|\\))\\s*,\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_yieldByKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(top\\s+\\d+|.*top-hitters.*of\\s+\\w+|.*top-nested.*of\\s+[\\w,\\(\\)]+\\s*(with others\\s*=\\s*\\w+\\s*)?|distinct|sort|order|reduce|render\\s+timepivot)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parseColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)parse\\s+(kind\\s*=\\s*\\w+\\s*(flags\\s*=\\s*\\w+\\s*)?\\s*)?\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_renderTimePivotColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)render\\s+timepivot\\s+by(.*,)?\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topSortOrderReduceByRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(top\\s+\\d+|sort|order|reduce)\\s+by\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topTopNestedSortOrderByAscDescRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)((top\\s+\\d+|sort|order).*?by.*?(asc|desc))[ ]+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findContextRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+(withsource\\s*\\=\\s*\\w+\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findInRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+(withsource\\s*\\=\\s*[^\\|\\(\\)]*\\s+)?in\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findInStartOrContinueListRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+[^\\|\\(\\)]*in\\s*\\(\\s*(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + ",\\s+)?\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_FindInEndOrContinueListRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+(withsource\\s*\\=\\s*\\w+\\s+)?in\\s*\\(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findWhereRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+[^\\|\\(\\)]*in\\s*\\(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "\\)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findProjectSmartRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*)find\\s+[^\\|]*\\s+project\\-smart\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_reduceByColumnContextRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)reduce\\s+by\\s+\\w+\\s+kind\\s*=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topNestedSuggestingColumnsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*top-nested.*of\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topHittersSuggestingColumnsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*top-hitters.*of\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_sampleDistinctSuggestingColumnsRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*sample-distinct.*of\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topOrOrderAscendingDescendingRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(top\\s+\\d+|sort|order)\\s+by\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topNestedAscendingDescendingRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?).*top-nested.*by\\s+.*(\\)|\\d)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_rangeFromRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*|join\\s+\\(\\s+|;\\s*)range\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_rangeFromToRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*|join\\s+\\(\\s+|;\\s*)range\\s+\\w+\\s+from(?!.*\\bto)\\s+[^|]*[\\w\\)]+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_rangeFromToStepRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*|join\\s+\\(\\s+|;\\s*)range(?!.*step)\\s+\\w+\\s+from\\s+[^|]+to\\s+[^|]+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_filteredColumnString = "((^|\\|\\s*?)(filter|where)|\\b(and|or))\\s+(?<MatchingString>\\S+?)\\s+";
                    this.s_filteredColumnRegex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filteredColumnString || "") + "$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_filterPredicateRightValueRegex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filteredColumnString || "") + "(\\=\\=|\\!\\=|\\>|\\<|\\<\\=|\\>\\=)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_makeSeriesByRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\|\\s*?)(make-series\\s+[^\\|]*\\bon\\s+[^\\|]+\\s+in\\s+range\\b\\([^\\|]+,[^\\|]+\\,[^\\|]+\\))\\s+by\\s+$|(^|\\|\\s*?)(make-series\\s+[^\\|]*\\bon\\s+[^\\|]+\\s+in\\s+range\\b\\([^\\|]+,[^\\|]+\\,[^\\|]+\\))\\s+by\\s+[^\\|]+?,\\s+$|(^|\\|\\s*?)(make-series\\s+[^\\|]*\\bon\\b)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_searchPrefixRegex = "(^|;|\\|)\\s*search\\s+";
                    this.s_searchContextRegex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchPrefixRegex || "") + "$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_searchKindRegex = "(kind\\s*=\\s*(case_sensitive|case_insensitive)\\s+)";
                    this.s_searchAfterKindContextRegex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchPrefixRegex || "") + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKindRegex || "") + "$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_searchMoreContextRegex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchPrefixRegex || "") + "[^\\|]+(and|or)\\s+$|" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchPrefixRegex || "") + "[^\\|\\(\\)]*in\\s*\\(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "\\)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_searchKind_Regex = new System.Text.RegularExpressions.Regex.ctor((Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchPrefixRegex || "") + "kind\\s*=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_clientDirective_Regex = new System.Text.RegularExpressions.Regex.ctor("^\\s*#$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_clientDirectiveConnect_Regex = new System.Text.RegularExpressions.Regex.ctor("^\\s*#connect\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorOptions = Kusto.Data.IntelliSense.CslCommandParser.PromotedOperatorCommandTokens;
                    this.s_renderOptions = Kusto.Data.IntelliSense.CslCommandParser.ChartRenderTypesTokens;
                    this.s_renderKindOptions = Kusto.Data.IntelliSense.CslCommandParser.ChartRenderKindTokens;
                    this.s_aggregateOperationOptions = Kusto.Data.IntelliSense.CslCommandParser.SortedSummarizeAggregators;
                    this.s_makeSeriesAggregateOperationOptions = Kusto.Data.IntelliSense.CslCommandParser.SortedMakeSeriesAggregationTokens;
                    this.s_extendOperationOptions = Kusto.Data.IntelliSense.CslCommandParser.SortedExtendFunctions;
                    this.s_databaseFunctionOptions = System.Array.init(["database()"], System.String);
                    this.s_stringOperatorOptions = System.Array.init(["==", "!=", "has", "contains", "startswith", "matches regex", "endswith", "!has", "!contains", "=~", "!~", "in", "!in", "has_cs", "!has_cs", "contains_cs", "!contains_cs", "!startswith", "!endswith", "hasprefix", "!hasprefix", "hassuffix", "!hassuffix"], System.String);
                    this.s_numericOperatorOptions = System.Array.init(["==", "!=", ">", "<", "<=", ">="], System.String);
                    this.s_numericScalarsOptions = System.Array.init(["1", "10", "100", "1000"], System.String);
                    this.s_byKeywordOptions = System.Array.init(["by"], System.String);
                    this.s_kindChooseKeywordOptions = System.Array.init(["= simple", "= regex", "= relaxed"], System.String);
                    this.s_withOthersKeywordOptions = System.Array.init(["with others = "], System.String);
                    this.s_ofKeywordOptions = System.Array.init(["of"], System.String);
                    this.s_withKeywordOptions = System.Array.init(["with"], System.String);
                    this.s_parseSuggestedTypesKeywordOptions = System.Array.init(["long", "int64", "real", "double", "string", "time", "timespan", "date", "datetime", "int"], System.String);
                    this.s_parseStarOption = System.Array.init(["*"], System.String);
                    this.s_ascDescKeywordOptions = System.Array.init(["asc", "desc"], System.String);
                    this.s_nullsLastFirstKeywordOptions = System.Array.init(["nulls last", "nulls first"], System.String);
                    this.s_ascDescOrNullsLastNullsFirstKeywordOptions = System.Array.init(["asc", "desc", "nulls last", "nulls first"], System.String);
                    this.s_rangeFromOptions = System.Array.init(["from"], System.String);
                    this.s_rangeFromToOptions = System.Array.init(["to"], System.String);
                    this.s_rangeFromToStepOptions = System.Array.init(["step"], System.String);
                    this.s_joinFlavorsOptions = Kusto.Data.IntelliSense.CslCommandParser.JoinKindTokens;
                    this.s_postJoinOptions = System.Array.init(["(", "kind="], System.String);
                    this.s_kindKeywordOptions = System.Array.init(["kind="], System.String);
                    this.s_searchInKeywordOptions = System.Array.init(["in"], System.String);
                    this.s_searchLiteralsOptions = System.Array.init(["\"\"", "*"], System.String);
                    this.s_reduceByFlavorsOptions = Kusto.Data.IntelliSense.CslCommandParser.ReduceByKindTokens;
                    this.s_datetimeOptions = Kusto.Data.IntelliSense.CslCommandParser.SortedDatetimeFunctions;
                    this.s_timespanOptions = System.Array.init(["30m", "1h", "12h", "1d", "3d", "7d"], System.String);
                    this.s_negativeTimespanOptions = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_timespanOptions).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f1).ToArray(System.String);
                    this.s_postFindInOptions = System.Array.init(["("], System.String);
                    this.s_findInEndOrContinueOptions = System.Array.init([")", ","], System.String);
                    this.s_findWhereInOptions = System.Array.init(["where", "in"], System.String);
                    this.s_findInPostListOptions = System.Array.init(["where"], System.String);
                    this.s_makeSeriesDefaultOrOnOptions = System.Array.init(["on", "default="], System.String);
                    this.s_makeSeriesOnOptions = System.Array.init(["on"], System.String);
                    this.s_makeSeriesInRangeOptions = System.Array.init(["in range()"], System.String);
                    this.s_searchKindOptions = System.Array.init(["case_sensitive", "case_insensitive"], System.String);
                    this.s_clientDirectivesOptions = System.Array.init(["connect"], System.String);
                    this.MultiColumnFunctionResultSuffixes = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f2(new (System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.String)))());
                    this.s_afterFunctionsApplyPolicies = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SortedExtendFunctions).toDictionary($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f3, $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f4, System.String, Bridge.global.Kusto.Data.IntelliSense.ApplyPolicy);
                    this.s_filterKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f5(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_projectKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f6(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_projectAwayKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f7(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_projectRenameKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f8(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_projectExtendKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f9(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_joinKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f10(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topSortOrderReduceKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f11(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_operatorsUsingByKeywordKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f12(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topSortOrderKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f13(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topTopNestedSortOrderKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f14(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_reduceKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f15(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_parseKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f16(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_renderKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f17(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topLimitTakeSampleKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f18(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_evaluateKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f19(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_summarizeKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f20(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_distinctKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f21(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topNestedKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f22(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_topHittersKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f23(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_sampleDistinctKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f24(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_operatorsRequestingAggregators = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f25(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_databaseKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f26(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_findKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f27(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_searchKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f28(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_makeSeriesKeywords = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f29(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_remoteContextRegex = new System.Text.RegularExpressions.Regex.ctor("^(?<HasClusterReference>cluster\\((?<Cluster>[^\\)]+?)\\)\\.?)?((?<HasDatabaseReference>database)\\((?<Database>[^\\)]*)\\))?(\\.(?<Context>(\\[.+?\\]|[\\w\\*]+))?)?", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_queryParametersRegex = new System.Text.RegularExpressions.Regex.ctor("{\\w*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_joinClosureRegex = new System.Text.RegularExpressions.Regex.ctor("\\)\\s*on\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_joinWithMakeSeriesClosureRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*make-series\\s+.*?\\b(on)\\b.*?\\)\\s*on\\b");
                    this.s_makeSeriesStartRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*make-series");
                    this.s_findSubClausesRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*?|;)find\\s+[^\\|]*(where|project)\\s+[^\\|]*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_searchSubClausesRegex = new System.Text.RegularExpressions.Regex.ctor("(^|\\s*?|;\\s*)search\\s+[^\\|]*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_rangeEntitiesRegex = new System.Text.RegularExpressions.Regex.ctor("^(?<Field>[\\w_]+)\\s+", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_parsedEntitiesRegex = new System.Text.RegularExpressions.Regex.ctor(".*?with\\s+(?<Entities>.+)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_removeStringLiteralsRegex = new System.Text.RegularExpressions.Regex.ctor("('.*?'|\".*?\")", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_removeStringLiteralsSurroundedBySpacesRegex = new System.Text.RegularExpressions.Regex.ctor("\\s('.*?'|\".*?\")\\s", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_removeCommentsRegex = new System.Text.RegularExpressions.Regex.ctor("//.+[\\r\\n]+", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_fieldInvalidCharacters = new System.Text.RegularExpressions.Regex.ctor("[^\\w \\-\\.]", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_fieldQuotableCharacters = new System.Text.RegularExpressions.Regex.ctor("[ \\-\\.\\[\\]]", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_aggregateOperatorToColumnPrefixMapping = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f30(new (System.Collections.Generic.Dictionary$2(System.String,System.String))());
                    this.s_lastCommandSegmentRegex = new System.Text.RegularExpressions.Regex.ctor("union(\\s*\\(.*?\\)\\s*,)+\\s*\\((?<LastSegment>.*$)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_incompleteJoinRegex = new System.Text.RegularExpressions.Regex.ctor("join(?!.+\\bon\\b)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandClausesRegex = new System.Text.RegularExpressions.Regex.ctor("(^\\s*(?<Clause>.*?)join|\\s*\\((?<Clause>.+?)\\)\\s+on\\s+\\w+)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_operatorsReplacingEntities = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f31(new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                    this.s_withsourceExtractRegex = new System.Text.RegularExpressions.Regex.ctor("withsource\\s*=\\s*(?<tableNameColumn>\\w+)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_findProjectionRegex = new System.Text.RegularExpressions.Regex.ctor("project\\s+(?<projectedList>[^\\|]+)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_packRgx = new System.Text.RegularExpressions.Regex.ctor("(,)?\\s*pack\\s*\\(\\s*\\*\\s*\\)\\s*", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_topNestedLevelExtractRegex = new System.Text.RegularExpressions.Regex.ctor("(top-nested)?\\s*\\d+\\s+of\\s+(?<InputColumn>[\\w_]+)\\s+by\\s+((?<ReanmingColumn>[\\w_]+)\\s*=\\s*)?(?<Aggregator>.+?(,)?)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_sampleDistinctEntityExtractRegex = new System.Text.RegularExpressions.Regex.ctor("(sample-distinct)?\\s*\\d+\\s+of\\s+(?<InputColumn>[\\w_\\(\\), ]+)\\s", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_aggregateOperatorsHash = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationTokens).union(Kusto.Data.IntelliSense.CslCommandParser.SummarizeAggregationAliasesTokens));
                    this.s_byKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("\\bby\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_byAndOnKeywordRegex = new System.Text.RegularExpressions.Regex.ctor("\\b(by|on)\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_makeSeriesDropNonFieldsRegex = new System.Text.RegularExpressions.Regex.ctor("(\\b(default\\s*\\=\\s*\\S+)\\b)|(\\bin\\s+range\\s*\\(\\s*\\S+\\s*,\\s*\\S+\\s*,\\s*\\S+\\s*\\))", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_fieldMatchingRegex = new System.Text.RegularExpressions.Regex.ctor("(?<Field>[\\w_]+)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_numericSuffixRegex = new System.Text.RegularExpressions.Regex.ctor("(?<suffix>\\d+)$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_defaultContextPattern = "(?<Context>(((cluster.+?)?database\\([^\\)]*\\)?\\.?(\\[.+?\\]|[\\w|\\d|*]+)?|\\[.+?\\])|[\\w\\d\\*]+))";
                    this.s_commandContext_Join = new System.Text.RegularExpressions.Regex.ctor(".*join\\s.*?\\(\\s*" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Union = new System.Text.RegularExpressions.Regex.ctor("union\\s.*\\(\\s*" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_ToScalar = new System.Text.RegularExpressions.Regex.ctor("toscalar\\s*\\(\\s*" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Show = new System.Text.RegularExpressions.Regex.ctor("^(?<Context>\\.show\\s+\\w+(\\s+\\w+)*)\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Range = new System.Text.RegularExpressions.Regex.ctor("^(?<Context>range)\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Callable = new System.Text.RegularExpressions.Regex.ctor("\\{\\s+" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Let = new System.Text.RegularExpressions.Regex.ctor("^let\\s.*?=\\s*(\\(.*?\\)\\s*\\{\\s*)?" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_ConnectDirective = new System.Text.RegularExpressions.Regex.ctor("^\\s*#connect\\s+(?<Context>cluster\\(.+?\\)(.database\\(.+\\))?)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Find = new System.Text.RegularExpressions.Regex.ctor("(^|.*;)((find\\s+[^\\|]*in\\s*\\((?<Context>(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "))\\))|" + "(find\\s+[^\\|]*in\\s*\\((" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "\\s*,\\s*)?(" + "((?<Context>((cluster.+\\.)?database\\([^\\)]*\\)))\\.)|" + "(database\\((?<Context>))|" + "((?<Context>(cluster.+\\.database\\()))" + "))" + ")", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContext_Search = new System.Text.RegularExpressions.Regex.ctor("(^|.*;)((search\\s+[^\\|]*in\\s*\\((?<Context>(" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "))\\))|" + "(search\\s+[^\\|]*in\\s*\\((" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_tablesScopeRegex || "") + "\\s*,\\s*)?(" + "((?<Context>((cluster.+\\.)?database\\([^\\)]*\\)))\\.)|" + "(database\\((?<Context>))|" + "((?<Context>(cluster.+\\.database\\()))" + "))" + ")", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandDefaultContext = new System.Text.RegularExpressions.Regex.ctor("^\\s*" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_defaultContextPattern || ""), Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_twoOrMoreSpacesRegex = new System.Text.RegularExpressions.Regex.ctor("\\s\\s+", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showCommandFixRegex = new System.Text.RegularExpressions.Regex.ctor("(.show)(.*)(extents)", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_commandContextRegexes = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f32(new (System.Collections.Generic.Dictionary$2(System.String,System.Object))());
                    this.s_nonDefaultContextKeywordsRegex = new System.Text.RegularExpressions.Regex.ctor(Bridge.toArray(System.Linq.Enumerable.from(Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContextRegexes.getKeys()).orderByDescending($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f33).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f34)).join("|"), Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                    this.s_letVariableRegex = new System.Text.RegularExpressions.Regex.ctor("(^|;)\\s*let\\s+(?<LetExpressionName>\\w+)\\s*=", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_letStatementRegexList = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f35(new (System.Collections.Generic.List$1(System.Text.RegularExpressions.Regex)).ctor());
                }
            },
            methods: {
                MapColumnsToTables: function (tables) {
                    var $t, $t1;
                    var result = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity, tables)) {
                        return result;
                    }

                    var resultsUnordered = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.IEnumerable$1(System.String)))();
                    $t = Bridge.getEnumerator(tables, Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            resultsUnordered.add(new Kusto.Data.IntelliSense.KustoCommandContext(t.Name), System.Linq.Enumerable.from(t.Columns).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f36));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    // sort each list alphabetically
                    $t1 = Bridge.getEnumerator(resultsUnordered);
                    try {
                        while ($t1.moveNext()) {
                            var kvp = $t1.Current;
                            result.set(kvp.key, System.Linq.Enumerable.from(kvp.value).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f37).toList(System.String));
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }return result;
                },
                ParseCommandClauses: function (command) {
                    var $t;
                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_incompleteJoinRegex.isMatch(command)) {
                        return System.Array.init([command], System.String);
                    }

                    var matches = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandClausesRegex.matches(command);
                    if (matches.getCount() === 0) {
                        return System.Array.init([command], System.String);
                    }

                    var clauses = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t = Bridge.getEnumerator(matches);
                    try {
                        while ($t.moveNext()) {
                            var m = Bridge.cast($t.Current, System.Text.RegularExpressions.Match);
                            var clause = (m.getGroups().getByName("Clause").toString() || "") + " | ";
                            if (!System.String.isNullOrWhiteSpace(clause)) {
                                clauses.add(clause);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    clauses.add(command); // Also add the whole command
                    return clauses;
                },
                BuildOpEntitiesMap: function (command) {
                    var $t;
                    var operatorEntitiesMap = new (System.Collections.Generic.Dictionary$2(System.String,System.String))();
                    var pipeParts = System.Linq.Enumerable.from(Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ParseAsStatements(command, 124, false)).reverse();
                    $t = Bridge.getEnumerator(pipeParts);
                    try {
                        while ($t.moveNext()) {
                            var part = $t.Current;
                            if (System.String.isNullOrWhiteSpace(part)) {
                                continue;
                            }

                            // Checks if the part is a closure of a join operator
                            if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinClosureRegex.isMatch(part)) {
                                // Make-series operator part will also pass this regex check,
                                // Special handling for make-series pattern
                                if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesStartRegex.isMatch(part)) {
                                    // make-series pattern found - check if the part matches the join clousre with make-series pattern
                                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinWithMakeSeriesClosureRegex.isMatch(part)) {
                                        continue;
                                    }
                                } else {
                                    continue;
                                }
                            }

                            if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchSubClausesRegex.isMatch(part)) {
                                if (!operatorEntitiesMap.containsKey("search")) {
                                    operatorEntitiesMap.add("search", "");
                                }

                                continue;
                            }

                            if (!System.String.endsWith(part, "|") && !Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findSubClausesRegex.isMatch(part)) {
                                continue;
                            }

                            var opAnRest = System.String.split(part, System.Array.init([32, 13, 10], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), 2, 1);
                            if (opAnRest.length !== 2) {
                                continue;
                            }
                            var op = opAnRest[System.Array.index(0, opAnRest)];

                            // Leave 'find' trailing '|' in order to differ between complete and partial find clauses
                            var entities = Bridge.referenceEquals(op, "find") ? opAnRest[System.Array.index(1, opAnRest)] : Kusto.Cloud.Platform.Utils.ExtendedString.TrimEnd(opAnRest[System.Array.index(1, opAnRest)], "|");

                            if (!operatorEntitiesMap.containsKey(op)) {
                                operatorEntitiesMap.add(op, entities);
                            } else {
                                // we should not reach here in 'find'...'where' flow
                                operatorEntitiesMap.set(op, (operatorEntitiesMap.get(op) || "") + "," + (entities || "")); // Concatenate entities
                            }

                            if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorsReplacingEntities.contains(op)) {
                                // If operator does not require further entity analysis, terminate the loop
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return operatorEntitiesMap;
                },
                HandleParseEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var $t;
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("parse", list)) {
                        return result;
                    }

                    var wasAdded = false;

                    var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parsedEntitiesRegex.match(list.v);
                    if (match.getSuccess()) {
                        var parsedColumnsString = match.getGroups().getByName("Entities").toString();
                        var parsedColumns = System.String.split(parsedColumnsString, System.Array.init([42, 32], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                        $t = Bridge.getEnumerator(parsedColumns);
                        try {
                            while ($t.moveNext()) {
                                var columnCandidate = $t.Current;
                                var col = columnCandidate.trim();
                                if (System.String.isNullOrEmpty(col) || !System.Char.isLetter(col.charCodeAt(0))) {
                                    continue;
                                }
                                col = Kusto.Cloud.Platform.Utils.ExtendedString.SplitFirst(col, ":");
                                wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, col));
                            }
                        } finally {
                            if (Bridge.is($t, System.IDisposable)) {
                                $t.System$IDisposable$Dispose();
                            }
                        }}

                    return (wasAdded) ? Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities : result;
                },
                HandleReduceByEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var lastPipePart = { v : null };
                    if (!opEntitiesMap.tryGetValue("reduce", lastPipePart)) {
                        return result;
                    }

                    entitiesList.AddRange(System.Array.init(["Pattern", "Count"], System.String));
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                    return result;
                },
                HandleGetSchemaEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var lastPipePart = { v : null };
                    if (!opEntitiesMap.tryGetValue("getschema", lastPipePart)) {
                        return result;
                    }

                    entitiesList.AddRange(System.Array.init(["ColumnName", "ColumnOrdinal", "DataType", "ColumnType"], System.String));
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                    return result;
                },
                HandleRangeEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var entitites = { v : null };
                    if (!opEntitiesMap.tryGetValue("range", entitites)) {
                        return result;
                    }

                    var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeEntitiesRegex.match(entitites.v);
                    if (match.getSuccess()) {
                        var field = match.getGroups().getByName("Field").toString();
                        if (!entitiesList.contains(field)) {
                            entitiesList.add(field);
                            result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities;
                        }
                    }
                    return result;
                },
                HandlePrintEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var entitites = { v : null };
                    if (!opEntitiesMap.tryGetValue("print", entitites)) {
                        return result;
                    }

                    var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeEntitiesRegex.match(entitites.v);
                    if (match.getSuccess()) {
                        var field = match.getGroups().getByName("Field").toString();
                        if (!entitiesList.contains(field)) {
                            entitiesList.add(field);
                            result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities;
                        }
                    }
                    return result;
                },
                HandleProjectEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("project", list)) {
                        return result;
                    }

                    var wasAdded = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveEntitiesFromListWithImplicitColumns(entitiesList, list.v);
                    if (wasAdded) {
                        result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                    }
                    return result;
                },
                HandleProjectAwayEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var $t, $t1;
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("project-away", list)) {
                        return result;
                    }

                    var entities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(list.v);
                    var fields = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t = Bridge.getEnumerator(entities);
                    try {
                        while ($t.moveNext()) {
                            var entity = $t.Current;
                            var field = entity.Name;
                            if (entitiesList.contains(field)) {
                                entitiesList.remove(field);
                            } else {
                                fields.add(field);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }// Resolve remaining entities from "knownEntities" instead of from "entitiesList".
                    // This is needed in case project-away was the first operator in the command that requires entity resolving
                    // and the entitiesList does not contain any entities at this stage. 
                    if (System.Linq.Enumerable.from(fields).any() && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, entitiesList)) {
                        var safeKnownEntities = knownEntities != null ? knownEntities : new (System.Collections.Generic.List$1(System.String)).ctor();
                        $t1 = Bridge.getEnumerator(System.Linq.Enumerable.from(safeKnownEntities).except(fields).ToArray(System.String));
                        try {
                            while ($t1.moveNext()) {
                                var field1 = $t1.Current;
                                Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, field1);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }}
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                    return result;
                },
                HandleMvexpandEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("mvexpand", list)) {
                        return result;
                    }

                    var wasAdded = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveEntitiesFromList(entitiesList, list.v);
                    if (result === Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None && wasAdded) {
                        result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities;
                    }
                    return result;
                },
                HandleTopNestedEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var $t;
                    var list = { v : null };
                    var changed = false;
                    if (!opEntitiesMap.tryGetValue("top-nested", list)) {
                        return result;
                    }
                    var matches = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedLevelExtractRegex.matches(list.v);
                    if (matches.getCount() > 0) {
                        changed = true;
                    }
                    $t = Bridge.getEnumerator(matches);
                    try {
                        while ($t.moveNext()) {
                            var match = $t.Current;
                            var convertedMatch = Bridge.as(match, System.Text.RegularExpressions.Match);
                            var columnName = convertedMatch.getGroups().getByName("InputColumn").toString();
                            Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, columnName);

                            var extendedColumnName = convertedMatch.getGroups().getByName("ReanmingColumn").toString();
                            if (System.String.isNullOrEmpty(extendedColumnName)) {
                                extendedColumnName = "aggregated_" + (columnName || "");
                            }
                            Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, extendedColumnName);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }if (changed) {
                        result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                    }
                    return result;
                },
                HandleExtendEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("extend", list)) {
                        return result;
                    }

                    var wasAdded = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveEntitiesFromListWithImplicitColumns(entitiesList, list.v);
                    if (result === Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None && wasAdded) {
                        result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities;
                    }
                    return result;
                },
                HandleSampleDistinctEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("sample-distinct", list)) {
                        return result;
                    }

                    var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_sampleDistinctEntityExtractRegex.match(list.v);
                    if (!match.getSuccess()) {
                        return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None;
                    }

                    var inputColumn = match.getGroups().getByName("InputColumn").toString();

                    return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleAggregationEntities(entitiesList, inputColumn, knownEntities);
                },
                GenerateImplicitEntitiesForFunction: function (funcName, $arguments, explicitlySpecifiedResultColumnCount, resultEntities) {
                    var $t, $t1;
                    if (explicitlySpecifiedResultColumnCount !== 0 || Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.ExpressionEntity, $arguments) || !Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.MultiColumnFunctionResultSuffixes.containsKey(funcName)) {
                        return false;
                    }

                    var resultSuffixes = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.MultiColumnFunctionResultSuffixes.get(funcName);

                    // if function returns less parameters then specified then we skip the name generation
                    if (resultSuffixes.length < explicitlySpecifiedResultColumnCount) {
                        return false;
                    }

                    var argName = System.Linq.Enumerable.from($arguments).first().Name;
                    var added = false;

                    $t = Bridge.getEnumerator(System.Linq.Enumerable.from(resultSuffixes).skip(explicitlySpecifiedResultColumnCount));
                    try {
                        while ($t.moveNext()) {
                            var suffix = $t.Current;
                            var generatedName = Kusto.Cloud.Platform.Utils.ExtendedString.FormatWithInvariantCulture("{0}_{1}_{2}", [funcName, argName, suffix]);
                            resultEntities.add(($t1 = new Kusto.Data.IntelliSense.ExpressionEntity(), $t1.Name = generatedName, $t1.IsGenerated = true, $t1));
                            added = true;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return added;
                },
                ResolveEntitiesFromListWithImplicitColumns: function (entitiesList, input) {
                    var $t;
                    var wasAdded = false;
                    var entities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities$1(input, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.GenerateImplicitEntitiesForFunction);

                    $t = Bridge.getEnumerator(entities);
                    try {
                        while ($t.moveNext()) {
                            var entity = $t.Current;
                            wasAdded = !!(wasAdded | entity.IsGenerated ? Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldRenameIfPresent(entitiesList, entity.Name) : Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity.Name));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return wasAdded;
                },
                ResolveEntitiesFromList: function (entitiesList, input, generateImplicitColumnNames) {
                    var $t;
                    if (generateImplicitColumnNames === void 0) { generateImplicitColumnNames = false; }
                    var wasAdded = false;
                    var entities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(input);
                    $t = Bridge.getEnumerator(entities);
                    try {
                        while ($t.moveNext()) {
                            var entity = $t.Current;
                            wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity.Name));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return wasAdded;
                },
                HandleSummarizeEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("summarize", list)) {
                        return result;
                    }

                    // Fetch entities, replace 'by' with a comma to simplify parsing
                    var entities = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_byKeywordRegex.replace(list.v, ", ");

                    return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleAggregationEntities(entitiesList, entities, knownEntities);
                },
                HandleMakeSeriesEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                    var list = { v : null };
                    if (!opEntitiesMap.tryGetValue("make-series", list)) {
                        return result;
                    }

                    // Fetch entities, starting with 'by' & 'on' similar to summarize
                    var entities = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_byAndOnKeywordRegex.replace(list.v, ", ");

                    // We still have 'default' & 'in range' statements - remove them
                    entities = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesDropNonFieldsRegex.replace(entities, "");

                    return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleAggregationEntities(entitiesList, entities, knownEntities);
                },
                HandleAggregationEntities: function (entitiesList, entities, knownEntities) {
                    var $t, $t1;
                    var argMinMaxEntities = null;

                    var parsedEntities = Kusto.Data.IntelliSense.ExpressionEntityParser.ParseEntities(entities);
                    $t = Bridge.getEnumerator(parsedEntities);
                    try {
                        while ($t.moveNext()) {
                            var parsedEntity = $t.Current;
                            // Summarize can have several types of projected fields:
                            // summarize cnt(Filed1) by Field2
                            // 1) fields created by explicit operators (sum(Field1)) ==> sum_Field1
                            // 2) fields created by implicit operators (cnt() by Filed1) ==> count_
                            // 3) fields without operators (by Field2) ==> Field2
                            var op = parsedEntity.Operator;
                            var field = ($t1 = parsedEntity.Name, $t1 != null ? $t1 : "");
                            var arg0 = field;
                            var wasAdded = false;
                            if (!System.String.isNullOrEmpty(op) && Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_aggregateOperatorsHash.contains(op)) {
                                if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_aggregateOperatorToColumnPrefixMapping.containsKey(op)) {
                                    op = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_aggregateOperatorToColumnPrefixMapping.get(op);
                                }
                                var entity = (op || "") + "_" + (field || "");

                                // If this is a percentile or percentiles operator - parse the tokens and use them for column names
                                // For example: percentiles(xfloat, 1E-2, 2.03, 20)
                                // will produce the following columns:
                                // percentile_xfloat_1E_2
                                // percentile_xfloat_2_03 
                                // percentile_xfloat_20
                                if (System.String.equals(op, "percentile", 4)) {
                                    wasAdded = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandlePercentileAggregateEntities(entitiesList, parsedEntity, entity, knownEntities);
                                } else if (System.String.equals(op, "argmin", 4) || System.String.equals(op, "argmax", 4) || System.String.equals(op, "arg_min", 4) || System.String.equals(op, "arg_max", 4)) {
                                    if (argMinMaxEntities == null) {
                                        argMinMaxEntities = new (System.Collections.Generic.List$1(System.String)).ctor();
                                    }
                                    var correctedOp = op.substr(((op.length - 3) | 0), 3); // Take last 3 chars  (min or max)
                                    var preserveNames = System.String.equals(op, "arg_max", 4) || System.String.equals(op, "arg_min", 4);
                                    entity = (preserveNames) ? field : (correctedOp || "") + "_" + (field || "");
                                    wasAdded = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleArgMinMaxAggregateEntities(argMinMaxEntities, parsedEntity, correctedOp, arg0, entity, preserveNames, knownEntities);
                                } else {
                                    // If entity is derived from function - it may include invalid characters,
                                    // and will be replaced with operator's name
                                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldInvalidCharacters.isMatch(entity)) {
                                        entity = (op || "") + "_";
                                    }
                                }
                                field = entity;
                            }
                            if (!wasAdded) {
                                Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, field);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.FinalizeSummarizeEntitiesList(argMinMaxEntities, entitiesList);
                    return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                },
                AddEscapedEntityName: function (entitiesList, entity) {
                    entity = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.EscapeEntityNameIfNeeded(entity);

                    if (!entitiesList.contains(entity)) {
                        entitiesList.add(entity);
                        return true;
                    }

                    return false;
                },
                EscapeEntityNameIfNeeded: function (entity) {
                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldQuotableCharacters.isMatch(entity)) {
                        entity = "['" + (entity || "") + "']";
                    }

                    return entity;
                },
                /**
                 * After all summarize entities were finalized, go over the list and finalize it
                 *
                 * @static
                 * @private
                 * @this Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @memberof Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider
                 * @param   {System.Collections.Generic.List$1}    argMinMaxEntities    
                 * @param   {System.Collections.Generic.List$1}    entitiesList
                 * @return  {void}
                 */
                FinalizeSummarizeEntitiesList: function (argMinMaxEntities, entitiesList) {
                    if (argMinMaxEntities == null || argMinMaxEntities.Count === 0) {
                        return;
                    }

                    if (entitiesList.Count === 0) {
                        entitiesList.AddRange(argMinMaxEntities);
                        return;
                    }

                    // Rule#1: argmin/argmax operators remove columns that are appearing both as group columns and as arguments
                    // ... | summarize argmin(col1, col2, col3) by col2
                    // --->  min_col1, min_col1_col3, col2 (no min_col1_col2)
                    var regexExpression = System.String.format("^(min|max)_.+?_({0})$", [Bridge.toArray(entitiesList).join("|")]);
                    try {
                        var regex = new System.Text.RegularExpressions.Regex.ctor(regexExpression, Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions);
                        System.Linq.Enumerable.from(argMinMaxEntities).where(function (en) {
                                return !regex.isMatch(en);
                            }).forEach(function (field) {
                            return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, field);
                        });
                    }
                    catch ($e1) {
                        $e1 = System.Exception.create($e1);
                        if (Bridge.is($e1, System.ArgumentException)) {
                            // Regex is not valid
                            return;
                        } else {
                            throw $e1;
                        }
                    }
                },
                HandlePercentileAggregateEntities: function (entitiesList, parsedEntity, field, knownEntities) {
                    var $t;
                    var wasAdded = false;
                    var correctedField = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldMatchingRegex.match(field).getGroups().getByName("Field").toString(); // Take only the relvant part of the field
                    var $arguments = parsedEntity.Arguments;
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, $arguments)) {
                        return wasAdded;
                    }

                    $t = Bridge.getEnumerator($arguments, System.String);
                    try {
                        while ($t.moveNext()) {
                            var arg = $t.Current;
                            var fieldname = (correctedField || "") + "_" + (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldQuotableCharacters.replace(arg, "_") || "");
                            wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, fieldname));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }return wasAdded;
                },
                HandleArgMinMaxAggregateEntities: function (entitiesList, parsedEntity, op, arg0, field, preserveNames, knownEntities) {
                    var $t, $t1;
                    var wasAdded = false;
                    var fieldReplaced = false;
                    // argmin(Timestamp, Column1, Column2) -->
                    // min_, min__arg1, min__arg2 - note that there are 2 underscores in min__arg1 

                    // Add the first field: argmin_value
                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldInvalidCharacters.isMatch(field)) {
                        field = (op || "") + "_";
                        fieldReplaced = true;
                    }
                    wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, field));

                    var $arguments = parsedEntity.Arguments;
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, $arguments)) {
                        return wasAdded;
                    }

                    // Check all rest of the arguments
                    var argCount = 1;
                    $t = Bridge.getEnumerator(parsedEntity.Arguments, System.String);
                    try {
                        while ($t.moveNext()) {
                            var arg = $t.Current;
                            if (!Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_fieldInvalidCharacters.isMatch(arg)) {
                                var fieldname = (preserveNames) ? arg : (field || "") + "_" + (arg || "");
                                wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, fieldname));
                            } else if (Kusto.Cloud.Platform.Utils.ExtendedRegex.IsWildCardPattern(arg)) {
                                if (knownEntities != null && System.Linq.Enumerable.from(knownEntities).any()) {
                                    var wildCardMatch = { v : Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(arg) };
                                    if (wildCardMatch.v != null) {
                                        var matchingEntities = System.Linq.Enumerable.from(knownEntities).where((function ($me, wildCardMatch) {
                                                return function (en) {
                                                    return !Bridge.referenceEquals(en, arg0) && wildCardMatch.v.isMatch(en);
                                                };
                                            })(this, wildCardMatch)).toList(System.String);
                                        if (System.Linq.Enumerable.from(matchingEntities).any()) {
                                            $t1 = Bridge.getEnumerator(matchingEntities);
                                            try {
                                                while ($t1.moveNext()) {
                                                    var en = $t1.Current;
                                                    var fieldname1 = (preserveNames) ? en : (field || "") + "_" + (en || "");
                                                    wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, fieldname1));
                                                }
                                            } finally {
                                                if (Bridge.is($t1, System.IDisposable)) {
                                                    $t1.System$IDisposable$Dispose();
                                                }
                                            }}
                                    }
                                }
                            } else {
                                var fieldname2 = System.String.format("{0}_{1}_arg{2}", op, preserveNames && !fieldReplaced && !System.String.isNullOrWhiteSpace(field) ? field : "", Bridge.box(argCount, System.Int32));
                                wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, fieldname2));
                            }
                            argCount = (argCount + 1) | 0;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }return wasAdded;
                },
                AddFieldIfNotPresent: function (entitiesList, field) {
                    if (!System.String.isNullOrEmpty(field)) {
                        return Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, field);
                    }

                    return false;
                },
                AddFieldRenameIfPresent: function (entitiesList, field) {
                    if (System.String.isNullOrEmpty(field)) {
                        return false;
                    }

                    // First, escape entity name if needed
                    var escapedField = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.EscapeEntityNameIfNeeded(field);

                    if (entitiesList.contains(escapedField)) {
                        // first try a field name without numbers in the end
                        field = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_numericSuffixRegex.replace(field, "");
                        escapedField = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.EscapeEntityNameIfNeeded(field);
                    }

                    // still exists, try to add a suffix
                    if (entitiesList.contains(escapedField)) {
                        field = (field || "") + "1";
                        escapedField = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.EscapeEntityNameIfNeeded(field);
                    }

                    // still exists, iterate until unique suffix is found
                    while (entitiesList.contains(escapedField)) {
                        var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_numericSuffixRegex.match(field);
                        if (match.getSuccess()) {
                            var suffix = System.Int32.parse(match.getGroups().getByName("suffix").getValue());
                            suffix = (suffix + 1) | 0;
                            field = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_numericSuffixRegex.replace(field, Bridge.toString(suffix));
                            escapedField = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.EscapeEntityNameIfNeeded(field);
                        } else {
                            // should not happen, we added the numeric suffix ourselves
                            return false;
                        }
                    }

                    entitiesList.add(escapedField);
                    return true;
                },
                GetLatestMatch: function (matchesKeywords) {
                    var $t;
                    var lastMatch = null;
                    $t = Bridge.getEnumerator(matchesKeywords);
                    try {
                        while ($t.moveNext()) {
                            var m = Bridge.cast($t.Current, System.Text.RegularExpressions.Match);
                            if (!m.getSuccess()) {
                                continue;
                            }
                            if (lastMatch == null) {
                                lastMatch = m;
                            } else {
                                if (lastMatch.getIndex() < m.getIndex()) {
                                    lastMatch = m;
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return lastMatch;
                },
                ResolveContextUsingRegex: function (command, contextMatchRegex, startat) {
                    if (System.String.startsWith(System.String.trimStart(command.substr(startat)), "|")) {
                        return null;
                    }

                    var matchingRegex = contextMatchRegex.Item1;
                    var transformationRegex = contextMatchRegex.Item2;
                    var tableContext = null;
                    var contextMatch = matchingRegex.match(command, startat);
                    if (contextMatch.getSuccess()) {
                        tableContext = contextMatch.getGroups().getByName("Context").toString();
                        if (transformationRegex != null) {
                            tableContext = transformationRegex.replace(tableContext, $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f38);
                        }
                        tableContext = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_twoOrMoreSpacesRegex.replace(tableContext, " ");
                    }

                    return tableContext;
                },
                ResolveLetVariable: function (letStatement) {
                    if (System.String.isNullOrEmpty(letStatement)) {
                        return "";
                    }

                    var letMatch = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_letVariableRegex.match(letStatement);
                    if (letMatch.getSuccess()) {
                        return letMatch.getGroups().getByName("LetExpressionName").toString();
                    }
                    return "";
                },
                ResolveLetExpressions: function (statements) {
                    var $t, $t1;
                    var result = new (System.Collections.Generic.Dictionary$2(System.String,System.String))();
                    $t = Bridge.getEnumerator(Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_letStatementRegexList);
                    try {
                        while ($t.moveNext()) {
                            var regex = $t.Current;
                            var letMatches = regex.matches(statements);
                            $t1 = Bridge.getEnumerator(letMatches);
                            try {
                                while ($t1.moveNext()) {
                                    var m = Bridge.cast($t1.Current, System.Text.RegularExpressions.Match);
                                    var variable = m.getGroups().getByName("LetExpressionName").toString();
                                    var statement = m.getGroups().getByName("Expression").toString();
                                    if (!result.containsKey(variable)) {
                                        result.add(variable, statement);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return result;
                }
            }
        },
        fields: {
            s_afterjoinOperatorApplyPolicies: null,
            s_afterRenderApplyPolicies: null,
            s_afterEvaluatePluginPolicies: null,
            s_afterFindApplyPolicies: null,
            s_afterFindInApplyPolicies: null,
            s_afterFindInEndOrContinuePolicies: null,
            s_afterSearchApplyPolicies: null,
            m_queryParameters: null,
            m_remoteSchemaResolver: null,
            m_remoteColumnMappingsToTables: null,
            m_remoteDatabaseMappingToClusters: null,
            m_availableClusters: null,
            m_allowClientDirectives: false,
            m_contextCache: null
        },
        props: {
            TableNames: null,
            FunctionMappings: null,
            ColumnMappingsToTables: null,
            ColumnMappingsToWildcardedTables: null,
            OverridingColumnMapping: null,
            OverridingDatabaseMapping: null,
            OverridingTablesMapping: null,
            RemoteTableNames: {
                get: function () {
                    return (this.OverridingTablesMapping != null) ? System.Linq.Enumerable.from(this.OverridingTablesMapping).selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f46) : null;
                }
            },
            FunctionNames: {
                get: function () {
                    if (this.FunctionMappings != null) {
                        return System.Linq.Enumerable.from(this.FunctionMappings.getKeys()).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f47);
                    }
                    return System.Linq.Enumerable.empty();
                }
            },
            AllowQueryParameters: false,
            Cluster: null,
            DatabaseSchema: null,
            Database: {
                get: function () {
                    return (this.DatabaseSchema != null) ? this.DatabaseSchema.Database : null;
                }
            },
            Databases: {
                get: function () {
                    return (this.Cluster != null) ? this.Cluster.Databases : null;
                }
            },
            Tables: {
                get: function () {
                    return this.DatabaseSchema != null && this.DatabaseSchema.Database != null ? this.DatabaseSchema.Database.Tables : null;
                }
            },
            Functions: {
                get: function () {
                    return this.DatabaseSchema != null && this.DatabaseSchema.Database != null ? this.DatabaseSchema.Database.Functions : null;
                }
            },
            ContextCache: {
                get: function () {
                    return this.m_contextCache;
                },
                set: function (value) {
                    this.m_contextCache = value;
                }
            }
        },
        ctors: {
            init: function () {
                this.s_afterjoinOperatorApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f39(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterRenderApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f40(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterEvaluatePluginPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f41(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterFindApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f42(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterFindInApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f43(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterFindInEndOrContinuePolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f44(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterSearchApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f45(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))(Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_afterFunctionsApplyPolicies));
                this.m_remoteColumnMappingsToTables = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String))))();
                this.m_remoteDatabaseMappingToClusters = new (System.Collections.Generic.Dictionary$2(System.String,System.Collections.Generic.List$1(System.String)))();
                this.m_contextCache = new (System.Collections.Generic.Dictionary$2(System.Int32,Kusto.Data.IntelliSense.KustoCommandContext))();
            },
            $ctor1: function (cluster, databaseSchema, queryParameters, availableClusters, schemaResolver, allowQueryParameters, allowClientDirectives) {
                this.$initialize();
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ctor.call(this);
                this.Cluster = cluster;
                this.DatabaseSchema = databaseSchema;
                this.m_queryParameters = queryParameters;
                this.m_remoteSchemaResolver = schemaResolver;
                this.m_availableClusters = availableClusters;
                this.m_allowClientDirectives = allowClientDirectives;
                this.AllowQueryParameters = allowQueryParameters;

                this.Initialize();
                this.LoadRules();
            },
            ctor: function (other) {
                this.$initialize();
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ctor.call(this);
                this.Cluster = other.Cluster.Clone();
                this.DatabaseSchema = other.DatabaseSchema.Clone();
                this.m_queryParameters = (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, other.m_queryParameters)) ? System.Linq.Enumerable.from(other.m_queryParameters).ToArray() : null;
                this.m_remoteSchemaResolver = other.m_remoteSchemaResolver;
                this.m_availableClusters = other.m_availableClusters;
                this.m_allowClientDirectives = other.m_allowClientDirectives;
                this.AllowQueryParameters = other.AllowQueryParameters;

                this.Initialize();
                this.LoadRules();
            }
        },
        methods: {
            ResetState: function () {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), this.OverridingColumnMapping)) {
                    this.OverridingColumnMapping.clear();
                }
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), this.OverridingDatabaseMapping)) {
                    this.OverridingDatabaseMapping.clear();
                }
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), this.OverridingTablesMapping)) {
                    this.OverridingTablesMapping.clear();
                }
                //if (m_remoteColumnMappingsToTables.SafeFastAny())
                //{
                //    m_remoteColumnMappingsToTables.Clear();
                //}
                //if (m_remoteDatabaseMappingToClusters.SafeFastAny())
                //{
                //    m_remoteDatabaseMappingToClusters.Clear();
                //}
            },
            Clone: function () {
                return new Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ctor(this);
            },
            UpdateProviderAvailableEntities: function (command, commandContext) {
                var knownEntities = this.ResolveKnownEntitiesFromContext(commandContext);

                var commandEntities = new (System.Collections.Generic.List$1(System.String)).ctor();
                var entitiesResolveResult = this.ResolveEntitiesFromCommand(command, commandEntities, knownEntities);
                switch (entitiesResolveResult) {
                    case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities: 
                        this.RegisterCommandEntities(commandContext, commandEntities, true);
                        break;
                    case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None: 
                    case Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities: 
                        this.RegisterCommandEntities(commandContext, commandEntities, false);
                        break;
                }
            },
            ResolveKnownEntitiesFromContext: function (commandContext) {
                var $t, $t1;
                var outputColumns = { v : null };
                var remoteColumnMappingsToTables = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                var dbNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                var localWildcardedTablesColumns = { v : null };
                var performUnion = commandContext.Operation === Kusto.Data.IntelliSense.ContextOperation.Union;

                var contextParts = commandContext.Flatten();
                $t = Bridge.getEnumerator(contextParts, Kusto.Data.IntelliSense.KustoCommandContext);
                try {
                    while ($t.moveNext()) {
                        var kustoCommandContextPart = $t.Current;
                        var clusterUriOrAlias = { };
                        var databaseNameOrAlias = { };
                        var remoteContext = { };

                        var matchingEntities = { v : null };
                        if (this.ResolveRemoteContext(kustoCommandContextPart.Context, clusterUriOrAlias, databaseNameOrAlias, remoteContext)) {
                            // Update columns list
                            var columnMappingsToTables = this.UpdateColumnsList(kustoCommandContextPart, clusterUriOrAlias.v, databaseNameOrAlias.v, remoteContext.v);

                            if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), columnMappingsToTables)) {
                                // Add the current table-columns mapping to the overall remote table to columns collection
                                $t1 = Bridge.getEnumerator(columnMappingsToTables);
                                try {
                                    while ($t1.moveNext()) {
                                        var mapping = $t1.Current;
                                        var columns = { };
                                        if (!remoteColumnMappingsToTables.tryGetValue(mapping.key, columns)) {
                                            columns.v = new (System.Collections.Generic.List$1(System.String)).ctor();
                                        }

                                        remoteColumnMappingsToTables.set(mapping.key, System.Linq.Enumerable.from(columns.v).union(mapping.value).toList(System.String));
                                    }
                                } finally {
                                    if (Bridge.is($t1, System.IDisposable)) {
                                        $t1.System$IDisposable$Dispose();
                                    }
                                }
                                matchingEntities.v = System.Linq.Enumerable.from(columnMappingsToTables.getValues()).selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f48).toList(System.String);
                            }

                            // Update cluster database list
                            this.UpdateDatabaseList(kustoCommandContextPart, clusterUriOrAlias.v, databaseNameOrAlias.v);

                            // Collect the current context databases names
                            var partDbs = { };
                            if (this.OverridingDatabaseMapping.tryGetValue(kustoCommandContextPart, partDbs)) {
                                dbNames = System.Linq.Enumerable.from(dbNames).union(partDbs.v).toList(System.String);
                            }
                        } else if (Kusto.Cloud.Platform.Utils.ExtendedRegex.IsWildCardPattern(kustoCommandContextPart.Context)) {
                            // Handle local context

                            // Check if we already computed the column mapping for this table name pattern
                            this.ColumnMappingsToWildcardedTables.tryGetValue(kustoCommandContextPart, matchingEntities);

                            if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, matchingEntities.v)) {
                                // Compute the column mapping for this table name pattern
                                var wildCardMatch = { v : Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(kustoCommandContextPart.Context) };
                                if (wildCardMatch.v != null) {
                                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity, this.Tables)) {
                                        var matchedTables = System.Linq.Enumerable.from(this.Tables).where((function ($me, wildCardMatch) {
                                                return function (t) {
                                                    return !t.IsInvisible && wildCardMatch.v.isMatch(t.Name);
                                                };
                                            })(this, wildCardMatch));
                                        var matchedTableNames = { v : new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(matchedTables.select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f49)) };

                                        // For each matching table name, get all columns
                                        var entitiesTables = System.Linq.Enumerable.from(this.ColumnMappingsToTables).where((function ($me, matchedTableNames) {
                                                return function (t) {
                                                    return matchedTableNames.v.contains(t.key.Context);
                                                };
                                            })(this, matchedTableNames));

                                        if (performUnion) {
                                            matchingEntities.v = entitiesTables.selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f50).distinct().toList(System.String);
                                        } else {
                                            // Compute the intersection of columns
                                            var intersection = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.Intersect(System.String, entitiesTables.select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f50));
                                            matchingEntities.v = intersection != null ? System.Linq.Enumerable.from(intersection).toList(System.String) : new (System.Collections.Generic.List$1(System.String)).ctor();
                                        }
                                    } else {
                                        matchingEntities.v = new (System.Collections.Generic.List$1(System.String)).ctor();
                                    }

                                    this.ColumnMappingsToWildcardedTables.set(kustoCommandContextPart, System.Linq.Enumerable.from(matchingEntities.v).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f37).toList(System.String));

                                    this.PerformGroupActionOrInit(localWildcardedTablesColumns, this.ColumnMappingsToWildcardedTables.get(kustoCommandContextPart), performUnion);
                                }
                            }
                        } else {
                            var contextWithNoOperation = new Kusto.Data.IntelliSense.KustoCommandContext(kustoCommandContextPart.Context);
                            this.ColumnMappingsToTables.tryGetValue(contextWithNoOperation, matchingEntities);
                        }

                        this.PerformGroupActionOrInit(outputColumns, matchingEntities.v, performUnion);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (!this.m_remoteColumnMappingsToTables.containsKey(commandContext) && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(Bridge.global.Kusto.Data.IntelliSense.KustoCommandContext, Bridge.global.System.Collections.Generic.List$1(System.String), remoteColumnMappingsToTables)) {
                    this.m_remoteColumnMappingsToTables.set(commandContext, remoteColumnMappingsToTables);
                }

                if (!this.OverridingDatabaseMapping.containsKey(commandContext) && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$6(System.String, dbNames)) {
                    this.OverridingDatabaseMapping.set(commandContext, dbNames);
                }

                if (!this.ColumnMappingsToWildcardedTables.containsKey(commandContext)) {
                    this.ColumnMappingsToWildcardedTables.set(commandContext, (localWildcardedTablesColumns.v != null ? System.Linq.Enumerable.from(localWildcardedTablesColumns.v).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f37).toList(System.String) : null) || new (System.Collections.Generic.List$1(System.String)).ctor());
                }

                return outputColumns.v != null ? System.Linq.Enumerable.from(outputColumns.v).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f37).toList(System.String) : null;
            },
            PerformGroupActionOrInit: function (target, source, performUnion) {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, source)) {
                    source = new (System.Collections.Generic.List$1(System.String)).ctor();
                }

                if (target.v == null) {
                    target.v = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(source);
                    return;
                }

                if (performUnion) {
                    target.v.unionWith(source);
                } else {
                    target.v.intersectWith(source);
                }
            },
            UpdateColumnsList: function (commandContext, clusterUriOrAlias, databaseNameOrAlias, tableName) {
                if (!this.m_remoteColumnMappingsToTables.containsKey(commandContext) && !System.String.isNullOrEmpty(databaseNameOrAlias)) {
                    if (this.m_remoteSchemaResolver != null) {
                        var dbSchemas = this.m_remoteSchemaResolver.Kusto$Data$IntelliSense$IKustoIntelliSenseSchemaResolver$ResolveDatabaseSchema$1(clusterUriOrAlias, databaseNameOrAlias, tableName);

                        if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity, dbSchemas)) {
                            var allTables = System.Linq.Enumerable.from(dbSchemas).selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f51).toList(Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity);

                            this.UpdateRemoteColumnMappingToTables(commandContext, tableName, allTables);

                            this.OverridingTablesMapping.set(commandContext, System.Linq.Enumerable.from(allTables).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f49).toList(System.String));
                        } else {
                            this.OverridingTablesMapping.set(commandContext, new (System.Collections.Generic.List$1(System.String)).ctor());
                            this.m_remoteColumnMappingsToTables.set(commandContext, new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))());
                        }
                    }
                }

                var columnMappingsToTables = { };
                this.m_remoteColumnMappingsToTables.tryGetValue(commandContext, columnMappingsToTables);

                return columnMappingsToTables.v || new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
            },
            UpdateRemoteColumnMappingToTables: function (commandContext, tableName, allTables) {
                var columnsToTablesMapping;
                if (allTables.Count === 1) {
                    // In this case there is no need to calculate the columns intersection
                    columnsToTablesMapping = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.MapColumnsToTables(allTables);
                } else {
                    var performUnion = commandContext.Operation === Kusto.Data.IntelliSense.ContextOperation.Union;

                    var outputColumns = null;
                    if (performUnion) {
                        outputColumns = System.Linq.Enumerable.from(allTables).selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f52).distinct().toList(System.String);
                    } else {
                        outputColumns = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.Intersect(System.String, System.Linq.Enumerable.from(allTables).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f52));
                    }

                    var orderedColumns = outputColumns != null ? System.Linq.Enumerable.from(outputColumns).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f37).toList(System.String) : new (System.Collections.Generic.List$1(System.String)).ctor();

                    columnsToTablesMapping = function (_o1) {
                            _o1.add(new Kusto.Data.IntelliSense.KustoCommandContext(tableName, commandContext.Operation), orderedColumns);
                            return _o1;
                        }(new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))());
                }


                this.m_remoteColumnMappingsToTables.set(commandContext, columnsToTablesMapping);
            },
            UpdateDatabaseList: function (commandContext, clusterUriOrAlias, databaseNameOrAlias) {
                var targetCluster = clusterUriOrAlias;
                if (System.String.isNullOrEmpty(targetCluster)) {
                    targetCluster = (this.Cluster != null) ? this.Cluster.Alias : null;
                }

                if (!System.String.isNullOrEmpty(targetCluster) && !this.OverridingDatabaseMapping.containsKey(commandContext)) {
                    if (this.m_remoteSchemaResolver != null) {
                        var dbNames = this.m_remoteSchemaResolver.Kusto$Data$IntelliSense$IKustoIntelliSenseSchemaResolver$ResolveDatabaseNames(targetCluster);
                        if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, dbNames) && !System.String.isNullOrEmpty(databaseNameOrAlias)) {
                            if (Kusto.Cloud.Platform.Utils.ExtendedRegex.IsWildCardPattern(databaseNameOrAlias)) {
                                // filter databases according to pattern
                                var wildCardMatch = Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(databaseNameOrAlias);
                                if (wildCardMatch != null) {
                                    dbNames = System.Linq.Enumerable.from(dbNames).where(function (db) {
                                            return wildCardMatch.isMatch(db);
                                        });
                                }
                            }
                        }

                        if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, dbNames)) {
                            this.OverridingDatabaseMapping.set(commandContext, System.Linq.Enumerable.from(dbNames).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f53).toList(System.String));
                        } else {
                            this.OverridingDatabaseMapping.set(commandContext, new (System.Collections.Generic.List$1(System.String)).ctor());
                        }
                    }
                }
            },
            ResolveRemoteContext: function (commandContext, clusterUriOrAlias, databaseNameOrAlias, remoteTableContext) {
                clusterUriOrAlias.v = "";
                databaseNameOrAlias.v = "";
                remoteTableContext.v = "";
                if (System.String.isNullOrEmpty(commandContext)) {
                    return false;
                }

                var match = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_remoteContextRegex.match(commandContext);
                if (!match.getSuccess()) {
                    return false;
                }

                var hasClusterReference = !System.String.isNullOrEmpty(match.getGroups().getByName("HasClusterReference").toString());
                if (hasClusterReference) {
                    Kusto.Cloud.Platform.Text.StringLiteral.TryParseStringLiteral(match.getGroups().getByName("Cluster").toString(), clusterUriOrAlias);
                } else {
                    clusterUriOrAlias.v = (this.Cluster != null) ? this.Cluster.Alias : "";
                    if (clusterUriOrAlias.v == null) {
                        clusterUriOrAlias.v = "";
                    }
                }
                Kusto.Cloud.Platform.Text.StringLiteral.TryParseStringLiteral(match.getGroups().getByName("Database").toString(), databaseNameOrAlias);
                var hasDatabaseReference = !System.String.isNullOrEmpty(match.getGroups().getByName("HasDatabaseReference").toString());
                remoteTableContext.v = match.getGroups().getByName("Context").toString();

                if ((!hasDatabaseReference && System.String.isNullOrEmpty(databaseNameOrAlias.v)) && (!hasClusterReference || System.String.isNullOrEmpty(clusterUriOrAlias.v))) {
                    return false;
                }

                return true;
            },
            Initialize: function () {
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.prototype.Initialize.call(this);

                this.ContextConnection = "";
                if (this.Cluster != null && !System.String.isNullOrWhiteSpace(this.Cluster.Alias)) {
                    this.ContextConnection = "cluster('" + (this.Cluster.Alias || "") + "')";
                }
                if (this.Database != null && !System.String.isNullOrWhiteSpace(this.Database.Name)) {
                    this.ContextConnection = (this.ContextConnection || "") + ".database('" + (this.DatabaseSchema.Database.Name || "") + "')";
                }

                this.OverridingColumnMapping = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.ColumnMappingsToTables = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.ColumnMappingsToWildcardedTables = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.TableNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                this.FunctionMappings = new (System.Collections.Generic.Dictionary$2(System.String,System.Object))();

                this.CommandRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.GeneralRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.QueryParametersRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
            },
            LoadRules: function () {
                var $t;
                this.ColumnMappingsToTables = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.MapColumnsToTables(this.Tables);
                this.OverridingColumnMapping = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.ColumnMappingsToWildcardedTables = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.OverridingDatabaseMapping = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                this.OverridingTablesMapping = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();

                this.AddClientDirectiveRules();

                this.AddFindOperator();

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldOperatorsAfterPipe, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_afterPipeRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Operator, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldSummarizeOperatorOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.m_commandsRequestingAggregators, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionAggregation, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_aggregateOperationOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorsRequestingAggregators, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceAfterBracketPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldDatabaseFunctionOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_clusterFunctionRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_databaseFunctionOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceStepBackPolicy, $t));

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, this.m_availableClusters)) {
                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldClusterNamesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_startOfCommandWithClusterRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Service, System.Linq.Enumerable.from(this.m_availableClusters).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f54).ToArray(System.String)), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));
                }

                var localDatabases = new (System.Collections.Generic.Dictionary$2(Kusto.Data.IntelliSense.KustoCommandContext,System.Collections.Generic.List$1(System.String)))();
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity, this.Databases)) {
                    localDatabases.add(Kusto.Data.IntelliSense.KustoCommandContext.Empty, System.Linq.Enumerable.from(this.Databases).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f55).toList(System.String));
                }
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldDatabaseNamesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_startOfCommandWithDatabaseRegex, $t.ContextualOptions = localDatabases, $t.OverrideOptions = this.OverridingDatabaseMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Database, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForRemoteQueryOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_databaseFunctionInFindRegex, $t.ContextualOptions = null, $t.OverrideOptions = this.OverridingTablesMapping, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Table, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendCommaPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForRemoteQueryOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_databaseFunctionRegex, $t.ContextualOptions = null, $t.OverrideOptions = this.OverridingTablesMapping, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Table, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendPipePolicy, $t));

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity, this.Tables)) {
                    this.TableNames = System.Linq.Enumerable.from(this.Tables).where($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f56).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f49).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f57).toList(System.String);

                    var rule = ($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTableNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_startOfLineWithSpaceOrAfterJoinRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendPipePolicy, $t);

                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTableNamesForFindIn, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findInStartOrContinueListRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));

                    // Add functions if there are any
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity, this.Functions)) {
                        rule.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionServerSide, System.Linq.Enumerable.from(this.Functions).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f58).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f33).ToArray(System.String))], Kusto.Data.IntelliSense.CompletionOptionCollection);

                        // After apply policy for functions is just space (and not pipe)
                        rule.AfterApplyPolicies = System.Linq.Enumerable.from(this.Functions).toDictionary($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f58, $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f59, System.String, Bridge.global.Kusto.Data.IntelliSense.ApplyPolicy);
                    }

                    this.GeneralRules.add(rule);
                    this.DefaultRule = rule;
                }

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseTableEntity, this.Tables)) {
                    this.AddColumnRules();
                }

                // Suggest timespan options for ago()
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_agoContextRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_timespanOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.MoveAfterTheBracketPolicy, $t));

                // Suggest timespan options for now()
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTimespanOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_nowContextRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_negativeTimespanOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.MoveAfterTheBracketPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForJoin, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinFlavorsForJoin_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionKind, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinFlavorsOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendJoinClauseWithOpenningBracketPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostJoinOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_postJoinOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterjoinOperatorApplyPolicies, $t));

                //Dictionary<string, ApplyPolicy> afterRenderApplyPolicies = null;
                //if (DateTime.Now.Day == 1 && DateTime.Now.Month == 4)
                //{
                //    afterRenderApplyPolicies = s_afterRenderApplyPolicies;
                //}

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRenderOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionRender, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRenderKindKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderMultiChartsRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionRender, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_kindKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRenderKindOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKindOptionsRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionRender, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKindOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldNumericScalarOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topOrLimitOrTakeOrSampleRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_numericScalarsOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topLimitTakeSampleKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //showing kind options : regex or simple
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldParseKeywordKindsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKindChoose_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionKind, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_kindChooseKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //shows with option 
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldWithKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseWith_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_withKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //shows star option 
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldStarOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseStarOption_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseStarOption), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //shows types for parse  
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldParseTypesKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseTypesSuggest_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.DataType, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseSuggestedTypesKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForTopNestedAndTopHitters, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_ofKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForTopNestedAndTopHitters, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_ofKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOfKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForSampleDistinct, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_ofKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_sampleDistinctKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopNestedKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywordPrefixRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Operator, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopHittersKeywordOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersKeywordPrefixRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Operator, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersKeywords), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldTopNestedOthersOption, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedWithOthersOption, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionKind, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_withOthersKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldByKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_yieldByKeywordRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_byKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorsUsingByKeywordKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedAscendingDescendingRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_ascDescKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldAscendingDescendingOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topOrOrderAscendingDescendingRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_ascDescOrNullsLastNullsFirstKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topSortOrderKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldNullsFirstNullsLastOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topTopNestedSortOrderByAscDescRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_nullsLastFirstKeywordOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topTopNestedSortOrderKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                if (this.Cluster != null && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSensePluginEntity, this.Cluster.Plugins)) {
                    var pluginOptions = System.Linq.Enumerable.from(this.Cluster.Plugins).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f60).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f61).ToArray(System.String);
                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldEvaluateOperatorOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_evaluateRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, pluginOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_evaluateKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceAfterBracketPolicy, $t.AfterApplyPolicies = this.s_afterEvaluatePluginPolicies, $t));
                }

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesRequestingAggregatorsRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionAggregation, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesAggregateOperationOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceAfterBracketPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForDefaultOrOn, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesBeforeDefaultOrOnRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesDefaultOrOnOptions), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForOn, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesBeforeOnRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesOnOptions), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForRange, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesBeforeRangeRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesInRangeOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceStepBackPolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldMakeSeriesOperatorForBy, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesBeforeByRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_byKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldSearchKindOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKind_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.OptionKind, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKindOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.AddRangeOperator();

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseFunctionEntity, this.Functions)) {
                    this.FunctionMappings = System.Linq.Enumerable.from(this.Functions).toDictionary($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f62, $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f63, System.String, Bridge.global.System.Object);
                }

                this.AddQueryParameterRule(this.m_queryParameters);
            },
            AddClientDirectiveRules: function () {
                var $t;
                if (!this.m_allowClientDirectives) {
                    return;
                }

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldClientDirectivesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_clientDirective_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.ClientDirective, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_clientDirectivesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, this.m_availableClusters)) {
                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldClientDirective_ConnectOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_clientDirectiveConnect_Regex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Service, System.Linq.Enumerable.from(this.m_availableClusters).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f64)), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));
                }
            },
            AddColumnRules: function () {
                var $t;
                var columns = System.Linq.Enumerable.from(this.Tables).selectMany($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f65).ToArray(System.Object);


                if (System.Linq.Enumerable.from(columns).count() === 0) {
                    return;
                }

                // Add columns
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForFilterColumnInFindRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Column, System.Array.init(["*"], System.String))], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                // Suggest options directly after 'search'
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostSearchOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchLiteralsOptions, 1), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchInKeywordOptions, 1), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_kindKeywordOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t.AfterApplyPolicies = this.s_afterSearchApplyPolicies, $t));

                // Suggest options for 'search kind=case_sensitive '
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostSearchKindOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchAfterKindContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchLiteralsOptions, 1), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchInKeywordOptions, 1), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t.AfterApplyPolicies = this.s_afterSearchApplyPolicies, $t));

                // Suggest options for 'search ... and', 'search .. in() '
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldInsideSearchOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchMoreContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Literal, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_searchLiteralsOptions, 1), new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t.AfterApplyPolicies = this.s_afterSearchApplyPolicies, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilter, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForFilterColumnRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filterKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Column, System.Array.init(["*"], System.String))], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForFindProject, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Column, System.Array.init(["pack(*)"], System.String))], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForProject, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_projectKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectAway, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForProjectAway, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_projectAwayKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectRename, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForProjectRename, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_projectRenameKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                // Handle functions with single parameter
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_singleParamFunctionsColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.MoveAfterTheBracketPolicy, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AfterApplyPolicies = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_afterFunctionsApplyPolicies, $t));

                // Handle functions with 2 parameters
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForTwoParamFunctions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_twoParamFunctionsColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendCommaPolicy, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForThreeParamFunctions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_threeParamFunctionsColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendDoubleCommaPolicy, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForManyParamFunctions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_manyParamFunctionsColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendCommaPolicy, $t));


                // Add columns for extend or project-with-assignment
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_operatorContextForExtend_ColumnAndFunctionRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_projectExtendKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceAfterBracketPolicy, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForJoin, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_entitiesForJoin_ColumnsRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_joinKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topSortOrderReduceByRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topSortOrderReduceKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedSuggestingColumnsRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topNestedKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForOrdering, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersSuggestingColumnsRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_topHittersKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesAndFunctionsForExtend, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_sampleDistinctSuggestingColumnsRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.AdditionalOptions = System.Array.init([new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_extendOperationOptions)], Kusto.Data.IntelliSense.CompletionOptionCollection), $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_sampleDistinctKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldKindFlavorsForReduceBy, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_reduceByColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_reduceKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //showing columns suggestions to be parsed
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForParse, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_parseKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //showing columns suggestions for render timepivot
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForRender, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderTimePivotColumnContextRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_renderKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                //showing columns suggestions for diffpatterns split column
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForDiffPatternsPluginSplitParameter, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_diffPatternsPluginSplitParameterRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_evaluateKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));

                // showing columns for make-series
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForMakeSeries, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesByRegex, $t.ContextualOptions = this.ColumnMappingsToTables, $t.OverrideOptions = this.OverridingColumnMapping, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_makeSeriesKeywords, $t.OptionsKind = Kusto.Data.IntelliSense.OptionKind.Column, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy, $t));

                // Take care of string columns
                var columnNamesWithStringTypes = System.Linq.Enumerable.from(columns).where($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f66).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f67);

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, columnNamesWithStringTypes)) {
                    // Add star column reference
                    columnNamesWithStringTypes = columnNamesWithStringTypes.union(System.Linq.Enumerable.from(this.Tables).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f68));

                    var matchingTokens = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(columnNamesWithStringTypes);
                    var afterApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f69(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());

                    /* GeneralRules.Add(new ContextualTokensWithRegexIntelliSenseRule()
                    {
                       Kind = (int)RuleKind.YieldStringComparisonInFindOptions,
                       GroupNameToUseAfterMatch = "MatchingString",
                       MatchingTokens = matchingTokens,
                       MatchingRegex = s_filteredColumnForFindRegex,
                       Options = new CompletionOptionCollection(OptionKind.FunctionFilter, s_stringOperatorOptions),
                       DefaultAfterApplyPolicy = ApplyPolicy.StringComparisonPolicy,
                       RequiredKeywords = s_findFilterKeywords,
                       AfterApplyPolicies = afterApplyPolicies,
                    });*/

                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldStringComparisonOptions, $t.GroupNameToUseAfterMatch = "MatchingString", $t.MatchingTokens = matchingTokens, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filteredColumnRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionFilter, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_stringOperatorOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.StringComparisonPolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filterKeywords, $t.AfterApplyPolicies = afterApplyPolicies, $t));
                }

                // Take care for rest columns 
                var columnNamesWithNonStringTypes = System.Linq.Enumerable.from(columns).where($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f70).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f67);
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, columnNamesWithNonStringTypes)) {
                    /* GeneralRules.Add(new ContextualTokensWithRegexIntelliSenseRule()
                    {
                       Kind = (int)RuleKind.YieldNumericComparisonInFindOptions,
                       GroupNameToUseAfterMatch = "MatchingString",
                       MatchingTokens = new HashSet<string>(columnNamesWithNonStringTypes),
                       MatchingRegex = s_filteredColumnForFindRegex,
                       Options = new CompletionOptionCollection(OptionKind.FunctionFilter, s_numericOperatorOptions),
                       DefaultAfterApplyPolicy = ApplyPolicy.AppendSpacePolicy,
                       RequiredKeywords = s_findFilterKeywords,
                    });*/

                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldNumericComparisonOptions, $t.GroupNameToUseAfterMatch = "MatchingString", $t.MatchingTokens = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(columnNamesWithNonStringTypes), $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filteredColumnRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionFilter, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_numericOperatorOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filterKeywords, $t));
                }

                // Suggest operators for DateTime columns
                var columnNamesWithTypeDateTime = System.Linq.Enumerable.from(columns).where($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f71).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f67);
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, columnNamesWithTypeDateTime)) {

                    /* GeneralRules.Add(new ContextualTokensWithRegexIntelliSenseRule()
                    {
                       Kind = (int)RuleKind.YieldDateTimeOperatorsInFindOptions,
                       GroupNameToUseAfterMatch = "MatchingString",
                       MatchingTokens = new HashSet<string>(columnNamesWithTypeDateTime),
                       MatchingRegex = s_filterPredicateRightValueForFindRegex,
                       Options = new CompletionOptionCollection(OptionKind.FunctionScalar, s_datetimeOptions),
                       DefaultAfterApplyPolicy = ApplyPolicy.AppendSpaceAfterBracketPolicy,
                       RequiredKeywords = s_findFilterKeywords,
                    });*/

                    this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldDateTimeOperatorsOptions, $t.GroupNameToUseAfterMatch = "MatchingString", $t.MatchingTokens = new (System.Collections.Generic.HashSet$1(System.String)).$ctor1(columnNamesWithTypeDateTime), $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filterPredicateRightValueRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.FunctionScalar, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_datetimeOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceAfterBracketPolicy, $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_filterKeywords, $t));
                }
            },
            SetQueryParametersRule: function (queryParameters) {
                this.Locker;
                {
                    this.QueryParametersRules.clear();
                    this.AddQueryParameterRule(queryParameters);
                }
            },
            AddQueryParameterRule: function (queryParameters) {
                var $t, $t1;
                if (queryParameters != null && System.Linq.Enumerable.from(queryParameters).any()) {
                    this.QueryParametersRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldQueryParameters, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_queryParametersRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Parameter, queryParameters), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = "}", $t1), $t));
                }
            },
            AddRangeOperator: function () {
                var $t;
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRangeFromOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromToRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromToOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldRangeFromToStepOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromToStepRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_rangeFromToStepOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddFindOperator: function () {
                var $t;
                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostFindOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findContextRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findWhereInOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterFindApplyPolicies, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostFindInOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findInRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_postFindInOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterFindInApplyPolicies, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldEndOrContinueFindInOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_FindInEndOrContinueListRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findInEndOrContinueOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterFindInEndOrContinuePolicies, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldPostFindInListOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findWhereRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findInPostListOptions), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.GeneralRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.RuleKind.YieldFindProjectSmartOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findProjectSmartRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.None, System.Array.init(["|"], System.String)), $t.RequiredKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findKeywords, $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            RegisterCommandEntities: function (commandContext, extendedEntities, replaceEntities) {
                var context = new Kusto.Data.IntelliSense.KustoCommandContext(commandContext.Context); // table name with no opereation context
                var columnMappingsToTables = this.ColumnMappingsToTables;
                // Check if this is a remote schema reference (should have been resolved in ResolveKnownEntitiesFromContext())
                if (this.m_remoteColumnMappingsToTables.containsKey(commandContext)) {
                    var cluster = { };
                    var database = { };
                    var remoteTableContext = { };
                    if (this.ResolveRemoteContext(commandContext.Context, cluster, database, remoteTableContext)) {
                        context = new Kusto.Data.IntelliSense.KustoCommandContext(remoteTableContext.v); // table name with no opereation context
                    }

                    columnMappingsToTables = this.m_remoteColumnMappingsToTables.get(commandContext);
                }

                if (!replaceEntities) {
                    if (columnMappingsToTables.containsKey(context)) {
                        extendedEntities.AddRange(columnMappingsToTables.get(context));
                    }
                }

                this.OverridingColumnMapping.set(commandContext, System.Linq.Enumerable.from(extendedEntities).orderBy($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f57).toList(System.String));
            },
            ResolveEntitiesFromCommand: function (input, entitiesList, knownEntities) {
                var $t;
                var result = { v : Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.None };

                // Remove string literals
                var command = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_removeStringLiteralsSurroundedBySpacesRegex.replace(input, " ");
                command = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_removeCommentsRegex.replace(command, ""); // Remove comments

                var unionCommandSegments = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_lastCommandSegmentRegex.match(command);
                if (unionCommandSegments.getSuccess()) {
                    command = unionCommandSegments.getGroups().getByName("LastSegment").toString();
                }

                var commandClauses = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ParseCommandClauses(command);
                if (System.Linq.Enumerable.from(commandClauses).count() === 1) {
                    return this.ResolveEntitiesFromClause(entitiesList, knownEntities, result, command);
                }

                var unifiedEntities = new (System.Collections.Generic.HashSet$1(System.String)).ctor();
                $t = Bridge.getEnumerator(commandClauses, System.String);
                try {
                    while ($t.moveNext()) {
                        var clause = $t.Current;
                        var clauseEntities = new (System.Collections.Generic.List$1(System.String)).ctor();
                        result.v = this.ResolveEntitiesFromClause(clauseEntities, knownEntities, result, clause);
                        unifiedEntities.unionWith(clauseEntities);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }entitiesList.AddRange(unifiedEntities);
                return result.v;
            },
            InjectFunctionsAsLetStatementsIfNeeded: function (input, usedFunctions) {
                var $t;
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$7(System.String, Bridge.global.System.Object, this.FunctionMappings)) {
                    var funcitonStatementsBuilder = new System.Text.StringBuilder();
                    $t = Bridge.getEnumerator(this.FunctionMappings);
                    try {
                        while ($t.moveNext()) {
                            var kvp = $t.Current;
                            var funcName = kvp.key;
                            var isFuncPresentRegex = kvp.value.Item2;
                            var funcExpression = kvp.value.Item1;
                            if (!usedFunctions.contains(funcName) && isFuncPresentRegex.isMatch(input)) {
                                funcitonStatementsBuilder.appendLine(funcExpression);
                                usedFunctions.add(funcName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    if (funcitonStatementsBuilder.getLength() > 0) {
                        var funcitonAdditions = funcitonStatementsBuilder.toString();
                        var moreFunctions = this.InjectFunctionsAsLetStatementsIfNeeded(funcitonAdditions, usedFunctions);
                        input = (moreFunctions || "") + (input || "");
                    }
                }
                return input;
            },
            ResolveEntitiesFromClause: function (entitiesList, knownEntities, result, input) {
                var statements = this.InjectFunctionsAsLetStatementsIfNeeded(input, new (System.Collections.Generic.HashSet$1(System.String)).ctor());
                var analyzeResult = this.AnalyzeStatementsImpl(statements, false);
                var command = analyzeResult.Command;

                if (System.String.isNullOrWhiteSpace(command)) {
                    return result.v;
                }

                var opEntitiesMap = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.BuildOpEntitiesMap(command);

                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleRangeEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandlePrintEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleProjectEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = this.HandleFindEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = this.HandleSearchEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleExtendEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleMvexpandEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleSummarizeEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleMakeSeriesEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleTopNestedEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleReduceByEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleParseEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleGetSchemaEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleSampleDistinctEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                if (result.v === Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities) {
                    knownEntities = entitiesList;
                } else if (result.v === Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.AppendEntities) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, knownEntities)) {
                        knownEntities = entitiesList;
                    } else {
                        knownEntities = System.Linq.Enumerable.from(knownEntities).union(entitiesList).toList(System.String);
                    }
                }

                result.v = this.HandleProjectRenameEntities(entitiesList, result.v, opEntitiesMap, knownEntities);
                result.v = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.HandleProjectAwayEntities(entitiesList, result.v, opEntitiesMap, knownEntities);

                return result.v;
            },
            HandleFindEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                var $t, $t1, $t2;
                var list = { v : null };
                if (!opEntitiesMap.tryGetValue("find", list)) {
                    return result;
                }

                var wasAdded = false;

                var hasPipe = System.String.endsWith(list.v, "|");
                list.v = Kusto.Cloud.Platform.Utils.ExtendedString.TrimEnd(list.v, "|");

                if (hasPipe) {
                    // assume we have a "full" find, so the user typed '|' with 'project' or with or without "project-smart"

                    var projectionMatch = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_findProjectionRegex.match(list.v);
                    if (projectionMatch.getSuccess()) {
                        var projectedList = projectionMatch.getGroups().getByName("projectedList").getValue();

                        // Handle pack_ entity
                        var projectedListCopy = projectedList;

                        projectedList = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_packRgx.replace(projectedList, "");

                        if (!Bridge.referenceEquals(projectedList, projectedListCopy)) {
                            wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, "pack_"));
                        }

                        // Break the list of projected entities and add the rest of the projected entities
                        var entities = new (System.Collections.Generic.List$1(System.String)).ctor();
                        if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveEntitiesFromList(entities, projectedList)) {
                            var knownProjectedEntities = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.IntersectWith(System.String, entities, knownEntities);
                            $t = Bridge.getEnumerator(knownProjectedEntities, System.String);
                            try {
                                while ($t.moveNext()) {
                                    var entity = $t.Current;
                                    wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity));
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }}
                    } else {
                        // Assume we are in "project-smart" scenario
                        if (knownEntities != null) {
                            $t1 = Bridge.getEnumerator(knownEntities, System.String);
                            try {
                                while ($t1.moveNext()) {
                                    var entity1 = $t1.Current;
                                    wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity1));
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }}

                        wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, "pack_"));
                    }

                    // Handle withsource entity
                    var withsourceMatch = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_withsourceExtractRegex.match(list.v);
                    var tableNameColumn = withsourceMatch.getSuccess() ? withsourceMatch.getGroups().getByName("tableNameColumn").getValue() : "source_";
                    wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, tableNameColumn));

                    if (!projectionMatch.getSuccess()) {
                        wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, "pack_"));
                    }

                    //TODO: also offer columns that participate in the predicate
                } else {
                    if (knownEntities != null) {
                        $t2 = Bridge.getEnumerator(knownEntities, System.String);
                        try {
                            while ($t2.moveNext()) {
                                var entity2 = $t2.Current;
                                wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity2));
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }}
                }

                if (wasAdded) {
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                }

                return result;
            },
            HandleSearchEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                var $t;
                var list = { v : null };
                if (!opEntitiesMap.tryGetValue("search", list)) {
                    return result;
                }

                var wasAdded = false;

                if (knownEntities != null) {
                    $t = Bridge.getEnumerator(knownEntities, System.String);
                    try {
                        while ($t.moveNext()) {
                            var entity = $t.Current;
                            wasAdded = !!(wasAdded | Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddFieldIfNotPresent(entitiesList, entity));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }}

                if (wasAdded) {
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                }

                return result;
            },
            HandleProjectRenameEntities: function (entitiesList, result, opEntitiesMap, knownEntities) {
                var $t, $t1;
                var list = { v : null };
                if (!opEntitiesMap.tryGetValue("project-rename", list)) {
                    return result;
                }

                var removedEntities = new (System.Collections.Generic.List$1(System.String)).ctor();

                var wasChanged = false;
                var entities = System.String.split(list.v, System.Array.init([44], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, entities)) {
                    return result;
                }

                var isOriginalEntitiesListEmpty = Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(System.String, entitiesList);

                $t = Bridge.getEnumerator(entities);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        var tuple = System.String.split(pair, System.Array.init([61], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                        if (tuple.length !== 2) {
                            continue;
                        }

                        var targetName = Kusto.Data.IntelliSense.ExpressionEntityParser.UnescapeEntityName(tuple[System.Array.index(0, tuple)]);
                        var sourceName = Kusto.Data.IntelliSense.ExpressionEntityParser.UnescapeEntityName(tuple[System.Array.index(1, tuple)]);

                        if (System.String.isNullOrEmpty(targetName) || System.String.isNullOrEmpty(sourceName) || System.String.equals(targetName, sourceName, 4)) {
                            continue;
                        }

                        removedEntities.add(sourceName);

                        if (entitiesList.contains(sourceName)) {
                            entitiesList.remove(sourceName);
                            wasChanged = true;
                        }

                        if (!entitiesList.contains(targetName)) {
                            Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, targetName);
                            wasChanged = true;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                // Resolve remaining entities from "knownEntities" instead of from "entitiesList".
                // This is needed in case project-rename was the first operator in the command that requires entity resolving
                // and the entitiesList does not contain any entities at this stage. 
                if (System.Linq.Enumerable.from(removedEntities).any() && isOriginalEntitiesListEmpty && Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, knownEntities)) {
                    $t1 = Bridge.getEnumerator(System.Linq.Enumerable.from(knownEntities).except(removedEntities).ToArray(System.String));
                    try {
                        while ($t1.moveNext()) {
                            var field = $t1.Current;
                            Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.AddEscapedEntityName(entitiesList, field);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }}

                if (wasChanged) {
                    result = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveResult.ReplaceEntities;
                }
                return result;
            },
            AnalyzeCommand$1: function (statement, cachedReference) {
                var input = this.InjectFunctionsAsLetStatementsIfNeeded(statement, new (System.Collections.Generic.HashSet$1(System.String)).ctor());

                // Copy context cache from reference command (if present)
                if (cachedReference != null && cachedReference.ContextCache != null) {
                    this.ContextCache = new (System.Collections.Generic.Dictionary$2(System.Int32,Kusto.Data.IntelliSense.KustoCommandContext))(cachedReference.ContextCache);
                }

                // Look if last statement exists
                if (System.String.indexOf(input, String.fromCharCode(59)) < 0) {
                    var result = new Kusto.Data.IntelliSense.AnalyzedCommand();
                    result.Command = statement;
                    result.Context = this.ResolveContextFromCommand(input);
                    return result;
                }

                return this.AnalyzeStatementsImpl(input, true);
            },
            AnalyzeCommand: function (analyzedCommand, appendingPart) {
                var $t;
                if (System.String.isNullOrWhiteSpace(appendingPart)) {
                    return analyzedCommand;
                }

                if (analyzedCommand == null || System.String.isNullOrEmpty(analyzedCommand.Command)) {
                    return this.AnalyzeCommand$1(appendingPart, null);
                }

                var appendedCommand = (analyzedCommand.Command || "") + (appendingPart || "");
                if (System.String.indexOf(appendingPart, String.fromCharCode(59)) >= 0 || System.String.endsWith(analyzedCommand.Command.trim(), ";") || Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_nonDefaultContextKeywordsRegex.isMatch(appendingPart)) {
                    return this.AnalyzeCommand$1(appendedCommand, null);
                }

                return ($t = new Kusto.Data.IntelliSense.AnalyzedCommand(), $t.Command = appendedCommand, $t.Context = analyzedCommand.Context, $t);
            },
            ResolveContextFromCommand: function (command) {
                var $t;
                if (System.String.isNullOrWhiteSpace(command)) {
                    return Kusto.Data.IntelliSense.KustoCommandContext.Empty;
                }

                // Remove string literals
                var commandWithoutStringLiterals = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_removeStringLiteralsSurroundedBySpacesRegex.replace(command, " ");
                // Remove comments
                commandWithoutStringLiterals = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_removeCommentsRegex.replace(commandWithoutStringLiterals, "");
                commandWithoutStringLiterals = commandWithoutStringLiterals.trim();

                var hashCode = Bridge.getHashCode(commandWithoutStringLiterals);
                if (this.m_contextCache.containsKey(hashCode)) {
                    return this.m_contextCache.get(hashCode);
                }

                var tableContext = "";
                var contextOperation = Kusto.Data.IntelliSense.ContextOperation.Intersect;
                var matchesKeywords = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_nonDefaultContextKeywordsRegex.matches(commandWithoutStringLiterals);
                var lastMatch = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.GetLatestMatch(matchesKeywords);
                var isFind = false;
                var isSearch = false;

                if (lastMatch != null) {
                    var keyword = lastMatch.getGroups().get(0).toString();
                    var contextMatchRegex = { };
                    if (Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContextRegexes.tryGetValue(keyword, contextMatchRegex)) {
                        tableContext = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveContextUsingRegex(commandWithoutStringLiterals, contextMatchRegex.v, lastMatch.getIndex());
                    }

                    isFind = (Bridge.referenceEquals(keyword, "find"));
                    isSearch = (Bridge.referenceEquals(keyword, "search"));

                    // For 'search in ()' set the contextOperation to union
                    if (isSearch && !System.String.isNullOrEmpty(tableContext)) {
                        contextOperation = Kusto.Data.IntelliSense.ContextOperation.Union;
                    }
                }

                if (isFind && Bridge.referenceEquals(tableContext, "")) {
                    tableContext = "database('*')";
                }

                // Try resolve using default context
                if (System.String.isNullOrEmpty(tableContext)) {
                    if (isFind) {
                        tableContext = "*";
                    } else {
                        var defaultContextMatcher = { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandDefaultContext, Item2: null };
                        tableContext = ($t = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveContextUsingRegex(commandWithoutStringLiterals, defaultContextMatcher, 0), $t != null ? $t : "");

                        // If no explicit context for search (no 'TabularSource | search ..' nor 'search in ()'), use union * as context
                        if (isSearch && System.String.equals(tableContext, "search")) {
                            tableContext = "*";
                            contextOperation = Kusto.Data.IntelliSense.ContextOperation.Union;
                        }
                    }
                }

                var commandContext = System.String.isNullOrEmpty(tableContext) ? Kusto.Data.IntelliSense.KustoCommandContext.Empty : new Kusto.Data.IntelliSense.KustoCommandContext(tableContext, contextOperation);
                this.m_contextCache.set(hashCode, commandContext);
                return commandContext;
            },
            AnalyzeStatementsImpl: function (statements, requireContext) {
                var result = new Kusto.Data.IntelliSense.AnalyzedCommand();

                // Get all 'let' statements
                var letStatements = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ResolveLetExpressions(statements);
                result.Command = Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.FindLastStatement(statements);
                if (requireContext || letStatements.count > 0) {
                    result.Context = this.ResolveContextFromCommand(result.Command);
                }

                if (letStatements.count === 0) {
                    return result;
                }

                while (letStatements.containsKey(result.Context.Context)) {
                    var expression = letStatements.get(result.Context.Context);
                    var replaceRegex = new System.Text.RegularExpressions.Regex.ctor("\\b" + (result.Context.Context || "") + "\\b(\\(.*?\\))?");
                    result.Command = replaceRegex.replace(result.Command, expression);
                    letStatements.remove(result.Context.Context);
                    result.Context = this.ResolveContextFromCommand(expression);
                }

                return result;
            },
            GetKnownEntities: function (command, context, mapOfOriginallyKnownEntities, knownEntities, originallyKnownEntities) {
                var rule = { };

                if (this.TryMatchSpecificRule(command, context, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForFilterInFind, rule)) {
                    knownEntities.v = System.Linq.Enumerable.from(rule.v.GetOptions(context)).toList(System.String);
                    if (!mapOfOriginallyKnownEntities.containsKey(context)) {
                        mapOfOriginallyKnownEntities.set(context, knownEntities.v);
                    }
                    originallyKnownEntities.v = mapOfOriginallyKnownEntities.get(context);
                    return true; // The only time when full parsing occurred
                }

                if (this.TryMatchSpecificRule((command || "") + " project ", context, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProjectInFind, rule)) {
                    knownEntities.v = System.Linq.Enumerable.from(rule.v.GetOptions(context)).toList(System.String);
                    if (!mapOfOriginallyKnownEntities.containsKey(context)) {
                        mapOfOriginallyKnownEntities.set(context, knownEntities.v);
                    }
                    originallyKnownEntities.v = mapOfOriginallyKnownEntities.get(context);
                    return true; // The only time when full parsing occurred
                }

                command = (command || "") + " | project ";
                if (this.TryMatchSpecificRule(command, context, Kusto.Data.IntelliSense.RuleKind.YieldColumnNamesForProject, rule)) {
                    knownEntities.v = System.Linq.Enumerable.from(rule.v.GetOptions(context)).toList(System.String);
                    if (!mapOfOriginallyKnownEntities.containsKey(context)) {
                        mapOfOriginallyKnownEntities.set(context, knownEntities.v);
                    }
                    originallyKnownEntities.v = mapOfOriginallyKnownEntities.get(context);
                    return true; // The only time when full parsing occurred
                }

                return false;
            },
            LoadCommandToolTips: function () {
                var $t;
                var toolTipCommands = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTip)).ctor();
                this.CommandToolTips = toolTipCommands;

                {
                    var command = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "tostring", $t.Summary = "Converts the given value to string", $t.Usage = "... | extend str = <i>tostring</i>(Column1)", $t);
                    var parameters = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command.Parameters = parameters;
                    parameters.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "T", $t.Name = "value", $t.Description = "The value to convert to string", $t));
                    toolTipCommands.add(command);
                }

                {
                    var command1 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "strlen", $t.Summary = "Returns the length of the given string", $t.Usage = "... | extend length = <i>strlen</i>(Column1)", $t);
                    var parameters1 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command1.Parameters = parameters1;
                    parameters1.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "value", $t.Description = "The string being measured for length", $t));
                    toolTipCommands.add(command1);
                }

                {
                    var command2 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "hash", $t.Summary = "Returns the xxhash value of a scalar value", $t.Usage = "... | extend hash = <i>hash</i>(Column1, 100)", $t);
                    var parameters2 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command2.Parameters = parameters2;
                    parameters2.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "Every scalar type </b><i>except</i><b> Dynamic", $t.Name = "target", $t.Description = "The value the hash is calculated on", $t));
                    parameters2.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "long", $t.Name = "modulo", $t.Description = "The modulo value to be applied on the hash result", $t));
                    toolTipCommands.add(command2);
                }

                {
                    var command3 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "iff", $t.Summary = "Returns one of two values, depending on whether the Boolean expression evaluates to true or false", $t.Usage = "... | extend val = <i>iff</i>(strlen(Column1) > 10, 'long', 'short')", $t);
                    var parameters3 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command3.Parameters = parameters3;
                    parameters3.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "bool", $t.Name = "expression", $t.Description = "The Boolean expression you want to evaluate", $t));
                    parameters3.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "T", $t.Name = "trueValue", $t.Description = " Returned if 'expression' evaluates to True", $t));
                    parameters3.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "T", $t.Name = "falseValue", $t.Description = "Returned if 'expression' evaluates to False", $t));
                    toolTipCommands.add(command3);
                }

                {
                    var command4 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "extract", $t.Summary = "Produces a scalar using a regular expression (<a href=https://re2.googlecode.com/hg/doc/syntax.html>RE2 reference</a>)", $t.Usage = "... | extend number = <i>extract</i>(@'(\\d+)', 1, Column1, typeof(int))", $t);
                    var parameters4 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command4.Parameters = parameters4;
                    parameters4.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "regex", $t.Description = "The regular expression to be applied", $t));
                    parameters4.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "int", $t.Name = "groupIndex", $t.Description = "The index of the matching group (1 = 1st matching group in regex, 2 = 2nd matching group, etc.)", $t));
                    parameters4.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "column", $t.Name = "columnName", $t.Description = "Specify column to operate on (can be calculated column)", $t));
                    parameters4.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "typename typeof(T)", $t.Name = "type", $t.Description = "Optional type to convert the result to", $t.Optional = true, $t));
                    toolTipCommands.add(command4);
                }

                {
                    var command5 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "replace", $t.Summary = "Replace a string with another string using a regular expression (<a href=https://re2.googlecode.com/hg/doc/syntax.html>RE2 reference</a>)", $t.Usage = "... | replace str = <i>replace</i>(@'foo', @'bar', Column1)", $t);
                    var parameters5 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command5.Parameters = parameters5;
                    parameters5.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "matchingPattern", $t.Description = "String or regular expression to be applied for matching", $t));
                    parameters5.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "rewritePattern", $t.Description = "String or regular expression to be used for rewrite (\\1 = 1st matching group in regex, \\2 = 2nd matching group, etc.)", $t));
                    parameters5.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "column", $t.Name = "columnName", $t.Description = "Specify column to operate on (can be calculated column)", $t));
                    toolTipCommands.add(command5);
                }

                {
                    var command6 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "extractjson", $t.Summary = "Produces a scalar using a JSONPath expression (<a href=http://goessner.net/articles/JsonPath/>JSONPath reference</a>)", $t.Usage = "... | extend number = <I>extractjson</I>(@'$.Object.Property', Column1, typeof(int))", $t);
                    var parameters6 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command6.Parameters = parameters6;
                    parameters6.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "jsonPath", $t.Description = "The JSON Path expression to be used", $t));
                    parameters6.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "column", $t.Name = "columnName", $t.Description = "Specify column to operate on (can be calculated column)", $t));
                    parameters6.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "typename typeof(T)", $t.Name = "type", $t.Description = "Optional type to convert the result to", $t.Optional = true, $t));
                    toolTipCommands.add(command6);
                }

                {
                    var command7 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "parsejson", $t.Summary = "Converts a JSON string into a value of type 'dynamic' (an object), whose properties can be further accessed using dot or bracket notation", $t.Usage = "... | extend obj = <I>parsejson</I>(Column1)", $t);
                    var parameters7 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command7.Parameters = parameters7;
                    parameters7.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "columnName", $t.Description = "Any valid query expression that returns a string (e.g. a column name)", $t));
                    toolTipCommands.add(command7);
                }

                {
                    var command8 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "toupper", $t.Summary = "Converts the given string to upper case", $t.Usage = "... | extend upper = <I>topupper</I>(Column1)", $t);
                    var parameters8 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command8.Parameters = parameters8;
                    parameters8.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "value", $t.Description = "The string to be converted to upper case", $t));
                    toolTipCommands.add(command8);
                }

                {
                    var command9 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "tolower", $t.Summary = "Converts the given string to lower case", $t.Usage = "... | extend lower = <I>tolower</I>(Column1)", $t);
                    var parameters9 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command9.Parameters = parameters9;
                    parameters9.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "value", $t.Description = "The string to be converted to lower case", $t));
                    toolTipCommands.add(command9);
                }

                {
                    var command10 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "substring", $t.Summary = "Retrieves a substring from the given string", $t.Usage = "... | extend substr = <I>substring</I>(Column1,1,3)", $t);
                    var parameters10 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command10.Parameters = parameters10;
                    parameters10.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "value", $t.Description = "The string to be substringed", $t));
                    parameters10.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "long", $t.Name = "startIndex", $t.Description = "The zero-based starting character position of a substring in this instance", $t));
                    parameters10.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "long", $t.Name = "count", $t.Description = "The number of characters in the substring", $t.Optional = true, $t));
                    toolTipCommands.add(command10);
                }

                {
                    var command11 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "split", $t.Summary = "Retrieves a string array that contains the substrings of the given source string that are delimited by the given delimiter", $t.Usage = "... | extend split = <I>split</I>(Column1,\";\")", $t);
                    var parameters11 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command11.Parameters = parameters11;
                    parameters11.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "source", $t.Description = "The string to be splitted", $t));
                    parameters11.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "delimiter", $t.Description = "The delimiter on which the split will be based on", $t));
                    parameters11.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "integer", $t.Name = "index", $t.Description = "The index of the requested substring", $t.Optional = true, $t));
                    toolTipCommands.add(command11);
                }

                {
                    var command12 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "strcat", $t.Summary = "Concatenates several strings together (up-to 16 parameters)", $t.Usage = "... | extend s = <I>strcat</I>('KU', 'S', 'TO')", $t);
                    var parameters12 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command12.Parameters = parameters12;

                    parameters12.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "value", $t.Description = "First part", $t));

                    parameters12.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "values", $t.Description = "Other parts", $t.IsArgsArray = true, $t.Optional = true, $t));

                    toolTipCommands.add(command12);
                }


                {
                    var command13 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "countof", $t.Summary = "Returns the number of pattern matches in the given string", $t.Usage = "... | extend matches = <i>countof</i>(Expression, Pattern, Type)", $t);
                    var parameters13 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command13.Parameters = parameters13;
                    parameters13.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "Expression", $t.Description = "The string to match the pattern to", $t));

                    parameters13.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "Pattern", $t.Description = "The pattern to match the expression to. Can be a regular expression", $t));

                    parameters13.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "string", $t.Name = "Type", $t.Description = "For substring count leave empty or specifiy 'normal', for regular expression count specify 'regex'", $t));

                    toolTipCommands.add(command13);
                }



                {
                    var command14 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "percentile", $t.Summary = "Returns the estimated value for the given percentile over source values", $t.Usage = "... | summarize <i>percentile</i>(source, percent) ...", $t);
                    var parameters14 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command14.Parameters = parameters14;
                    parameters14.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "numeric </b><i>or</i><b> DateTime </b><i>or</i><b> TimeSpan", $t.Name = "Source", $t.Description = "Range of values over which to estimate percentile", $t));

                    parameters14.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "real", $t.Name = "percent", $t.Description = "Value in the range [0..100] giving the percentile to estimate", $t));

                    toolTipCommands.add(command14);
                }



                {
                    var command15 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "percentiles", $t.Summary = "Returns the estimated value for each of the given percentiles over source values", $t.Usage = "... | summarize <i>percentiles</i>(source, percent, ...) ...", $t);
                    var parameters15 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command15.Parameters = parameters15;
                    parameters15.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "numeric </b><i>or</i><b> DateTime </b><i>or</i><b> TimeSpan", $t.Name = "Source", $t.Description = "Range of values over which to estimate percentile", $t));

                    parameters15.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "real", $t.Name = "percent", $t.Description = "Value in the range [0..100] giving the percentile to estimate", $t.IsArgsArray = true, $t));

                    toolTipCommands.add(command15);
                }


                {
                    var command16 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "percentilew", $t.Summary = "Returns the estimated value for the given percentile over weighted source values", $t.Usage = "... | summarize <i>percentilew</i>(source, weight, percent) ...", $t);
                    var parameters16 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command16.Parameters = parameters16;
                    parameters16.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "numeric </b><i>or</i><b> DateTime </b><i>or</i><b> TimeSpan", $t.Name = "Source", $t.Description = "Range of values over which to estimate percentile", $t));
                    parameters16.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "integer", $t.Name = "Weight", $t.Description = "Range of weights to give to each source value", $t));
                    parameters16.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "real", $t.Name = "percent", $t.Description = "Value in the range [0..100] giving the percentile to estimate", $t));

                    toolTipCommands.add(command16);
                }



                {
                    var command17 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "percentilesw", $t.Summary = "Returns the estimated value for each of the given percentiles over weighted source values", $t.Usage = "... | summarize <i>percentilesw</i>(source, weight, percent, ...) ...", $t);
                    var parameters17 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command17.Parameters = parameters17;
                    parameters17.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "numeric </b><i>or</i><b> DateTime </b><i>or</i><b> TimeSpan", $t.Name = "Source", $t.Description = "Range of values over which to estimate percentile", $t));
                    parameters17.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "integer", $t.Name = "Weight", $t.Description = "Range of weights to give to each source value", $t));
                    parameters17.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "real", $t.Name = "percent", $t.Description = "Value in the range [0..100] giving the percentile to estimate", $t.IsArgsArray = true, $t));

                    toolTipCommands.add(command17);
                }

                {
                    var command18 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "ingestion_time", $t.Summary = "returns a datetime value specifying when the record was first available for query", $t.Usage = "... | extend length = <i>ingestiontime</i>()", $t);
                    command18.Parameters = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    toolTipCommands.add(command18);
                }

                {
                    var command19 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "countif", $t.Summary = "Returns the number of rows that matches the predicate", $t.Usage = "... | summarize <i>countif</i>(Predicate)", $t);
                    var parameters18 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command19.Parameters = parameters18;
                    parameters18.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "boolean", $t.Name = "Predicate", $t.Description = "Boolean expression used as predicate", $t));
                    toolTipCommands.add(command19);
                }

                {
                    var command20 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "dcountif", $t.Summary = "Returns the number of unique values of Expression in rows that matches the predicate", $t.Usage = "... | summarize <i>dcountif</i>(Expression, Predicate, Accuracy)", $t);
                    var parameters19 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command20.Parameters = parameters19;
                    parameters19.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "T", $t.Name = "Expression", $t.Description = "The unique values to count", $t));
                    parameters19.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "boolean", $t.Name = "Predicate", $t.Description = "Boolean expression used as predicate", $t));
                    parameters19.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "integer", $t.Name = "Accuracy", $t.Description = "Optional. Controls the balance between speed and accuracy", $t));
                    toolTipCommands.add(command20);
                }

                {
                    var command21 = ($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTip(), $t.Name = "sumif", $t.Summary = "Returns the sum of rows that matches the predicate", $t.Usage = "... | summarize <i>sumif</i>(Predicate, Column)", $t);
                    var parameters20 = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter)).ctor();
                    command21.Parameters = parameters20;
                    parameters20.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "boolean", $t.Name = "Predicate", $t.Description = "Boolean expression used as predicate", $t));
                    parameters20.add(($t = new Kusto.Data.IntelliSense.IntelliSenseCommandTipParameter(), $t.DataType = "numeric </b><i>or</i><b> DateTime </b><i>or</i><b> TimeSpan", $t.Name = "Column", $t.Description = "Column or other scalar funciton to calculate the sum of", $t));
                    toolTipCommands.add(command21);
                }
            }
        }
    });

    Bridge.define("$AnonymousType$1", $asm, {
        $kind: "anonymous",
        ctors: {
            ctor: function (name, parentTableName, typeCode) {
                this.Name = name;
                this.ParentTableName = parentTableName;
                this.TypeCode = typeCode;
            }
        },
        methods: {
            equals: function (o) {
                if (!Bridge.is(o, $asm.$AnonymousType$1)) {
                    return false;
                }
                return Bridge.equals(this.Name, o.Name) && Bridge.equals(this.ParentTableName, o.ParentTableName) && Bridge.equals(this.TypeCode, o.TypeCode);
            },
            getHashCode: function () {
                var h = Bridge.addHash([7550196186, this.Name, this.ParentTableName, this.TypeCode]);
                return h;
            },
            toJSON: function () {
                return {
                    Name : this.Name,
                    ParentTableName : this.ParentTableName,
                    TypeCode : this.TypeCode
                };
            }
        },
        statics : {
            methods: {
                $metadata : function () { return {"m":[{"a":2,"n":"Name","t":16,"rt":System.String,"g":{"a":2,"n":"get_Name","t":8,"rt":System.String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"ParentTableName","t":16,"rt":System.String,"g":{"a":2,"n":"get_ParentTableName","t":8,"rt":System.String,"fg":"ParentTableName"},"fn":"ParentTableName"},{"a":2,"n":"TypeCode","t":16,"rt":Kusto.Data.IntelliSense.EntityDataType,"g":{"a":2,"n":"get_TypeCode","t":8,"rt":Kusto.Data.IntelliSense.EntityDataType,"fg":"TypeCode","box":function ($v) { return Bridge.box($v, Kusto.Data.IntelliSense.EntityDataType, System.Enum.toStringFn(Kusto.Data.IntelliSense.EntityDataType));}},"fn":"TypeCode"}]}; }
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider, {
        f1: function (f) {
            return "-" + (f || "");
        },
        f2: function (_o1) {
            _o1.add("series_stats", System.Array.init(["min", "min_idx", "max", "max_idx", "avg", "stdev", "variance"], System.String));
            _o1.add("series_fit_line", System.Array.init(["rsquare", "slope", "variance", "rvariance", "interception", "line_fit"], System.String));
            _o1.add("series_fit_2lines", System.Array.init(["rsquare", "split_idx", "variance", "rvariance", "line_fit", "right_rsquare", "right_slope", "right_interception", "right_variance", "right_rvariance", "left_rsquare", "left_slope", "left_interception", "left_variance", "left_rvariance"], System.String));
            _o1.add("series_periods_detect", System.Array.init(["periods", "scores"], System.String));
            _o1.add("series_periods_validate", System.Array.init(["periods", "scores"], System.String));
            return _o1;
        },
        f3: function (func) {
            return func;
        },
        f4: function (func) {
            return Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceStepBackPolicy;
        },
        f5: function (_o9) {
            _o9.add("filter");
            _o9.add("where");
            return _o9;
        },
        f6: function (_o10) {
            _o10.add("project");
            return _o10;
        },
        f7: function (_o11) {
            _o11.add("project-away");
            return _o11;
        },
        f8: function (_o12) {
            _o12.add("project-rename");
            return _o12;
        },
        f9: function (_o13) {
            _o13.add("project");
            _o13.add("extend");
            return _o13;
        },
        f10: function (_o14) {
            _o14.add("join");
            return _o14;
        },
        f11: function (_o15) {
            _o15.add("top");
            _o15.add("top-hitters");
            _o15.add("order");
            _o15.add("sort");
            _o15.add("reduce");
            _o15.add("top-nested");
            return _o15;
        },
        f12: function (_o16) {
            _o16.add("top");
            _o16.add("top-hitters");
            _o16.add("order");
            _o16.add("sort");
            _o16.add("reduce");
            _o16.add("top-nested");
            _o16.add("render");
            return _o16;
        },
        f13: function (_o17) {
            _o17.add("top");
            _o17.add("order");
            _o17.add("sort");
            return _o17;
        },
        f14: function (_o18) {
            _o18.add("top");
            _o18.add("top-hitters");
            _o18.add("order");
            _o18.add("sort");
            _o18.add("top-nested");
            return _o18;
        },
        f15: function (_o19) {
            _o19.add("reduce");
            return _o19;
        },
        f16: function (_o20) {
            _o20.add("parse");
            return _o20;
        },
        f17: function (_o21) {
            _o21.add("render");
            return _o21;
        },
        f18: function (_o22) {
            _o22.add("top");
            _o22.add("limit");
            _o22.add("take");
            _o22.add("top-nested");
            _o22.add("top-hitters");
            _o22.add("sample");
            _o22.add("sample-distinct");
            return _o22;
        },
        f19: function (_o23) {
            _o23.add("evaluate");
            return _o23;
        },
        f20: function (_o24) {
            _o24.add("summarize");
            return _o24;
        },
        f21: function (_o25) {
            _o25.add("distinct");
            return _o25;
        },
        f22: function (_o26) {
            _o26.add("top-nested");
            return _o26;
        },
        f23: function (_o27) {
            _o27.add("top-hitters");
            return _o27;
        },
        f24: function (_o28) {
            _o28.add("sample-distinct");
            return _o28;
        },
        f25: function (_o29) {
            _o29.add("top-nested");
            _o29.add("top-hitters");
            _o29.add("summarize");
            _o29.add("distinct");
            return _o29;
        },
        f26: function (_o30) {
            _o30.add("database");
            return _o30;
        },
        f27: function (_o31) {
            _o31.add("find");
            return _o31;
        },
        f28: function (_o32) {
            _o32.add("search");
            return _o32;
        },
        f29: function (_o33) {
            _o33.add("make-series");
            return _o33;
        },
        f30: function (_o34) {
            _o34.add("cnt", "count");
            _o34.add("percentiles", "percentile");
            _o34.add("percentilew", "percentile");
            _o34.add("percentilesw", "percentile");
            _o34.add("makelist", "list");
            _o34.add("makeset", "set");
            _o34.add("make_dictionary", "dictionary");
            return _o34;
        },
        f31: function (_o35) {
            _o35.add("join");
            _o35.add("project");
            _o35.add("summarize");
            _o35.add("reduce");
            _o35.add("getschema");
            _o35.add("distinct");
            return _o35;
        },
        f32: function (_o36) {
            _o36.add("join", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Join, Item2: null });
            _o36.add(".show", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Show, Item2: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_showCommandFixRegex });
            _o36.add("range", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Range, Item2: null });
            _o36.add("toscalar", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_ToScalar, Item2: null });
            _o36.add("{", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Callable, Item2: null });
            _o36.add("let", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Let, Item2: null });
            _o36.add("union", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Union, Item2: null });
            _o36.add("find", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Find, Item2: null });
            _o36.add("search", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_Search, Item2: null });
            _o36.add("#connect", { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_commandContext_ConnectDirective, Item2: null });
            return _o36;
        },
        f33: function (s) {
            return s;
        },
        f34: function (s) {
            return System.Text.RegularExpressions.Regex.escape(s);
        },
        f35: function (_o37) {
            _o37.add(new System.Text.RegularExpressions.Regex.ctor("\\blet\\s+(?<LetExpressionName>\\w+)\\s*=.*?\\{(?<Expression>.+?)\\}", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions));
            _o37.add(new System.Text.RegularExpressions.Regex.ctor("\\blet\\s+(?<LetExpressionName>\\w+)\\s*=\\s*(?<Expression>.+?);", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions));
            return _o37;
        },
        f36: function (c) {
            return c.Name;
        },
        f37: function (c) {
            return c;
        },
        f38: function (m) {
            return (m.getGroups().get(1).getValue() || "") + " " + (m.getGroups().get(3).getValue() || "");
        },
        f39: function (_o2) {
            _o2.add("kind=", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            _o2.add("(", Kusto.Data.IntelliSense.ApplyPolicy.AppendJoinClauseWithoutOpenningBracketPolicy);
            return _o2;
        },
        f40: function (_o3) {
            var $t;
            _o3.add("timechart", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " with 'cats' ", $t));
            _o3.add("barchart", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " with 'dogs' ", $t));
            return _o3;
        },
        f41: function (_o4) {
            var $t;
            _o4.add("autocluster", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "()", $t.OffsetToken = ")", $t.OffsetPosition = 0, $t));
            _o4.add("diffpatterns", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "(\"split= \")", $t.OffsetToken = "=", $t.OffsetPosition = 2, $t));
            _o4.add("basket", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "()", $t.OffsetToken = ")", $t.OffsetPosition = 0, $t));
            _o4.add("extractcolumns", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = "()", $t.OffsetToken = ")", $t.OffsetPosition = 0, $t));
            return _o4;
        },
        f42: function (_o5) {
            _o5.add("where", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            _o5.add("in", Kusto.Data.IntelliSense.ApplyPolicy.AppendFindInClausePolicy);
            return _o5;
        },
        f43: function (_o6) {
            _o6.add("(", Kusto.Data.IntelliSense.ApplyPolicy.AppendFindInClauseWithoutOpenningBracketPolicy);
            return _o6;
        },
        f44: function (_o7) {
            var $t;
            _o7.add(")", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " where ", $t));
            _o7.add(",", Kusto.Data.IntelliSense.ApplyPolicy.AppendFindInClauseWithoutOpenningBracketPolicy);
            return _o7;
        },
        f45: function (_o8) {
            _o8.add("\"\"", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpaceStepBackPolicy);
            _o8.add("kind=", Kusto.Data.IntelliSense.ApplyPolicy.NullApplyPolicy);
            _o8.add("in", Kusto.Data.IntelliSense.ApplyPolicy.AppendSearchInClausePolicy);
            return _o8;
        },
        f46: function (kvp) {
            return kvp.value;
        },
        f47: function (f) {
            return f.toLowerCase();
        },
        f48: function (vals) {
            return vals;
        },
        f49: function (t) {
            return t.Name;
        },
        f50: function (t) {
            return t.value;
        },
        f51: function (db) {
            return db.Tables;
        },
        f52: function (t) {
            return System.Linq.Enumerable.from(t.Columns).select($asm.$.Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.f36);
        },
        f53: function (n) {
            return "'" + (n || "") + "'";
        },
        f54: function (c) {
            return "'" + (c || "") + "'";
        },
        f55: function (db) {
            return "'" + (db.Name || "") + "'";
        },
        f56: function (t) {
            return !t.IsInvisible;
        },
        f57: function (n) {
            return n;
        },
        f58: function (f) {
            return f.CallName;
        },
        f59: function (f) {
            return Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy;
        },
        f60: function (p) {
            return (p.Name || "") + "()";
        },
        f61: function (p) {
            return p;
        },
        f62: function (f) {
            return f.Name;
        },
        f63: function (f) {
            return { Item1: Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_removeCommentsRegex.replace(f.Expression, ""), Item2: new System.Text.RegularExpressions.Regex.ctor("\\b" + (f.Name || "") + "\\b", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.DefaultRegexOptions) };
        },
        f64: function (c) {
            return "cluster('" + (c || "") + "')";
        },
        f65: function (t) {
            return System.Linq.Enumerable.from(t.Columns).select(function (c) {
                    return new $asm.$AnonymousType$1(c.Name, t.Name, c.TypeCode);
                });
        },
        f66: function (c) {
            return c.TypeCode === Kusto.Data.IntelliSense.EntityDataType.String;
        },
        f67: function (e) {
            return Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule.GetHashStringForContextAndToken(e.ParentTableName, e.Name);
        },
        f68: function (t) {
            return Kusto.Data.IntelliSense.ContextualTokensWithRegexIntelliSenseRule.GetHashStringForContextAndToken(t.Name, "*");
        },
        f69: function (_o1) {
            _o1.add("in", Kusto.Data.IntelliSense.ApplyPolicy.AppendStringLiteralArrayPolicy);
            _o1.add("!in", Kusto.Data.IntelliSense.ApplyPolicy.AppendStringLiteralArrayPolicy);
            return _o1;
        },
        f70: function (c) {
            return c.TypeCode !== Kusto.Data.IntelliSense.EntityDataType.String;
        },
        f71: function (c) {
            return c.TypeCode === Kusto.Data.IntelliSense.EntityDataType.DateTime;
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase],
        statics: {
            fields: {
                s_dmRuleKinds: null,
                s_ingestionQueueTypes: null,
                s_lineWithDotBeginningRegex: null,
                s_showCommandRegex: null,
                s_showClusterCommandRegex: null,
                s_showClusterSettingsCommandRegex: null,
                s_showClusterSettingsVersionsCommandRegex: null,
                s_showPrincipalRolesCommandRegex: null,
                s_alterCommandRegex: null,
                s_alterClusterSettingsCommandRegex: null,
                s_alterClusterSettingsFromCommandRegex: null,
                s_alterMergeCommandRegex: null,
                s_alterObtainerQueuesCommandRegex: null,
                s_addOrAlterlterEventHubIngestionSourceCommandRegex: null,
                s_createCommandRegex: null,
                s_dropCommandRegex: null,
                s_addCommandRegex: null,
                s_addOrAlterCommandRegex: null,
                s_addDataObtainerCommandRegex: null,
                s_addDataObtainerInitializeCommandRegex: null,
                s_addDataObtainerInitializeWithCommandRegex: null,
                s_getCommandRegex: null,
                s_getIngestionQueuesCommandRegex: null,
                s_getIngestionQueuesTypeCommandRegex: null,
                s_flushCommandRegex: null,
                s_initializeCommandRegex: null,
                s_initializeClusterConfigCommandRegex: null,
                s_initializeClusterConfigEncryptionCommandRegex: null,
                s_resetCommandRegex: null,
                s_setCommandRegex: null,
                s_adminOperationOptions: null,
                s_showCommandOptions: null,
                s_showClustersKeywordOptions: null,
                s_showClusterSettingsKeywordOptions: null,
                s_showClusterSettingsVersionsKeywordOptions: null,
                s_showPrincipalRolesKeywordOptions: null,
                s_alterClusterSettingsFromKeywordOptions: null,
                s_alterCommandOptions: null,
                s_createCommandOptions: null,
                s_dropCommandOptions: null,
                s_addCommandOptions: null,
                s_addOrAlterCommandOptions: null,
                s_addDataObtainerCommandOptions: null,
                s_addDataObtainerInitializeCommandOptions: null,
                s_addDataObtainerInitializeWithCommandOptions: null,
                s_getCommandOptions: null,
                s_getIngestionQueuesCommandOptions: null,
                s_getIngestionQueuesTypeCommandOptions: null,
                s_flushCommandOptions: null,
                s_initializeCommandOptions: null,
                s_initializeClusterConfigurationCommandOptions: null,
                s_initializeClusterConfigurationEncryptionCommandOptions: null,
                s_resetCommandOptions: null,
                s_setCommandOptions: null,
                s_alterObtainerQueuesOptions: null,
                s_addOrAlterEventHubIngestionSourceOptions: null
            },
            ctors: {
                init: function () {
                    this.s_dmRuleKinds = System.Enum.getNames(Kusto.Data.DmSettingsType);
                    this.s_ingestionQueueTypes = System.Linq.Enumerable.from(System.Enum.getNames(Kusto.Data.IngestionQueueType)).select($asm.$.Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.f1).ToArray(System.String);
                    this.s_lineWithDotBeginningRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showClusterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showClusterSettingsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+cluster\\s+settings\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showClusterSettingsVersionsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+cluster\\s+settings\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showPrincipalRolesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+principal\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterClusterSettingsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+cluster\\s+settings\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterClusterSettingsFromCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+cluster\\s+settings\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter-merge\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterObtainerQueuesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(alter|alter-merge|drop)\\s+obtainer\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addOrAlterlterEventHubIngestionSourceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add-or-alter\\s+eventhub\\s+ingestion\\s+source\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addOrAlterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add-or-alter\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addDataObtainerCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+data\\s+obtainer\\s+\\S+\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addDataObtainerInitializeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+data\\s+obtainer\\s+\\S+\\s+\\S+\\s+initialize\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addDataObtainerInitializeWithCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+data\\s+obtainer\\s+\\S+\\s+\\S+\\s+initialize\\s+with\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_getCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.get\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_getIngestionQueuesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(get|show)\\s+ingestion\\s+queues\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_getIngestionQueuesTypeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(get|show)\\s+ingestion\\s+queues\\s+\"(.*?)\"\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_flushCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.flush\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_initializeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.initialize\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_initializeClusterConfigCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.initialize\\s+cluster\\s+configuration\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_initializeClusterConfigEncryptionCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.initialize\\s+cluster\\s+configuration\\s+\\S+\\s+encryption\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_resetCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.reset\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_adminOperationOptions = System.Array.init([
                        "show", 
                        "get", 
                        "alter", 
                        "alter-merge", 
                        "add", 
                        "add-or-alter", 
                        "create", 
                        "drop", 
                        "flush", 
                        "initialize", 
                        "reset", 
                        "set"
                    ], System.String);
                    this.s_showCommandOptions = System.Array.init([
                        "version", 
                        "diagnostics", 
                        "cluster", 
                        "lagging queues", 
                        "ingestion queues", 
                        "ingestion source types", 
                        "Geneva ingestion sources settings", 
                        "EventHub ingestion sources settings", 
                        "principal"
                    ], System.String);
                    this.s_showClustersKeywordOptions = System.Array.init(["principals", "settings"], System.String);
                    this.s_showClusterSettingsKeywordOptions = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_dmRuleKinds;
                    this.s_showClusterSettingsVersionsKeywordOptions = System.Array.init(["version", "versions"], System.String);
                    this.s_showPrincipalRolesKeywordOptions = System.Array.init(["roles", "@'principal' roles"], System.String);
                    this.s_alterClusterSettingsFromKeywordOptions = System.Array.init(["from"], System.String);
                    this.s_alterCommandOptions = System.Array.init([
                        "cluster settings", 
                        "aggregator storage accounts", 
                        "obtainer", 
                        "obtainers"
                    ], System.String);
                    this.s_createCommandOptions = System.Array.init(["tempstorage"], System.String);
                    this.s_dropCommandOptions = System.Array.init([
                        "cluster admins", 
                        "cluster users", 
                        "cluster ingestors", 
                        "obtainer", 
                        "aggregator storage accounts", 
                        "obtainers"
                    ], System.String);
                    this.s_addCommandOptions = System.Array.init([
                        "ingestion interval for", 
                        "data obtainer", 
                        "cluster admins", 
                        "cluster users"
                    ], System.String);
                    this.s_addOrAlterCommandOptions = System.Array.init(["eventhub ingestion source"], System.String);
                    this.s_addDataObtainerCommandOptions = System.Array.init(["initialize"], System.String);
                    this.s_addDataObtainerInitializeCommandOptions = System.Array.init(["with"], System.String);
                    this.s_addDataObtainerInitializeWithCommandOptions = System.Array.init(["encryption certificate"], System.String);
                    this.s_getCommandOptions = System.Array.init([
                        "lagging queues", 
                        "ingestion queues", 
                        "source containers"
                    ], System.String);
                    this.s_getIngestionQueuesCommandOptions = System.Linq.Enumerable.from(System.Array.init(["lengths", "withsas"], System.String)).concat(Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_ingestionQueueTypes).ToArray(System.String);
                    this.s_getIngestionQueuesTypeCommandOptions = System.Array.init(["withsas", "withencryptedkeys"], System.String);
                    this.s_flushCommandOptions = System.Array.init(["configuration"], System.String);
                    this.s_initializeCommandOptions = System.Array.init(["cluster configuration"], System.String);
                    this.s_initializeClusterConfigurationCommandOptions = System.Array.init(["encryption"], System.String);
                    this.s_initializeClusterConfigurationEncryptionCommandOptions = System.Array.init(["certificate"], System.String);
                    this.s_resetCommandOptions = System.Array.init(["cluster configuration"], System.String);
                    this.s_setCommandOptions = System.Array.init(["cluster as secondary"], System.String);
                    this.s_alterObtainerQueuesOptions = System.Array.init([System.Enum.toString(Kusto.Data.IngestionQueueType, Kusto.Data.IngestionQueueType.InternalQueue), System.Enum.toString(Kusto.Data.IngestionQueueType, Kusto.Data.IngestionQueueType.InputQueue)], System.String);
                    this.s_addOrAlterEventHubIngestionSourceOptions = System.Array.init(["settings with (Configuration='', EcryptionCertificateThumbprint='')"], System.String);
                }
            }
        },
        ctors: {
            ctor: function (connectionContext) {
                if (connectionContext === void 0) { connectionContext = null; }
                var $t;

                this.$initialize();
                Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.ctor.call(this);
                this.Locker;
                {
                    if (this.CommandRules == null || this.GeneralRules == null) {
                        this.LoadRulesUnderLock();
                    }
                }

                if (this.CommandToolTips == null) {
                    this.LoadCommandToolTips();
                }

                this.ContextConnection = ($t = connectionContext, $t != null ? $t : "");
            }
        },
        methods: {
            LoadRulesUnderLock: function () {
                var $t, $t1;
                this.CommandRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.GeneralRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();
                this.QueryParametersRules = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseRule)).ctor();

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAdminCommandsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_lineWithDotBeginningRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_adminOperationOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldShowCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldShowClustersKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClustersKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldShowClustersSettingsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterSettingsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterSettingsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldShowClustersSettingsVersionKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterSettingsVersionsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterSettingsVersionsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldShowPrincipalRolesCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showPrincipalRolesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showPrincipalRolesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAlterCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAlterMergeCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterMergeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAlterObtainerQueuesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterObtainerQueuesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterObtainerQueuesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddOrAlterEventHubIngestionSourceSettingsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addOrAlterlterEventHubIngestionSourceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addOrAlterEventHubIngestionSourceOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAlterClustersSettingsKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterClusterSettingsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_showClusterSettingsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAlterClustersSettingsFromKeywordOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterClusterSettingsFromCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_alterClusterSettingsFromKeywordOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldCreateCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_createCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_createCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldDropCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_dropCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_dropCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddOrAlterCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addOrAlterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addOrAlterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddDataObtainerKeyworkOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddDataObtainerInitializeKeyworkOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerInitializeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerInitializeCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldAddDataObtainerInitializeWithKeyworkOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerInitializeWithCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_addDataObtainerInitializeWithCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldGetCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldGetIngestionQueuesCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getIngestionQueuesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getIngestionQueuesCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldGetIngestionQueuesTypeCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getIngestionQueuesTypeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_getIngestionQueuesTypeCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldFlushCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_flushCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_flushCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldInitializeCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldInitializeClusterConfigCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeClusterConfigCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeClusterConfigurationCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldInitializeClusterConfigEncryptionCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeClusterConfigEncryptionCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_initializeClusterConfigurationEncryptionCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldResetCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_resetCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_resetCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.DMRuleKind.YieldSetCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_setCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider.s_setCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AnalyzeCommand$1: function (statement, cachedReference) {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.AnalyzedCommand(), $t.Command = statement, $t.Context = Kusto.Data.IntelliSense.KustoCommandContext.Empty, $t);
            },
            AnalyzeCommand: function (command, appendingPart) {
                var $t;
                return ($t = new Kusto.Data.IntelliSense.AnalyzedCommand(), $t.Command = (command.Command || "") + (appendingPart || ""), $t.Context = Kusto.Data.IntelliSense.KustoCommandContext.Empty, $t);
            },
            ResetState: function () { },
            LoadCommandToolTips: function () {
                this.CommandToolTips = new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.IntelliSenseCommandTip)).ctor();
            },
            UpdateProviderAvailableEntities: function (command, commandContext) { }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.DataManagerIntelliSenseRulesProvider, {
        f1: function (a) {
            return "\"" + (a || "") + "\"";
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.RegexIntelliSenseRule", {
        inherits: [Kusto.Data.IntelliSense.IntelliSenseRule],
        props: {
            MatchingRegex: null,
            Options: null,
            AdditionalOptions: null,
            RequiresFullCommand: {
                get: function () {
                    return false;
                }
            },
            IsContextual: {
                get: function () {
                    return false;
                }
            }
        },
        methods: {
            IsMatch: function (context, input) {
                // Code explicilty layed-out (instead of just retuning the IsMatch value)
                // to allow debugging
                var isMatch = this.MatchingRegex.isMatch(input);
                if (isMatch) {
                    return true;
                }
                return false;
            },
            GetOptions: function (context) {
                var result = this.Options.Values;
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CompletionOptionCollection, this.AdditionalOptions)) {
                    return result;
                }
                return System.Linq.Enumerable.from(result).union(System.Linq.Enumerable.from(this.AdditionalOptions).selectMany($asm.$.Kusto.Data.IntelliSense.RegexIntelliSenseRule.f1));
            },
            GetCompletionOptions: function (context) {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.CompletionOptionCollection, this.AdditionalOptions)) {
                    var result = this.Options.GetCompletionOptions();
                    return result;
                }

                // Order the completion option collections by their priority
                var sortedCollections = System.Linq.Enumerable.from(Bridge.fn.bind(this, $asm.$.Kusto.Data.IntelliSense.RegexIntelliSenseRule.f2)(new (System.Collections.Generic.List$1(Kusto.Data.IntelliSense.CompletionOptionCollection)).ctor())).concat(this.AdditionalOptions).orderByDescending($asm.$.Kusto.Data.IntelliSense.RegexIntelliSenseRule.f3);

                return sortedCollections.selectMany($asm.$.Kusto.Data.IntelliSense.RegexIntelliSenseRule.f4);
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.RegexIntelliSenseRule", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.RegexIntelliSenseRule, {
        f1: function (o) {
            return o.Values;
        },
        f2: function (_o1) {
            _o1.add(this.Options);
            return _o1;
        },
        f3: function (o) {
            return o.Priority;
        },
        f4: function (c) {
            return c.GetCompletionOptions();
        }
    });

    Bridge.define("Kusto.UT.IntelliSenseRulesTests.RemoteSchemaResolverMock", {
        inherits: [Kusto.Data.IntelliSense.IKustoIntelliSenseSchemaResolver],
        $kind: "nested class",
        fields: {
            s_dbMap: null,
            s_clusterDatabasesMap: null
        },
        alias: [
            "ResolveDatabaseNames", "Kusto$Data$IntelliSense$IKustoIntelliSenseSchemaResolver$ResolveDatabaseNames",
            "ResolveDatabaseSchema", "Kusto$Data$IntelliSense$IKustoIntelliSenseSchemaResolver$ResolveDatabaseSchema",
            "ResolveDatabaseSchema$1", "Kusto$Data$IntelliSense$IKustoIntelliSenseSchemaResolver$ResolveDatabaseSchema$1"
        ],
        ctors: {
            ctor: function () {
                var $t;
                this.$initialize();
                this.s_dbMap = new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity))();
                this.s_clusterDatabasesMap = new (System.Collections.Generic.Dictionary$2(System.String,System.Collections.Generic.List$1(System.String)))();
                var dbSchema = Kusto.UT.IntelliSenseRulesTests.GenerateKustoEntities(null, null);
                $t = Bridge.getEnumerator(System.Array.init([{ Item1: "", Item2: "db1" }, { Item1: "other", Item2: "db2" }], System.Object));
                try {
                    while ($t.moveNext()) {
                        var context = $t.Current;
                        var key = (context.Item1 || "") + ":" + (context.Item2 || "");
                        this.s_dbMap.set(key, System.Linq.Enumerable.from(dbSchema.Databases).first());

                        // Update cluster databases map
                        if (!this.s_clusterDatabasesMap.containsKey(context.Item1)) {
                            this.s_clusterDatabasesMap.set(context.Item1, new (System.Collections.Generic.List$1(System.String)).ctor());
                        }
                        this.s_clusterDatabasesMap.get(context.Item1).add(context.Item2);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }}
        },
        methods: {
            ResolveDatabaseNames: function (clusterUriOrAlias) {
                var result = { };
                this.s_clusterDatabasesMap.tryGetValue(clusterUriOrAlias, result);
                return result.v;
            },
            ResolveDatabaseSchema: function (clusterUriOrAlias, databaseNameOrAlias) {
                var key = (clusterUriOrAlias || "") + ":" + (databaseNameOrAlias || "");
                if (this.s_dbMap.containsKey(key)) {
                    return this.s_dbMap.get(key);
                }

                return null;
            },
            ResolveDatabaseSchema$1: function (clusterUriOrAlias, databaseNameOrAlias, tableName) {
                var key = (clusterUriOrAlias || "") + ":" + (databaseNameOrAlias || "");

                var databases = System.Linq.Enumerable.from(this.s_dbMap).where(function (db) {
                        return System.String.startsWith(db.key, (clusterUriOrAlias || "") + ":");
                    });

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.System.Collections.Generic.KeyValuePair$2(System.String,Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity), databases)) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedRegex.IsWildCardPattern(databaseNameOrAlias)) {
                        // filter databases according to pattern
                        var keyMatcher = Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(key);
                        var dbMatcher = Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(databaseNameOrAlias);

                        if (dbMatcher != null) {
                            databases = databases.where(function (db) {
                                return keyMatcher.isMatch(db.key) || dbMatcher.isMatch(db.value.Name) || dbMatcher.isMatch(db.value.Alias);
                            });
                        }
                    } else {
                        databases = databases.where(function (db) {
                            return System.String.equals(key, db.key, 5) || System.String.equals(databaseNameOrAlias, db.value.Name, 5) || System.String.equals(databaseNameOrAlias, db.value.Alias, 5);
                        });
                    }
                }

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.System.Collections.Generic.KeyValuePair$2(System.String,Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity), databases)) {
                    return null;
                }

                var tableMatcher = null;

                if (!System.String.isNullOrEmpty(tableName)) {
                    if (Kusto.Cloud.Platform.Utils.ExtendedRegex.IsWildCardPattern(tableName)) {
                        // filter tables according to pattern
                        tableMatcher = Kusto.Cloud.Platform.Utils.ExtendedRegex.TryTransformWildCardPatternToRegex(tableName);
                    }
                }

                var result = databases.select(function (db) {
                    var filteredDb = new Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity();
                    filteredDb.Name = db.value.Name;
                    filteredDb.Alias = db.value.Alias;
                    filteredDb.Tables = System.Linq.Enumerable.from(db.value.Tables).where(function (t) {
                            return (System.String.isNullOrEmpty(tableName) || (tableMatcher == null && Bridge.referenceEquals(tableName, t.Name)) || (tableMatcher != null && tableMatcher.isMatch(t.Name)));
                        });
                    filteredDb.Functions = db.value.Functions;
                    filteredDb.IsInitialized = db.value.IsInitialized;

                    return filteredDb;
                });

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastNone$1(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity, result)) {
                    return null;
                }

                return result;
            }
        }
    });

    Bridge.define("Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider", {
        inherits: [Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider],
        statics: {
            fields: {
                s_showCommandRegex: null,
                s_setCommandRegex: null,
                s_addCommandRegex: null,
                s_alterCommandRegex: null,
                s_alterMergeCommandRegex: null,
                s_deleteCommandRegex: null,
                s_createCommandRegex: null,
                s_dropCommandRegex: null,
                s_moveCommandRegex: null,
                s_attachCommandRegex: null,
                s_replaceCommandRegex: null,
                s_ingestionDuplicationCommandRegex: null,
                s_createOrAlterCommandRegex: null,
                s_purgeCommandRegex: null,
                s_purgeCleanupCommandRegex: null,
                s_createDatabaseCommandRegex: null,
                s_createDatabaseCommandEndingRegex: null,
                s_showDatabaseCommandRegex: null,
                s_showBasicAuthCommandRegex: null,
                s_showDatabasePrincipalsCommandRegex: null,
                s_showDatabasesCommandRegex: null,
                s_showClusterCommandRegex: null,
                s_showPrincipalCommandRegex: null,
                s_showFabricCommandRegex: null,
                s_addClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex: null,
                s_setClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex: null,
                s_addClusterBlockedPrincipalsCommandRegex: null,
                s_setClusterAdminsNoneCommandRegex: null,
                s_setClusterUsersNoneCommandRegex: null,
                s_setClusterViewersNoneCommandRegex: null,
                s_setClusterDatabaseCreatorsNoneCommandRegex: null,
                s_dropClusterAdminsUsersViewersDatabaseCreatorsCommandRegex: null,
                s_showTableOptionsCommandRegex: null,
                s_setDatabaseCommandRegex: null,
                s_addDatabaseCommandRegex: null,
                s_dropDatabaseCommandRegex: null,
                s_anySimpleSyntaxActionTableCommandRegex: null,
                s_anySimpleSyntaxActionFunctionCommandRegex: null,
                s_dropExtentTagsCommandRegex: null,
                s_alterExtentTagsCommandRegex: null,
                s_attachExtentsCommandRegex: null,
                s_attachExtentsIntoTableCommandRegex: null,
                s_attachExtentsIntoSpecifiedTableCommandRegex: null,
                s_moveExtentsCommandRegex: null,
                s_moveSpecifiedExtentsCommandRegex: null,
                s_moveExtentsFromSpecifiedTableCommandRegex: null,
                s_moveExtentsFromTableCommandRegex: null,
                s_moveExtentsToTableCommandRegex: null,
                s_replaceExtentsCommandRegex: null,
                s_replaceExtentsInTableCommandRegex: null,
                s_showExtentsInSpecifiedEntityCommandRegex: null,
                s_showExtentsInSpecifiedEntityWithTagFiltersCommandRegex: null,
                s_dropExtentTagsFromTableCommandRegex: null,
                s_setDatabaseAdminsUsersViewersPrettyNameCommandRegex: null,
                s_addDatabaseAdminsUsersViewersCommandRegex: null,
                s_dropDatabasePropertyCommandRegex: null,
                s_setTableAdminsCommandRegex: null,
                s_addTableAdminsCommandRegex: null,
                s_createTableEntitiesCommandRegex: null,
                s_alterTableEntitiesCommandRegex: null,
                s_alterMergeTableEntitiesCommandRegex: null,
                s_dropTableEntitiesCommandRegex: null,
                s_deleteTableEntitiesCommandRegex: null,
                s_dropTableColumnsSyntaxCommandRegex: null,
                s_alterFunctionEntitiesCommandRegex: null,
                s_setDatabaseAdminsNoneCommandRegex: null,
                s_setDatabaseUsersNoneCommandRegex: null,
                s_setDatabaseViewersNoneCommandRegex: null,
                s_setDatabaseIngestorsNoneCommandRegex: null,
                s_setTableAdminsNoneCommandRegex: null,
                s_setTableIngestorsNoneCommandRegex: null,
                s_appendTableCommandRegex: null,
                s_setOrAppendReplaceTableCommandRegex: null,
                s_clusterPolicyRegex: null,
                s_alterDatabaseRegex: null,
                s_databasePolicyRegex: null,
                s_tablePolicyRegex: null,
                s_columnPolicyRegex: null,
                s_policyCommandOnDatabase: null,
                s_policyCommand: null,
                s_alterMultiplePoliciesRegex: null,
                s_deleteMultiplePoliciesRegex: null,
                s_exportCommandRegex: null,
                s_exportCommandWithModifiersToRegex: null,
                s_exportCommandNoModifiersToRegex: null,
                s_duplicateIngestionIntoRegex: null,
                s_purgeWhatIfRegex: null,
                s_purgeWithPropertiesRegex: null,
                s_purgeTableRegex: null,
                s_purgeSpecifiedTableRegex: null,
                s_alterMergePolicyRetentionRegex: null,
                s_alterMergePolicyRetentionSoftDeleteDefinedRegex: null,
                s_alterMergePolicyRetentionOptionsRegex: null,
                s_createRowstoreCommandRegex: null,
                s_createRowstoreCommandEndingRegex: null,
                s_adminOperationOptions: null,
                s_showCommandOptions: null,
                s_clusterShowKeywordOptions: null,
                s_tableShowKeywordOptions: null,
                s_setAddCommandsOptions: null,
                s_dropCommandsOptions: null,
                s_attachCommandsOptions: null,
                s_moveCommandsOptions: null,
                s_replaceCommandsOptions: null,
                s_dropExtentTagsCommandsOptions: null,
                s_attachExtentsCommandsOptions: null,
                s_attachExtentsIntoSpecifedTableCommandsOptions: null,
                s_moveExtentsCommandsOptions: null,
                s_moveSpecifiedExtentsCommandsOptions: null,
                s_moveExtentsFromTableCommandsOptions: null,
                s_showExtentsByEntityCommandsOptions: null,
                s_showExtentsByEntityWithTagFiltersCommandsOptions: null,
                s_replaceExtentsCommandsOptions: null,
                s_alterCommandOptions: null,
                s_alterMergeAndDeleteCommandOptions: null,
                s_createCommandOptions: null,
                s_setUsersAdminsPrettyNameKeywordOptions: null,
                s_addSetDropUsersAdminsKeywordOptions: null,
                s_dropDatabaseKeywordOptions: null,
                s_setUsersAdminsViewersDatabaseCreatorsKeywordOptions: null,
                s_addDropUsersAdminsViewersDbCreatorsBlockedKeywordOptions: null,
                s_addClusterBlockedPrincipalsApplicationKeywordOptions: null,
                s_showBasicAuthUsersKeywordOptions: null,
                s_AddSetAdminsKeywordOptions: null,
                s_createTableEntitiesKeywordOptions: null,
                s_alterTableEntitiesKeywordOptions: null,
                s_alterMergeTableEntitiesKeywordOptions: null,
                s_dropTableEntitiesKeywordOptions: null,
                s_deleteTableEntitiesKeywordOptions: null,
                s_alterFunctionEntitiesKeywordOptions: null,
                s_DropColumnsSyntaxKeywordOptions: null,
                s_setNoneKeywordOptions: null,
                s_clusterPoliciesOptions: null,
                s_databasePoliciesOptions: null,
                s_tablePoliciesOptions: null,
                s_columnPoliciesOptions: null,
                s_multiplePoliciesOptions: null,
                s_multipleDeletionPoliciesOptions: null,
                s_databasePersistencyOptions: null,
                s_rowstorePersistencyOptions: null,
                s_ifNotExistsOptions: null,
                s_policyKeywordOptions: null,
                s_principalsPolicySchemaAndExtentsKeywordOptions: null,
                s_databasesShowKeywordOptions: null,
                s_exportFileFormatOptions: null,
                s_exportCommandOptions: null,
                s_alterDatabaseCommandOptions: null,
                s_duplicateIngestionCommandsOptions: null,
                s_purgeWhatIfCommandOptions: null,
                s_purgeTableCommandsOptions: null,
                s_purgeCleanupCommandsOptions: null,
                s_purgeCommandsOptions: null,
                s_purgeWithPropertiesCommandsOptions: null,
                s_showPrincipalKeywordOptions: null,
                s_showFabricKeywordOptions: null,
                s_alterMergePolicyRetentionOptions: null,
                s_alterMergePolicyRetentionSoftDeleteDefinedOptions: null,
                s_timeSpanPolicyOptions: null,
                s_createOrAlterOptions: null
            },
            ctors: {
                init: function () {
                    this.s_showCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter-merge\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_deleteCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_attachCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.attach\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_replaceCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.replace\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_ingestionDuplicationCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.dup-next-(failed-)?ingest\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createOrAlterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create-or-alter\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeCleanupCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge-cleanup\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+database\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createDatabaseCommandEndingRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+database\\s+\\w+\\s+(persist\\s+\\(.+\\)|volatile)\\s$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showBasicAuthCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+basicauth\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showDatabasePrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+database\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showDatabasesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+databases\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showClusterCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+cluster\\s$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showPrincipalCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+principal\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showFabricCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+fabric\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addClusterBlockedPrincipalsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+cluster\\s+blockedprincipals\\s+('(.*?)'|\"(.*?)\")\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterAdminsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+admins\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterUsersNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+users\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterViewersNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+viewers\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setClusterDatabaseCreatorsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+cluster\\s+databasecreators\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropClusterAdminsUsersViewersDatabaseCreatorsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+cluster\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showTableOptionsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropDatabaseCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_anySimpleSyntaxActionTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|create|add|set|alter|alter-merge|drop|delete)\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_anySimpleSyntaxActionFunctionCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|drop)\\s+function\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropExtentTagsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+extent\\s+tags\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterExtentTagsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+extent\\s+tags\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_attachExtentsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.attach\\s+(async\\s+)?extents\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_attachExtentsIntoTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.attach\\s+(async\\s+)?extents\\s+into\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_attachExtentsIntoSpecifiedTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.attach\\s+(async\\s+)?extents\\s+into\\s+table\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveExtentsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?extents\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveSpecifiedExtentsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?extents\\s+([A-Za-z0-9(),.-]+)\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveExtentsFromSpecifiedTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?extents\\s+([A-Za-z0-9(),.-]+)\\s+from\\s+table\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveExtentsFromTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?extents\\s+([A-Za-z0-9(),.-]+)\\s+from\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_moveExtentsToTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.move\\s+(async\\s+)?extents\\s+([A-Za-z0-9(),.-]+)\\s+from\\s+table\\s+\\S+\\s+to\\s+table\\s+$|^\\s*\\.move\\s+(async\\s+)?extents\\s+to\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_replaceExtentsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.replace\\s+(async\\s+)?extents\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_replaceExtentsInTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.replace\\s+(async\\s+)?extents\\s+in\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showExtentsInSpecifiedEntityCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+(database|table)\\s+\\S+\\s+extents\\s+$|^\\s*\\.show\\s+cluster\\s+extents\\s+$|^\\s*\\.show\\s+tables\\s+\\([^)]+\\)\\s+extents\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_showExtentsInSpecifiedEntityWithTagFiltersCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.show\\s+((database\\s+\\S+)|(table\\s+\\S+)|(tables\\s+\\([^)]+\\))|(cluster))\\s+extents\\s+(hot\\s+)?where\\s+tags\\s+((has|!has|contains|!contains)\\s+\\S+\\s+and\\s+tags\\s+)*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropExtentTagsFromTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+extent\\s+tags\\s+from\\s+table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseAdminsUsersViewersPrettyNameCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addDatabaseAdminsUsersViewersCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+database\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropDatabasePropertyCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setTableAdminsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_addTableAdminsCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.add\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createTableEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterTableEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergeTableEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter-merge\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropTableEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_deleteTableEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+table\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_dropTableColumnsSyntaxCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.drop\\s+table\\s+\\w+\\s+columns\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterFunctionEntitiesCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+function\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseAdminsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+\\w+\\s+admins\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseUsersNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+\\w+\\s+users\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseViewersNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+\\w+\\s+viewers\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setDatabaseIngestorsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+database\\s+\\w+\\s+ingestors\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setTableAdminsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+table\\s+\\w+\\s+admins\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setTableIngestorsNoneCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.set\\s+table\\s+\\w+\\s+ingestors\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_appendTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.append\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_setOrAppendReplaceTableCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(set-or-append|set-or-replace)\\s+(async\\s+)?$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_clusterPolicyRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|alter-merge|delete)\\s+cluster\\s+policy\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterDatabaseRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+database\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_databasePolicyRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|alter-merge|delete)\\s+database\\s+\\S+\\s+policy\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_tablePolicyRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|alter-merge|delete)\\s+table\\s+\\S+\\s+policy\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_columnPolicyRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|alter-merge|delete)\\s+column\\s+\\S+\\s+policy\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_policyCommandOnDatabase = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(show|alter|alter-merge|delete)\\s+database\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_policyCommand = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(alter|alter-merge|delete)\\s+column\\s+\\S+\\s+$|^\\s*\\.(alter|alter-merge|delete)\\s+cluster\\s+$|^\\s*\\.(alter-merge|delete)\\s+database\\s+\\S+\\s+$|^\\s*\\.show\\s+column\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMultiplePoliciesRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.alter\\s+policies\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_deleteMultiplePoliciesRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.delete\\s+policies\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_exportCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.export\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_exportCommandWithModifiersToRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.export\\s+(async|async compressed|compressed)\\s+to\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_exportCommandNoModifiersToRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.export\\s+to\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_duplicateIngestionIntoRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.dup-next-(failed-)?ingest\\s+into\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeWhatIfRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+(async\\s+)?whatif\\s*=\\s*$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeWithPropertiesRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+(async\\s+)?whatif\\s*=\\s*\\S+\\s+(maxRecords\\s*=\\s*\\d+\\s+)?$|^\\s*\\.purge\\s+(async\\s+)?maxRecords\\s*=\\s*\\d+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeTableRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+(async\\s+)?(whatif\\s*=\\s*\\S+\\s+)?(maxRecords\\s*=\\s*\\d+\\s+)?table\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_purgeSpecifiedTableRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.purge\\s+(async\\s+)?(whatif\\s*=\\s*\\S+\\s+)?(maxRecords\\s*=\\s*\\d+\\s+)?table\\s+\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergePolicyRetentionRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(alter-merge)\\s+(database|table)\\s+\\S+\\s+policy\\s+retention\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergePolicyRetentionSoftDeleteDefinedRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(alter-merge)\\s+(database|table)\\s+\\S+\\s+policy\\s+retention\\s+softdelete\\s*=\\s*\\S+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_alterMergePolicyRetentionOptionsRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.(alter-merge)\\s+(database|table)\\s+\\S+\\s+policy\\s+retention\\s+((softdelete\\s*=\\s*\\S+\\s+harddelete)|((soft|hard)delete))\\s*=\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createRowstoreCommandRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+rowstore\\s+\\w+\\s+$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_createRowstoreCommandEndingRegex = new System.Text.RegularExpressions.Regex.ctor("^\\s*\\.create\\s+rowstore\\s+\\w+\\s+(writeaheadlog\\s+\\(.+\\)|volatile)\\s$", Kusto.Data.IntelliSense.IntelliSenseRulesProviderBase.CommonRegexOptions);
                    this.s_adminOperationOptions = System.Array.init(["show", "alter", "alter-merge", "append", "attach", "create", "delete", "detach", "drop", "rename", "set-or-append", "set-or-replace", "set", "export", "move", "replace", "create-or-alter", "dup-next-ingest", "dup-next-failed-ingest", "seal table", "purge", "purge-cleanup"], System.String);
                    this.s_showCommandOptions = System.Linq.Enumerable.from(System.Array.init(["basicauth", "cache", "capacity", "cluster", "column", "database", "databases", "diagnostics", "extentcontainers", "fabric", "function", "functions", "ingestion failures", "journal", "memory", "operations", "schema", "table", "tables", "version", "queries", "commands", "principal", "rowstores", "rowstore", "rowstore transactions", "rowstore seals"], System.String)).orderBy($asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f1).ToArray(System.String);
                    this.s_clusterShowKeywordOptions = System.Array.init(["principals", "policy", "extents", "monitoring", "journal", "blockedprincipals", "databases", " "], System.String);
                    this.s_tableShowKeywordOptions = System.Array.init(["principals", "policy", "extents", "ingestion csv mappings", "ingestion json mappings", "rowstores", "rowstore_references", " "], System.String);
                    this.s_setAddCommandsOptions = System.Array.init(["database", "cluster", "table", "async"], System.String);
                    this.s_dropCommandsOptions = System.Array.init(["database", "cluster", "table", "tables", "function", "column", "extent tags", "extent", "extents", "rowstore"], System.String);
                    this.s_attachCommandsOptions = System.Array.init(["extents"], System.String);
                    this.s_moveCommandsOptions = System.Array.init(["extents"], System.String);
                    this.s_replaceCommandsOptions = System.Array.init(["extents"], System.String);
                    this.s_dropExtentTagsCommandsOptions = System.Array.init(["from table"], System.String);
                    this.s_attachExtentsCommandsOptions = System.Array.init(["into table", "by metadata"], System.String);
                    this.s_attachExtentsIntoSpecifedTableCommandsOptions = System.Array.init(["by metadata"], System.String);
                    this.s_moveExtentsCommandsOptions = System.Array.init(["all", "(GUID,...,GUID)", "to table"], System.String);
                    this.s_moveSpecifiedExtentsCommandsOptions = System.Array.init(["from table"], System.String);
                    this.s_moveExtentsFromTableCommandsOptions = System.Array.init(["to table"], System.String);
                    this.s_showExtentsByEntityCommandsOptions = System.Array.init(["hot", "where tags"], System.String);
                    this.s_showExtentsByEntityWithTagFiltersCommandsOptions = System.Array.init(["has", "!has", "contains", "!contains"], System.String);
                    this.s_replaceExtentsCommandsOptions = System.Array.init(["in table"], System.String);
                    this.s_alterCommandOptions = System.Array.init(["cluster", "column", "database", "function", "table", "policies", "extent tags"], System.String);
                    this.s_alterMergeAndDeleteCommandOptions = System.Array.init(["cluster", "column", "database", "table"], System.String);
                    this.s_createCommandOptions = System.Array.init(["database", "function", "table", "rowstore"], System.String);
                    this.s_setUsersAdminsPrettyNameKeywordOptions = System.Array.init(["users", "admins", "viewers", "ingestors", "monitors", "prettyname"], System.String);
                    this.s_addSetDropUsersAdminsKeywordOptions = System.Array.init(["users", "admins", "viewers", "ingestors", "monitors"], System.String);
                    this.s_dropDatabaseKeywordOptions = System.Array.init(["users", "admins", "viewers", "ingestors", "monitors", "prettyname"], System.String);
                    this.s_setUsersAdminsViewersDatabaseCreatorsKeywordOptions = System.Array.init(["users", "admins", "viewers", "databasecreators"], System.String);
                    this.s_addDropUsersAdminsViewersDbCreatorsBlockedKeywordOptions = System.Array.init(["users", "admins", "viewers", "databasecreators", "blockedprincipals"], System.String);
                    this.s_addClusterBlockedPrincipalsApplicationKeywordOptions = System.Array.init(["application", "user", "period", "reason"], System.String);
                    this.s_showBasicAuthUsersKeywordOptions = System.Array.init(["users"], System.String);
                    this.s_AddSetAdminsKeywordOptions = System.Array.init(["admins", "ingestors"], System.String);
                    this.s_createTableEntitiesKeywordOptions = System.Array.init(["ingestion csv mapping", "ingestion json mapping"], System.String);
                    this.s_alterTableEntitiesKeywordOptions = System.Array.init(["ingestion csv mapping", "ingestion json mapping", "docstring", "folder", "column-docstrings", "policy"], System.String);
                    this.s_alterMergeTableEntitiesKeywordOptions = System.Array.init(["column-docstrings", "policy"], System.String);
                    this.s_dropTableEntitiesKeywordOptions = System.Array.init(["admins", "ingestors", "columns", "ingestion csv mapping", "ingestion json mapping"], System.String);
                    this.s_deleteTableEntitiesKeywordOptions = System.Array.init(["policy"], System.String);
                    this.s_alterFunctionEntitiesKeywordOptions = System.Array.init(["docstring", "folder"], System.String);
                    this.s_DropColumnsSyntaxKeywordOptions = System.Array.init(["(COLUMN1,COLUMN2)"], System.String);
                    this.s_setNoneKeywordOptions = System.Array.init(["none"], System.String);
                    this.s_clusterPoliciesOptions = System.Array.init(["caching", "querythrottling", "capacity", "rowstore", "callout", "querylimit"], System.String);
                    this.s_databasePoliciesOptions = System.Array.init(["caching", "encoding", "merge", "retention", "sharding", "streamingingestion"], System.String);
                    this.s_tablePoliciesOptions = System.Array.init(["caching", "encoding", "merge", "ingestiontime", "retention", "roworder", "update", "sharding", "streamingingestion", "restricted_view_access"], System.String);
                    this.s_columnPoliciesOptions = System.Array.init(["caching", "encoding"], System.String);
                    this.s_multiplePoliciesOptions = System.Array.init(["of retention", "of encoding"], System.String);
                    this.s_multipleDeletionPoliciesOptions = System.Array.init(["of retention"], System.String);
                    this.s_databasePersistencyOptions = System.Array.init(["persist", "volatile"], System.String);
                    this.s_rowstorePersistencyOptions = System.Array.init(["writeaheadlog", "volatile"], System.String);
                    this.s_ifNotExistsOptions = System.Array.init(["ifnotexists", " "], System.String);
                    this.s_policyKeywordOptions = System.Array.init(["policy"], System.String);
                    this.s_principalsPolicySchemaAndExtentsKeywordOptions = System.Array.init(["principals", "policy", "schema", "extents", "journal", "purge operations", " "], System.String);
                    this.s_databasesShowKeywordOptions = System.Array.init(["identity", "policies", "datastats", " "], System.String);
                    this.s_exportFileFormatOptions = System.Array.init(["csv", "tsv", "json", "sql", "parquet"], System.String);
                    this.s_exportCommandOptions = System.Array.init(["async compressed", "async", "compressed", " "], System.String);
                    this.s_alterDatabaseCommandOptions = System.Array.init(["policy", "persist metadata", "prettyname"], System.String);
                    this.s_duplicateIngestionCommandsOptions = System.Array.init(["into"], System.String);
                    this.s_purgeWhatIfCommandOptions = System.Array.init(["info", "stats", "purge", "retain"], System.String);
                    this.s_purgeTableCommandsOptions = System.Array.init(["records"], System.String);
                    this.s_purgeCleanupCommandsOptions = System.Array.init(["until="], System.String);
                    this.s_purgeCommandsOptions = System.Array.init(["whatif =", "maxRecords =", "table"], System.String);
                    this.s_purgeWithPropertiesCommandsOptions = System.Array.init(["table"], System.String);
                    this.s_showPrincipalKeywordOptions = System.Array.init(["access", "roles", "@'principal' roles"], System.String);
                    this.s_showFabricKeywordOptions = System.Array.init(["clocks", "locks", "cache", "nodes", "services"], System.String);
                    this.s_alterMergePolicyRetentionOptions = System.Array.init(["softdelete", "harddelete"], System.String);
                    this.s_alterMergePolicyRetentionSoftDeleteDefinedOptions = System.Array.init(["harddelete"], System.String);
                    this.s_timeSpanPolicyOptions = System.Array.init(["1d", "7d", "30d", "90d", "365d"], System.String);
                    this.s_createOrAlterOptions = System.Array.init(["function"], System.String);
                }
            }
        },
        fields: {
            s_afterCreateDatabaseApplyPolicies: null,
            s_afterAlterDatabaseApplyPolicies: null,
            s_afterCreateRowStoreApplyPolicies: null,
            s_afterExportFile: null
        },
        ctors: {
            init: function () {
                this.s_afterCreateDatabaseApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f2(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterAlterDatabaseApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f3(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterCreateRowStoreApplyPolicies = $asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f4(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
                this.s_afterExportFile = $asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f5(new (System.Collections.Generic.Dictionary$2(System.String,Kusto.Data.IntelliSense.ApplyPolicy))());
            },
            $ctor1: function (cluster, schema, queryParameters, availableClusters, schemaResolver, allowQueryParameters, allowClientDirectives) {
                if (queryParameters === void 0) { queryParameters = null; }
                if (availableClusters === void 0) { availableClusters = null; }
                if (schemaResolver === void 0) { schemaResolver = null; }
                if (allowQueryParameters === void 0) { allowQueryParameters = false; }
                if (allowClientDirectives === void 0) { allowClientDirectives = false; }

                this.$initialize();
                Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.$ctor1.call(this, cluster, schema, queryParameters, availableClusters, schemaResolver, allowQueryParameters, allowClientDirectives);
                this.LoadRules$1();
            },
            ctor: function (other) {
                this.$initialize();
                Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.ctor.call(this, other);
                this.LoadRules$1();
            }
        },
        methods: {
            Clone$1: function () {
                return new Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.ctor(this);
            },
            LoadRules$1: function () {
                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, this.TableNames)) {
                    this.AddTableControlCommands();
                }

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(System.String, this.FunctionNames)) {
                    this.AddFunctionControlCommands();
                }

                this.AddControlCommandKeywords();
                this.AddPolicyControlCommands();
                this.AddMultiplePoliciesControlCommands();
                this.DeleteMultiplePoliciesControlCommands();
                this.AddPermissionsControlCommands();
                this.AddDatabaseCreateCommands();
                this.AddExportControlCommand();

                if (Kusto.Cloud.Platform.Utils.ExtendedEnumerable.SafeFastAny$4(Bridge.global.Kusto.Data.IntelliSense.KustoIntelliSenseDatabaseEntity, this.Databases)) {
                    this.AddDatabaseControlCommands(this.Databases);
                }

                this.AddDatabasesShowControlCommands();
                this.AddAddDropControlCommandKeywords();
                this.AddRowStoreControlCommands();
            },
            AddDatabaseCreateCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseCreatePersistencyOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_databasePersistencyOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterCreateDatabaseApplyPolicies, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateIfNotExistsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createDatabaseCommandEndingRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_ifNotExistsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddControlCommandKeywords: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAdminCommandsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslQueryIntelliSenseRulesProvider.s_lineWithDotBeginningRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Command, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_adminOperationOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowPrincipalCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showPrincipalCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showPrincipalKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowFabricOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showFabricCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showFabricKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddExportControlCommand: function () {
                var $t, $t1;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportCommandOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " to ", $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandWithModifiersAndOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportCommandWithModifiersToRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportFileFormatOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterExportFile, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldExportCommandNoModifiersAndOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportCommandNoModifiersToRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_exportFileFormatOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterExportFile, $t));
            },
            AddPermissionsControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowBasicAuthOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showBasicAuthCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showBasicAuthUsersKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowClusterPrincipalsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showClusterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_clusterShowKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterAdminsUsersViewersDatabaseCreatorsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setUsersAdminsViewersDatabaseCreatorsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addDropUsersAdminsViewersDbCreatorsBlockedKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropClusterAdminsUsersViewersDatabaseCreatorsBlockedPrincipalsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropClusterAdminsUsersViewersDatabaseCreatorsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addDropUsersAdminsViewersDbCreatorsBlockedKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddClusterBlockedPrincipalsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addClusterBlockedPrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addClusterBlockedPrincipalsApplicationKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterUsersNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setClusterUsersNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterAdminsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setClusterAdminsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterViewersNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setClusterViewersNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetClusterDatabaseCreatorsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setClusterDatabaseCreatorsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddPolicyControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_policyCommand, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_policyKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldClusterPoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_clusterPolicyRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_clusterPoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabasePoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_databasePolicyRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_databasePoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTablePoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_tablePolicyRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_tablePoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldColumnPoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_columnPolicyRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_columnPoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddMultiplePoliciesControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMultiplePoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMultiplePoliciesRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_multiplePoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            DeleteMultiplePoliciesControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteMultiplePoliciesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_deleteMultiplePoliciesRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_multipleDeletionPoliciesOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddDatabasesShowControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowDatabasesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showDatabasesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Policy, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_databasesShowKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddDatabaseControlCommands: function (databases) {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowDatabasePrincipalsPoliciesAndSchemaOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showDatabasePrincipalsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_principalsPolicySchemaAndExtentsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseAdminsUsersViewersPrettyNameOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseAdminsUsersViewersPrettyNameCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setUsersAdminsPrettyNameKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddDatabaseAdminsUsersViewersOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addDatabaseAdminsUsersViewersCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addSetDropUsersAdminsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropDatabaseOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropDatabasePropertyCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropDatabaseKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseUsersNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseUsersNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseAdminsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseAdminsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseViewersNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseViewersNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetDatabaseIngestorsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseIngestorsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                var orderedDatabases = System.Linq.Enumerable.from(databases).select($asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f6).orderBy($asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.f7).ToArray(System.String);
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, orderedDatabases), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, orderedDatabases), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, orderedDatabases), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropDatabaseCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, orderedDatabases), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDatabaseNames, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_policyCommandOnDatabase, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Database, orderedDatabases), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterDatabaseCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterDatabaseRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterDatabaseCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterAlterDatabaseApplyPolicies, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergePolicyRetentionRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergePolicyRetentionOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendAssignmentPolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergePolicyRetentionSoftDeleteDefinedOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergePolicyRetentionSoftDeleteDefinedRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergePolicyRetentionSoftDeleteDefinedOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendAssignmentPolicy, $t));


                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTimeSpanPolicyOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergePolicyRetentionOptionsRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_timeSpanPolicyOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddTableControlCommands: function () {
                var $t, $t1;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_appendTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setOrAppendReplaceTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showTableOptionsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_tableShowKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_anySimpleSyntaxActionTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropExtentTagsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropExtentTagsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropExtentTagsCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropExtentTagsFromTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " (@'')", $t1.OffsetPosition = -2, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterExtentTagsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterExtentTagsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Command, System.Array.init(["(@'') <| "], System.String)), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = "", $t1.OffsetPosition = -6, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachExtentsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachExtentsCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachExtentsIntoTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachExtentsIntoTableOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachExtentsIntoSpecifiedTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachExtentsIntoSpecifedTableCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveSpecifiedExtentsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveSpecifiedExtentsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveSpecifiedExtentsCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsFromTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveExtentsToTableOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsFromSpecifiedTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsFromTableCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveExtentsToTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showExtentsInSpecifiedEntityCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showExtentsByEntityCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldShowExtentsByEntityWithTagsFiltersOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showExtentsInSpecifiedEntityWithTagFiltersCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_showExtentsByEntityWithTagFiltersCommandsOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " @''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceExtentsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_replaceExtentsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_replaceExtentsCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_replaceExtentsInTableCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableAdminsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setTableAdminsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_AddSetAdminsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddTableAdminsOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addTableAdminsCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_AddSetAdminsKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createTableEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createTableEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterTableEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterTableEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergeTableEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergeTableEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropTableEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropTableEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteTableEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_deleteTableEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_deleteTableEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropTableColumnsSyntaxOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropTableColumnsSyntaxCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_DropColumnsSyntaxKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableAdminsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setTableAdminsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetTableIngestorsNoneOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setTableIngestorsNoneCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setNoneKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_duplicateIngestionIntoRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " to h@''", $t1.OffsetPosition = -1, $t1), $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWhatIfOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeWhatIfRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeWhatIfCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeWithPropertiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeWithPropertiesRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeWithPropertiesCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldTableNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeTableRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Table, this.TableNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeTableOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeSpecifiedTableRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeTableCommandsOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " <|", $t1), $t));
            },
            AddRowStoreControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldRowStoreCreatePersistencyOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createRowstoreCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_rowstorePersistencyOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t.AfterApplyPolicies = this.s_afterCreateRowStoreApplyPolicies, $t));
            },
            AddFunctionControlCommands: function () {
                var $t;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldFunctionNamesForAdminOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_anySimpleSyntaxActionFunctionCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.ExpressionFunction, this.FunctionNames), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterFunctionEntitiesOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterFunctionEntitiesCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterFunctionEntitiesKeywordOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));
            },
            AddAddDropControlCommandKeywords: function () {
                var $t, $t1;
                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldSetCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setAddCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAddCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_addCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_setAddCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDropCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_dropCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldMoveCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_moveCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAttachCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_attachCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldReplaceCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_replaceCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_replaceCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldAlterMergeCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergeAndDeleteCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldDeleteCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_deleteCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_alterMergeAndDeleteCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateCommandOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createCommandOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldCreateOrAlterOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createOrAlterCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_createOrAlterOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldIngestionDuplicationOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_ingestionDuplicationCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_duplicateIngestionCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeCommandsOptions), $t.DefaultAfterApplyPolicy = Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy, $t));

                this.CommandRules.add(($t = new Kusto.Data.IntelliSense.RegexIntelliSenseRule(), $t.Kind = Kusto.Data.IntelliSense.AdminEngineRuleKind.YieldPurgeCleanupOptions, $t.MatchingRegex = Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeCleanupCommandRegex, $t.Options = new Kusto.Data.IntelliSense.CompletionOptionCollection(Kusto.Data.IntelliSense.OptionKind.Option, Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider.s_purgeCleanupCommandsOptions), $t.DefaultAfterApplyPolicy = ($t1 = new Kusto.Data.IntelliSense.ApplyPolicy(), $t1.Text = " datetime()", $t1.OffsetPosition = -1, $t1), $t));
            }
        }
    });

    Bridge.ns("Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider", $asm.$);

    Bridge.apply($asm.$.Kusto.Data.IntelliSense.CslIntelliSenseRulesProvider, {
        f1: function (s) {
            return s;
        },
        f2: function (_o1) {
            var $t;
            _o1.add("volatile", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            _o1.add("persist", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (h@'', h@'') ", $t.OffsetPosition = -9, $t));
            return _o1;
        },
        f3: function (_o2) {
            var $t;
            _o2.add("policy", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            _o2.add("persist metadata", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " h'' ", $t.OffsetPosition = -2, $t));
            return _o2;
        },
        f4: function (_o3) {
            var $t;
            _o3.add("volatile", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            _o3.add("writeaheadlog", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (h@'', h@'') ", $t.OffsetPosition = -9, $t));
            return _o3;
        },
        f5: function (_o4) {
            var $t;
            _o4.add("csv", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (h@'')", $t.OffsetPosition = -2, $t));
            _o4.add("tsv", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (h@'')", $t.OffsetPosition = -2, $t));
            _o4.add("json", ($t = new Kusto.Data.IntelliSense.ApplyPolicy(), $t.Text = " (h@'')", $t.OffsetPosition = -2, $t));
            _o4.add("sql", Kusto.Data.IntelliSense.ApplyPolicy.AppendSpacePolicy);
            return _o4;
        },
        f6: function (t) {
            return t.Name;
        },
        f7: function (n) {
            return n;
        }
    });
});
49v'Ël!7cÖú=}      [Ö	Z[Ö	b?§êa[Öká   W    :https://kusto.azure.com/monaco-editor/min/vs/language/kusto/kusto.javascript.client.js necko:classified 1 strongly-framed 1 security-info FnhllAKWRHGAlo+ESXykKAAAAAAAAAAAwAAAAAAAAEaphjojH6pBabDSgSnsfLHeAAQAAgAAAAAAAAAAAAAAAAAAAAAB4vFIJp5wRkeyPxAQ9RJGKPqbqVvKO0mKuIl8ec8o/uhmCjImkVxP+7sgiYWmMt8FvcOXmlQiTNWFiWlrbpbqgwAAAAAAAAOKMIIDhjCCAm6gAwIBAgIERTJf7TANBgkqhkiG9w0BAQsFADCBijEUMBIGA1UEBhMLUG9ydFN3aWdnZXIxFDASBgNVBAgTC1BvcnRTd2lnZ2VyMRQwEgYDVQQHEwtQb3J0U3dpZ2dlcjEUMBIGA1UEChMLUG9ydFN3aWdnZXIxFzAVBgNVBAsTDlBvcnRTd2lnZ2VyIENBMRcwFQYDVQQDEw5Qb3J0U3dpZ2dlciBDQTAeFw0xNDEwMjgxMzEyMTBaFw0zODEwMjgxMzEyMTBaMF8xFDASBgNVBAYTC1BvcnRTd2lnZ2VyMRQwEgYDVQQKEwtQb3J0U3dpZ2dlcjEXMBUGA1UECxMOUG9ydFN3aWdnZXIgQ0ExGDAWBgNVBAMTD2t1c3RvLmF6dXJlLmNvbTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAIqft6Yog2ydao9n4L9WyptB/+Xg2yYiHfhtcFHTF02D1t9v7FyiCFGWZs+OFn8DboDaAnpGuDZ3QYYwuluoDydOVFEZcQAPf3fbXOTjJ7T0SVcKW+qC4ap2o4mk9DTkM8UPrBI6r4pUARuUTluL4syoEuKkMRHOBR7vHN6pVWTSLSV2H3JA4iTdi7NwFH2KBIS7DmqVp2Yxi9codgz1hnPRHtrExzzEC1p0rsL0p8U98QjktLaeGbLi8GtOAXJiF+QS8p+YiPodNfQhIUIALaWVwEukQNy6Jbvq0AenWlcN5a1J5pXfoB45y12V5WCtuawazd+7qmm5FxaMRlRuMTcCAwEAAaMeMBwwGgYDVR0RBBMwEYIPa3VzdG8uYXp1cmUuY29tMA0GCSqGSIb3DQEBCwUAA4IBAQBe2Dugc55iC3o4JcQg2ltjYLMbUF3OZR848/8FjQsQezOmljrfduap//KIs3ptCRsUTso55IQX+oozo9DZlr/0j/JmtX9G3CsPraOMauBBOAWtvZSowN6P9iLn1HE7Mr8NQhUnGpF13mGT0tI4H6FQ+mK0OyfUOh6i7Fi2E6nO0++UJYfrO5B+FHGR/dBNSH8kwlVh1w/i4fBKOICdfLPzaWqXigp0TTgrcXJ33EeLc3lDaZqJNgRzMI1Jo/8llnWFkBHt/ydooCp+Cg8ncfNZjGBRwEcbMBLXCx5GZeCJkRzCaX50gG6Og0lfoVHtIZvwSs4d6JE/CcaLVr5jFRUvwC8BAwAAAAABAQAAAAA= request-method GET request-Accept-Encoding gzip, deflate, br response-head HTTP/1.1 200 OK
Content-Type: application/x-javascript
Last-Modified: Thu, 25 Oct 2018 21:23:32 GMT
Accept-Ranges: bytes
Etag: "0e2e1faa86cd41:0"
Vary: Accept-Encoding
Server: Microsoft-IIS/10.0
X-Powered-By: ASP.NET
Strict-Transport-Security: max-age=31536000; includeSubDomains
Date: Sun, 28 Oct 2018 19:27:29 GMT
Content-Length: 1816546
 original-response-headers Content-Type: application/x-javascript
Last-Modified: Thu, 25 Oct 2018 21:23:32 GMT
Accept-Ranges: bytes
Etag: "0e2e1faa86cd41:0"
Vary: Accept-Encoding
Server: Microsoft-IIS/10.0
X-Powered-By: ASP.NET
Strict-Transport-Security: max-age=31536000; includeSubDomains
Date: Sun, 28 Oct 2018 19:27:29 GMT
Connection: close
Content-Length: 1816546
 uncompressed-len 0 net-response-time-onstart 7424 net-response-time-onstop 7466  ·â